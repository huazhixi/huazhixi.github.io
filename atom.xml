<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ivan&#39;s Blog</title>
  
  <subtitle>华曦之家</subtitle>
  <link href="http://www.hxtec.top/atom.xml" rel="self"/>
  
  <link href="http://www.hxtec.top/"/>
  <updated>2022-09-17T09:58:41.299Z</updated>
  <id>http://www.hxtec.top/</id>
  
  <author>
    <name>ivan_华之曦</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Block - __block本质</title>
    <link href="http://www.hxtec.top/2022/09/17/Block-block%E6%9C%AC%E8%B4%A8/"/>
    <id>http://www.hxtec.top/2022/09/17/Block-block%E6%9C%AC%E8%B4%A8/</id>
    <published>2022-09-17T09:54:02.000Z</published>
    <updated>2022-09-17T09:58:41.299Z</updated>
    
    <content type="html"><![CDATA[<h2 id="block修饰符"><a href="#block修饰符" class="headerlink" title="__block修饰符"></a>__block修饰符</h2><ul><li>__block可以用于解决block内部无法修改auto变量值的问题</li><li>__block不能修饰全局变量、静态变量（static）</li><li>编译器会将__block变量包装成一个对象</li></ul><blockquote><p>示例1：__block修饰auto常量时</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">__block int age = 10;</span><br><span class="line">^&#123;</span><br><span class="line">    NSLog(@&quot;age is %d&quot;, age);</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line">//C++源码分析</span><br><span class="line">//block对象信息</span><br><span class="line">struct __block_impl &#123;</span><br><span class="line">    void *isa;</span><br><span class="line">    int Flags;</span><br><span class="line">    int Reserved;</span><br><span class="line">    void *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//block描述信息，大小，copy, dispose操作</span><br><span class="line">struct __main_block_desc_0 &#123;</span><br><span class="line">    size_t reserved;</span><br><span class="line">    size_t Block_size;</span><br><span class="line">    void (*copy)(void);</span><br><span class="line">    void (*dispose)(void);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//被包装成__Block_byref_age_0结构体</span><br><span class="line">struct __Block_byref_age_0 &#123;</span><br><span class="line">  void *__isa;</span><br><span class="line">__Block_byref_age_0 *__forwarding;</span><br><span class="line"> int __flags;</span><br><span class="line"> int __size;</span><br><span class="line"> int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//block结构体内容</span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  NSObject *p;</span><br><span class="line">  </span><br><span class="line">  //被包装成一个函数</span><br><span class="line">  __Block_byref_age_0 *age; // by ref</span><br><span class="line">  </span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, NSObject *_p, __Block_byref_age_0 *_age, int flags=0) : p(_p), age(_age-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>示例1：__block修饰对象时</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">//ARC环境下，编译器会对block进行copy操作。</span><br><span class="line">Person *person = [[Person alloc] init];</span><br><span class="line">Block block = ^&#123;</span><br><span class="line">    NSLog(@&quot;%p&quot;, person);</span><br><span class="line">&#125;;</span><br><span class="line">block();</span><br><span class="line">        </span><br><span class="line">//C++源码解析：</span><br><span class="line">struct __block_impl &#123;</span><br><span class="line">    void *isa;</span><br><span class="line">    int Flags;</span><br><span class="line">    int Reserved;</span><br><span class="line">    void *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct __main_block_desc_0 &#123;</span><br><span class="line">    size_t reserved;</span><br><span class="line">    size_t Block_size;</span><br><span class="line">    void (*copy)(void);</span><br><span class="line">    void (*dispose)(void);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct __Block_byref_weakPerson_0 &#123;</span><br><span class="line">  void *__isa; // 8</span><br><span class="line"> __Block_byref_weakPerson_0 *__forwarding; // 8</span><br><span class="line"> int __flags; // 4</span><br><span class="line"> int __size; // 4</span><br><span class="line"> </span><br><span class="line"> //内存管理相关</span><br><span class="line"> void (*__Block_byref_id_object_copy)(void*, void*); // 8</span><br><span class="line"> void (*__Block_byref_id_object_dispose)(void*); // 8</span><br><span class="line"> </span><br><span class="line"> Person *__weak weakPerson;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  </span><br><span class="line">  __Block_byref_weakPerson_0 *weakPerson; // by ref</span><br><span class="line">  </span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_weakPerson_0 *_weakPerson, int flags=0) : weakPerson(_weakPerson-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="block的内存管理"><a href="#block的内存管理" class="headerlink" title="__block的内存管理"></a>__block的内存管理</h2><ul><li>当block在栈上时，并不会对__block变量产生强引用</li><li>当block被copy到堆时<ul><li>会调用block内部的copy函数</li><li>copy函数内部会调用_Block_object_assign函数</li><li>_Block_object_assign函数会对__block变量形成强引用（retain）</li></ul></li><li>当block从堆中移除时<ul><li>会调用block内部的dispose函数</li><li>dispose函数内部会调用_Block_object_dispose函数</li><li>_Block_object_dispose函数会自动释放引用的__block变量（release）</li></ul></li></ul><h3 id="block的-forwarding指针"><a href="#block的-forwarding指针" class="headerlink" title="__block的__forwarding指针"></a>__block的__forwarding指针</h3><ul><li>在栈上的话，__forwarding指向自己</li><li>在堆上的话，__forwarding指向复制到堆上的的__block变量结构体的指针</li></ul><h3 id="对象类型的auto变量、-block变量"><a href="#对象类型的auto变量、-block变量" class="headerlink" title="对象类型的auto变量、__block变量"></a>对象类型的auto变量、__block变量</h3><ul><li>当block在栈上时，对它们都不会产生强引用</li><li>当block拷贝到堆上时，都会通过copy函数来处理它们<ul><li>__block变量（假设变量名叫做a）</li><li>_Block_object_assign((void*)&amp;dst-&gt;a, (void*)src-&gt;a, 8&#x2F;<em>BLOCK_FIELD_IS_BYREF</em>&#x2F;);</li></ul></li><li>对象类型的auto变量（假设变量名叫做p）<ul><li>_Block_object_assign((void*)&amp;dst-&gt;p, (void*)src-&gt;p, 3&#x2F;<em>BLOCK_FIELD_IS_OBJECT</em>&#x2F;);</li></ul></li><li>当block从堆上移除时，都会通过dispose函数来释放它们<ul><li>__block变量（假设变量名叫做a）</li><li>_Block_object_dispose((void*)src-&gt;a, 8&#x2F;<em>BLOCK_FIELD_IS_BYREF</em>&#x2F;);</li></ul></li><li>对象类型的auto变量（假设变量名叫做p）<ul><li>_Block_object_dispose((void*)src-&gt;p, 3&#x2F;<em>BLOCK_FIELD_IS_OBJECT</em>&#x2F;);</li></ul></li></ul><h3 id="被-block修饰的对象类型"><a href="#被-block修饰的对象类型" class="headerlink" title="被__block修饰的对象类型"></a>被__block修饰的对象类型</h3><ul><li>当__block变量在栈上时，不会对指向的对象产生强引用</li><li>当__block变量被copy到堆时<ul><li>会调用__block变量内部的copy函数</li><li>copy函数内部会调用_Block_object_assign函数</li><li>_Block_object_assign函数会根据所指向对象的修饰符（__strong、__weak、__unsafe_unretained）做出相应的操作，形成强引用（retain）或者弱引用（ <code>注意：这里仅限于ARC时会retain，MRC时不会retain </code>）</li></ul></li><li>如果__block变量从堆上移除<ul><li>会调用__block变量内部的dispose函数</li><li>dispose函数内部会调用_Block_object_dispose函数</li><li>_Block_object_dispose函数会自动释放指向的对象（release）</li></ul></li></ul><h3 id="循环引用问题"><a href="#循环引用问题" class="headerlink" title="循环引用问题"></a>循环引用问题</h3><h4 id="解决循环引用问题-ARC"><a href="#解决循环引用问题-ARC" class="headerlink" title="解决循环引用问题 - ARC"></a>解决循环引用问题 - ARC</h4><blockquote><p>用__weak、__unsafe_unretained解决</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//用__weak解决</span><br><span class="line">__weak typeof(self) weakSelf = self;</span><br><span class="line">self.block = ^&#123;</span><br><span class="line">    NSLog(@&quot;%p&quot;, weakSelf);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//用__unsafe_unretained解决</span><br><span class="line">__unsafe_unretained id weakSelf = self;</span><br><span class="line">self.block = ^&#123;</span><br><span class="line">    NSLog(@&quot;%p&quot;, weakSelf);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">注：</span><br><span class="line">// __weak：不会产生强引用，指向的对象销毁时，会自动让指针置为nil</span><br><span class="line">// __unsafe_unretained：不会产生强引用，不安全，指向的对象销毁时，指针存储的地址值不变</span><br></pre></td></tr></table></figure><blockquote><p>用__block解决（必须要调用block）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__block id weakSelf = self;</span><br><span class="line">self.block = ^&#123;</span><br><span class="line">    NSLog(@&quot;%p&quot;, weakSelf);</span><br><span class="line">    weakSelf = nil;</span><br><span class="line">&#125;;</span><br><span class="line">self.block()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;block修饰符&quot;&gt;&lt;a href=&quot;#block修饰符&quot; class=&quot;headerlink&quot; title=&quot;__block修饰符&quot;&gt;&lt;/a&gt;__block修饰符&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;__block可以用于解决block内部无法修改auto变量值的问题&lt;/</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="底层原理" scheme="http://www.hxtec.top/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    <category term="Category" scheme="http://www.hxtec.top/tags/Category/"/>
    
  </entry>
  
  <entry>
    <title>Block - 本质认识，变量捕获，类型</title>
    <link href="http://www.hxtec.top/2022/09/17/Block-%E6%9C%AC%E8%B4%A8%E8%AE%A4%E8%AF%86%EF%BC%8C%E5%8F%98%E9%87%8F%E6%8D%95%E8%8E%B7%EF%BC%8C%E7%B1%BB%E5%9E%8B/"/>
    <id>http://www.hxtec.top/2022/09/17/Block-%E6%9C%AC%E8%B4%A8%E8%AE%A4%E8%AF%86%EF%BC%8C%E5%8F%98%E9%87%8F%E6%8D%95%E8%8E%B7%EF%BC%8C%E7%B1%BB%E5%9E%8B/</id>
    <published>2022-09-17T09:45:57.000Z</published>
    <updated>2022-09-17T09:51:48.316Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本认识"><a href="#基本认识" class="headerlink" title="基本认识"></a>基本认识</h2><ul><li>block本质上也是一个OC对象，它内部也有个isa指针</li><li>block是封装了函数调用以及函数调用环境的OC对象</li><li>以下是一个block：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int age = 20;</span><br><span class="line">        </span><br><span class="line">void (^block)(int, int) =  ^(int a , int b)&#123;</span><br><span class="line">    NSLog(@&quot;this is a block! -- %d&quot;, age);</span><br><span class="line">&#125;;</span><br><span class="line">block()</span><br></pre></td></tr></table></figure></li></ul><h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_desc_0 &#123;</span><br><span class="line">    size_t reserved;</span><br><span class="line">    size_t Block_size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct __block_impl &#123;</span><br><span class="line">    void *isa;</span><br><span class="line">    int Flags;</span><br><span class="line">    int Reserved;</span><br><span class="line">    void *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">    struct __block_impl impl;</span><br><span class="line">    struct __main_block_desc_0* Desc;</span><br><span class="line">    int age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="block变量捕获"><a href="#block变量捕获" class="headerlink" title="block变量捕获"></a>block变量捕获</h3><ul><li>为了保证block内部能够正常访问外部的变量，block有个变量捕获机制<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">变量类型        捕获到block内部         访问方式</span><br><span class="line">局部变量          auto    √            值传递</span><br><span class="line">               static    √            指针传递</span><br><span class="line">全局变量                  ×            直接访问</span><br></pre></td></tr></table></figure></li></ul><h3 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h3><blockquote><p>auto和static局部变量捕获</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">void test &#123;</span><br><span class="line">    auto int a = 10;</span><br><span class="line">    static int b = 10;</span><br><span class="line">    block = ^&#123;</span><br><span class="line">        NSLog(@&quot;age is %d, height is %d&quot;, a, b);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//prama mark: - 编译后的源码</span><br><span class="line"></span><br><span class="line">struct __test_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __test_block_desc_0* Desc;</span><br><span class="line">  int a;//值传递</span><br><span class="line">  int *b;//指针传递</span><br><span class="line">  __test_block_impl_0(void *fp, struct __test_block_desc_0 *desc, int _a, int *_b, int flags=0) : a(_a), b(_b) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __test_block_func_0(struct __test_block_impl_0 *__cself) &#123;</span><br><span class="line">  int a = __cself-&gt;a; // bound by copy，值传递</span><br><span class="line">  int *b = __cself-&gt;b; // bound by copy 指针传递</span><br><span class="line"></span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_2r__m13fp2x2n9dvlr8d68yry500000gn_T_main_fd2a14_mi_0, a, (*b));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">static struct __test_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __test_block_desc_0_DATA = &#123; 0, sizeof(struct __test_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    auto int a = 10;</span><br><span class="line">    static int b = 10;</span><br><span class="line">    block = ((void (*)())&amp;__test_block_impl_0((void *)__test_block_func_0, &amp;__test_block_desc_0_DATA, a, &amp;b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="block类型"><a href="#block类型" class="headerlink" title="block类型"></a>block类型</h3><ul><li>block有3种类型，可以通过调用class方法或者isa指针查看具体类型，最终都是继承自NSBlock类型<ul><li><strong>NSGlobalBlock</strong> （ _NSConcreteGlobalBlock ）（数据区）</li><li><strong>NSStackBlock</strong> （ _NSConcreteStackBlock ）（栈区）</li><li><strong>NSMallocBlock</strong> （ _NSConcreteMallocBlock ）（堆区）</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// Global：没有访问auto变量</span><br><span class="line">void (^block1)(void) = ^&#123;</span><br><span class="line">    NSLog(@&quot;block1---------&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">// Stack：访问了auto变量</span><br><span class="line">int age = 10;</span><br><span class="line">void (^block2)(void) = ^&#123;</span><br><span class="line">    NSLog(@&quot;block2---------%d&quot;, age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// NSMallocBlock（MRC环境下）</span><br><span class="line">//对stack类型的block进行copy操作，就会变成malloc类型的block</span><br><span class="line">int age = 10;</span><br><span class="line">block = [^&#123;</span><br><span class="line">    NSLog(@&quot;block---------%d&quot;, age);</span><br><span class="line">&#125; copy];</span><br><span class="line">[block release];</span><br></pre></td></tr></table></figure><blockquote><p> block父类层级结构，如下：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// __NSGlobalBlock__ : __NSGlobalBlock : NSBlock : NSObject</span><br><span class="line">void (^block)(void) = ^&#123;</span><br><span class="line">    NSLog(@&quot;Hello&quot;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@&quot;, [block class]);</span><br><span class="line">NSLog(@&quot;%@&quot;, [[block class] superclass]);</span><br><span class="line">NSLog(@&quot;%@&quot;, [[[block class] superclass] superclass]);</span><br><span class="line">NSLog(@&quot;%@&quot;, [[[[block class] superclass] superclass] superclass]);</span><br></pre></td></tr></table></figure><h3 id="block的copy"><a href="#block的copy" class="headerlink" title="block的copy"></a>block的copy</h3><ul><li>在ARC环境下，编译器会根据情况自动将栈上的block复制到堆上，比如以下情况<ul><li>block作为函数返回值时</li><li>将block赋值给__strong指针时</li><li>block作为Cocoa API中方法名含有usingBlock的方法参数时</li><li>block作为GCD API的方法参数时</li></ul></li><li>MRC下block属性的建议写法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (copy, nonatomic) void (^block)(void);</span><br></pre></td></tr></table></figure></li><li>ARC下block属性的建议写法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@property (strong, nonatomic) void (^block)(void);</span><br><span class="line">@property (copy, nonatomic) void (^block)(void);</span><br></pre></td></tr></table></figure></li></ul><h3 id="对象类型的auto变量"><a href="#对象类型的auto变量" class="headerlink" title="对象类型的auto变量"></a>对象类型的auto变量</h3><ul><li>当block内部访问了对象类型的auto变量时，如果block是在栈上，将不会对auto变量产生强引用</li><li>如果block被拷贝到堆上，会调用block内部的copy函数<ul><li>copy函数内部会调用<code>_Block_object_assign</code>函数</li><li><code>_Block_object_assign</code>函数会根据auto变量的修饰符（__strong、__weak、__unsafe_unretained）做出相应的操作，形成强引用（retain）或者弱引用</li></ul></li><li>如果block从堆上移除，会调用block内部的dispose函数<ul><li>dispose函数内部会调用<code>_Block_object_dispose</code>函数</li><li><code>_Block_object_dispose</code>会自动释放引用的auto变量（release）</li></ul></li></ul><blockquote><p>代码解析：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">typedef void (^Block)(void);</span><br><span class="line">Block block;</span><br><span class="line">&#123;</span><br><span class="line">    Person *person = [[Person alloc] init];</span><br><span class="line">    person.age = 10;</span><br><span class="line"></span><br><span class="line">    //__weak Person *weakPerson = person;</span><br><span class="line">    block = ^&#123;</span><br><span class="line">        NSLog(@&quot;---------%d&quot;, person.age);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//编译后的源代码 </span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  MJPerson *__strong person;//由于没有使用weakPerson,所以这里是strong</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, MJPerson *__strong _person, int flags=0) : person(_person) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  MJPerson *__strong person = __cself-&gt;person; // bound by copy</span><br><span class="line"></span><br><span class="line">                NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_2r__m13fp2x2n9dvlr8d68yry500000gn_T_main_c41e64_mi_0, ((int (*)(id, SEL))(void *)objc_msgSend)((id)person, sel_registerName(&quot;age&quot;)));</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;</span><br><span class="line">    _Block_object_assign((void*)&amp;dst-&gt;person,//对block进行一个引用计数的操作，外界是strong，retain就引用计数加1，外界是weak就是一个弱引用。</span><br><span class="line">    (void*)src-&gt;person, 3/*BLOCK_FIELD_IS_OBJECT*/);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;person, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class="line"></span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);// 将栈上的bock，复制到椎上</span><br><span class="line">  void (*dispose)(struct __main_block_impl_0*);//堆上的block被废弃时，进行dispose操作</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="weak问题解决"><a href="#weak问题解决" class="headerlink" title="__weak问题解决"></a>__weak问题解决</h3><ul><li>ARC环境下，默认对block进行一个copy操作</li><li>在使用clang转换OC为C++代码时，可能会遇到以下问题<ul><li>cannot create __weak reference in file using manual reference</li></ul></li><li>解决方案：支持ARC、指定运行时系统版本，比如<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基本认识&quot;&gt;&lt;a href=&quot;#基本认识&quot; class=&quot;headerlink&quot; title=&quot;基本认识&quot;&gt;&lt;/a&gt;基本认识&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;block本质上也是一个OC对象，它内部也有个isa指针&lt;/li&gt;
&lt;li&gt;block是封装了函数调用以及函数调</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="底层原理" scheme="http://www.hxtec.top/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    <category term="Block" scheme="http://www.hxtec.top/tags/Block/"/>
    
  </entry>
  
  <entry>
    <title>Category - 关联对象</title>
    <link href="http://www.hxtec.top/2022/09/17/Category-%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/"/>
    <id>http://www.hxtec.top/2022/09/17/Category-%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/</id>
    <published>2022-09-17T09:40:41.000Z</published>
    <updated>2022-09-17T09:42:46.420Z</updated>
    
    <content type="html"><![CDATA[<h4 id="关联对象"><a href="#关联对象" class="headerlink" title="关联对象"></a>关联对象</h4><ul><li>默认情况下，因为分类底层结构的限制，不能添加&#x3D;&#x3D;成员变量&#x3D;&#x3D;到分类中,但可以通过&#x3D;&#x3D;关联对象&#x3D;&#x3D;来间接实现</li><li>关联对象提供了以下API：<ul><li>添加关联对象<ul><li>void objc_setAssociatedObject(id object, const void * key,<br>                  id value, objc_AssociationPolicy policy)</li></ul></li><li>获得关联对象<ul><li>id objc_getAssociatedObject(id object, const void * key)</li></ul></li><li>移除所有的关联对象<ul><li>void objc_removeAssociatedObjects(id object)</li></ul></li></ul></li></ul><h4 id="key的常见用法"><a href="#key的常见用法" class="headerlink" title="key的常见用法"></a>key的常见用法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static void *MyKey = &amp;MyKey;</span><br><span class="line">objc_setAssociatedObject(obj, MyKey, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><br><span class="line">objc_getAssociatedObject(obj, MyKey)</span><br><span class="line"></span><br><span class="line">static char MyKey;</span><br><span class="line">objc_setAssociatedObject(obj, &amp;MyKey, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><br><span class="line">objc_getAssociatedObject(obj, &amp;MyKey)</span><br><span class="line"></span><br><span class="line">使用属性名作为key</span><br><span class="line">objc_setAssociatedObject(obj, @&quot;property&quot;, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">objc_getAssociatedObject(obj, @&quot;property&quot;);</span><br><span class="line"></span><br><span class="line">使用get方法的@selecor作为key</span><br><span class="line">objc_setAssociatedObject(obj, @selector(getter), value, OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><br><span class="line">objc_getAssociatedObject(obj, @selector(getter))</span><br></pre></td></tr></table></figure><ul><li>objc_AssociationPolicy，关联策略<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">objc_AssociationPolicy                    对应的修饰符</span><br><span class="line">OBJC_ASSOCIATION_ASSIGN                        assign</span><br><span class="line">OBJC_ASSOCIATION_RETAIN_NONATOMIC       strong, nonatomic</span><br><span class="line">OBJC_ASSOCIATION_COPY_NONATOMIC         copy, nonatomic</span><br><span class="line">OBJC_ASSOCIATION_RETAIN                    strong, atomic</span><br><span class="line">OBJC_ASSOCIATION_COPY                    copy, atomic</span><br></pre></td></tr></table></figure></li></ul><h4 id="关联对象的原理"><a href="#关联对象的原理" class="headerlink" title="关联对象的原理"></a>关联对象的原理</h4><ul><li>实现关联对象技术的核心对象有<ul><li>AssociationsManager</li><li>AssociationsHashMap</li><li>ObjectAssociationMap</li><li>ObjcAssociation</li></ul></li></ul><h5 id="objc4源码：objc-references-mm"><a href="#objc4源码：objc-references-mm" class="headerlink" title="objc4源码：objc-references.mm"></a>objc4源码：objc-references.mm</h5><blockquote><p>AssociationsManager</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class AssociationsManager &#123;</span><br><span class="line">    // associative references: object pointer -&gt; PtrPtrHashMap.</span><br><span class="line">    static AssociationsHashMap *_map;</span><br><span class="line">public:</span><br><span class="line">    AssociationsManager()   &#123; AssociationsManagerLock.lock(); &#125;</span><br><span class="line">    ~AssociationsManager()  &#123; AssociationsManagerLock.unlock(); &#125;</span><br><span class="line">    </span><br><span class="line">    // </span><br><span class="line">    AssociationsHashMap &amp;associations() &#123;</span><br><span class="line">        if (_map == NULL)</span><br><span class="line">            _map = new AssociationsHashMap();</span><br><span class="line">        return *_map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>AssociationsHashMap</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class AssociationsHashMap : public unordered_map&lt;disguised_ptr_t, ObjectAssociationMap *, DisguisedPointerHash, DisguisedPointerEqual, AssociationsHashMapAllocator&gt; &#123;</span><br><span class="line">public:</span><br><span class="line">    void *operator new(size_t n) &#123; return ::malloc(n); &#125;</span><br><span class="line">    void operator delete(void *ptr) &#123; ::free(ptr); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>ObjectAssociationMap</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class ObjectAssociationMap : public std::map&lt;void *, ObjcAssociation, ObjectPointerLess, ObjectAssociationMapAllocator&gt; &#123;</span><br><span class="line">public:</span><br><span class="line">    void *operator new(size_t n) &#123; return ::malloc(n); &#125;</span><br><span class="line">    void operator delete(void *ptr) &#123; ::free(ptr); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>ObjcAssociation</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class ObjcAssociation &#123;</span><br><span class="line">    </span><br><span class="line">    uintptr_t _policy;</span><br><span class="line">    id _value;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    ObjcAssociation(uintptr_t policy, id value) : _policy(policy), _value(value) &#123;&#125;</span><br><span class="line">    ObjcAssociation() : _policy(0), _value(nil) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    uintptr_t policy() const &#123; return _policy; &#125;</span><br><span class="line">    id value() const &#123; return _value; &#125;</span><br><span class="line">    </span><br><span class="line">    bool hasValue() &#123; return _value != nil; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><strong>notes:</strong></p></blockquote><ul><li>关联对象并不是存储在被关联对象本身内存中</li><li>关联对象存储在全局的统一的一个AssociationsManager中</li><li>设置关联对象为nil，就相当于是移除关联对象</li><li>即为以下的关系：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">AssociationsManager</span><br><span class="line">AssociationsHashMap *_map;</span><br><span class="line"></span><br><span class="line">AssociationsHashMap</span><br><span class="line">disguised_ptr_t    ObjectAssociationMap</span><br><span class="line">disguised_ptr_t    ObjectAssociationMap</span><br><span class="line">...    ...</span><br><span class="line"></span><br><span class="line">AssociationsMap</span><br><span class="line">void *    ObjectAssociation</span><br><span class="line">void *    ObjectAssociation</span><br><span class="line">...    ...</span><br><span class="line"></span><br><span class="line">ObjectAssociation</span><br><span class="line">uintptr_t _policy;</span><br><span class="line">id _value;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;关联对象&quot;&gt;&lt;a href=&quot;#关联对象&quot; class=&quot;headerlink&quot; title=&quot;关联对象&quot;&gt;&lt;/a&gt;关联对象&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;默认情况下，因为分类底层结构的限制，不能添加&amp;#x3D;&amp;#x3D;成员变量&amp;#x3D;&amp;#x3D;到分类中,但</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="底层原理" scheme="http://www.hxtec.top/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    <category term="Category" scheme="http://www.hxtec.top/tags/Category/"/>
    
  </entry>
  
  <entry>
    <title>Category - initialize</title>
    <link href="http://www.hxtec.top/2022/09/17/Category-initialize/"/>
    <id>http://www.hxtec.top/2022/09/17/Category-initialize/</id>
    <published>2022-09-17T09:38:43.000Z</published>
    <updated>2022-09-17T09:58:43.490Z</updated>
    
    <content type="html"><![CDATA[<h4 id="initialized"><a href="#initialized" class="headerlink" title="initialized"></a>initialized</h4><ul><li>+initialized方法会在类第一次接收到消息时调用 </li><li>调用顺序<ul><li>先调用父类的+initialize，再调用子类的+initialize</li><li>先初始化父类，再初始化子类，每个类只会初始化1次</li></ul></li><li>+initialize和+load的很大区别是，+initialize是通过objc_msgSend进行调用的，所以有以下特点<ul><li>如果子类没有实现+initialize，会调用父类的+initialize（所以父类的+initialize可能会被调用多次）</li><li>如果分类实现了+initialize，就覆盖类本身的+initialize调用</li></ul></li></ul><h5 id="objc4源码解读"><a href="#objc4源码解读" class="headerlink" title="objc4源码解读"></a>objc4源码解读</h5><ul><li>objc-msg-arm64.s，汇编级别的源码<ul><li>objc_msgSend，消息发送汇编源码</li></ul></li><li>objc-runtime-new.mm<ul><li>class_getInstanceMethod</li><li>lookUpImpOrNil</li><li>lookUpImpOrForward</li><li>_class_initialize</li><li>callInitialize</li><li>objc_msgSend(cls, SEL_initialize)</li></ul></li></ul><h4 id="源码分析，objc-runtime-new-mm"><a href="#源码分析，objc-runtime-new-mm" class="headerlink" title="源码分析，objc-runtime-new.mm"></a>源码分析，objc-runtime-new.mm</h4><blockquote><p>class_getInstanceMethod</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/***********************************************************************</span><br><span class="line">* class_getInstanceMethod.  Return the instance method for the</span><br><span class="line">* specified class and selector.</span><br><span class="line">**********************************************************************/</span><br><span class="line">Method class_getInstanceMethod(Class cls, SEL sel)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cls  ||  !sel) return nil;</span><br><span class="line"></span><br><span class="line">    // This deliberately avoids +initialize because it historically did so.</span><br><span class="line"></span><br><span class="line">    // This implementation is a bit weird because it&#x27;s the only place that </span><br><span class="line">    // wants a Method instead of an IMP.</span><br><span class="line"></span><br><span class="line">#warning fixme build and search caches</span><br><span class="line">        </span><br><span class="line">    // Search method lists, try method resolver, etc.</span><br><span class="line">    // 查找方法</span><br><span class="line">    lookUpImpOrNil(cls, sel, nil, </span><br><span class="line">                   NO/*initialize*/, NO/*cache*/, YES/*resolver*/);</span><br><span class="line"></span><br><span class="line">#warning fixme build and search caches</span><br><span class="line"></span><br><span class="line">    return _class_getMethod(cls, sel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>lookUpImpOrNil</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">* lookUpImpOrNil.</span><br><span class="line">* Like lookUpImpOrForward, but returns nil instead of _objc_msgForward_impcache</span><br><span class="line">**********************************************************************/</span><br><span class="line">IMP lookUpImpOrNil(Class cls, SEL sel, id inst, </span><br><span class="line">                   bool initialize, bool cache, bool resolver)</span><br><span class="line">&#123;</span><br><span class="line">    IMP imp = lookUpImpOrForward(cls, sel, inst, initialize, cache, resolver);</span><br><span class="line">    if (imp == _objc_msgForward_impcache) return nil;</span><br><span class="line">    else return imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>lookUpImpOrForward<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">IMP lookUpImpOrForward(Class cls, SEL sel, id inst, </span><br><span class="line">                       bool initialize, bool cache, bool resolver)</span><br><span class="line">&#123;</span><br><span class="line">    IMP imp = nil;</span><br><span class="line">    bool triedResolver = NO;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line"></span><br><span class="line">    // 省去代码...   </span><br><span class="line"></span><br><span class="line">    // 判断是否初始化过类，没有就进行初始化</span><br><span class="line">    if (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</span><br><span class="line">        runtimeLock.unlockRead();</span><br><span class="line">        </span><br><span class="line">        // 初始化操作</span><br><span class="line">        _class_initialize (_class_getNonMetaClass(cls, inst));</span><br><span class="line">        </span><br><span class="line">        runtimeLock.read();</span><br><span class="line">        // If sel == initialize, _class_initialize will send +initialize and </span><br><span class="line">        // then the messenger will send +initialize again after this </span><br><span class="line">        // procedure finishes. Of course, if this is not being called </span><br><span class="line">        // from the messenger then it won&#x27;t happen. 2778172</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>_class_initialize</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">* class_initialize.  Send the &#x27;+initialize&#x27; message on demand to any</span><br><span class="line">* uninitialized class. Force initialization of superclasses first.</span><br><span class="line">**********************************************************************/</span><br><span class="line">void _class_initialize(Class cls)</span><br><span class="line">&#123;    </span><br><span class="line">    // 省去代码...   </span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            // 调用自己的初始化方法</span><br><span class="line">            callInitialize(cls);</span><br><span class="line"></span><br><span class="line">            if (PrintInitializing) &#123;</span><br><span class="line">                _objc_inform(&quot;INITIALIZE: thread %p: finished +[%s initialize]&quot;,</span><br><span class="line">                             pthread_self(), cls-&gt;nameForLogging());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    // 省去代码...   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>callInitialize</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void callInitialize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    // 消息发送机制</span><br><span class="line">    ((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);</span><br><span class="line">    asm(&quot;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="高频面试"><a href="#高频面试" class="headerlink" title="高频面试"></a>高频面试</h4><ul><li><p>Category中有load方法吗？load方法是什么时候调用的？load 方法能继承吗？</p><ul><li>有load方法</li><li>load方法在runtime加载类、分类的时候调用</li><li>load方法可以继承，但是一般情况下不会主动去调用load方法，都是让系统自动调用</li></ul></li><li><p>load、initialize方法的区别什么？它们在category中的调用的顺序？以及出现继承时他们之间的调用过程？</p><ul><li>分别在两个笔记里面顶部体现</li></ul></li><li><p>Category能否添加成员变量？如果可以，如何给Category添加成员变量？</p><ul><li>不能直接给Category添加成员变量，但是可以间接实现Category有成员变量的效果</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;initialized&quot;&gt;&lt;a href=&quot;#initialized&quot; class=&quot;headerlink&quot; title=&quot;initialized&quot;&gt;&lt;/a&gt;initialized&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;+initialized方法会在类第一次接收到消息时调用</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="底层原理" scheme="http://www.hxtec.top/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    <category term="Category" scheme="http://www.hxtec.top/tags/Category/"/>
    
  </entry>
  
  <entry>
    <title>Category - load</title>
    <link href="http://www.hxtec.top/2022/09/17/Category-load/"/>
    <id>http://www.hxtec.top/2022/09/17/Category-load/</id>
    <published>2022-09-17T09:35:26.000Z</published>
    <updated>2022-09-17T09:36:04.796Z</updated>
    
    <content type="html"><![CDATA[<h3 id="load"><a href="#load" class="headerlink" title="+load"></a>+load</h3><ul><li>+load方法会在runtime加载类、分类时调用</li><li>每个类、分类的+load，在程序运行过程中只调用一次</li><li>调用顺序<ol><li>先调用类的+load<ul><li>按照编译先后顺序调用（先编译，先调用）</li><li>调用子类+load之前会先调用父类的+load</li></ul></li><li>再调用分类的+load<ul><li>按照编译先后顺序调用（先编译，先调用）</li></ul></li></ol></li></ul><h5 id="objc4源码解读：objc-os-mm"><a href="#objc4源码解读：objc-os-mm" class="headerlink" title="objc4源码解读：objc-os.mm"></a>objc4源码解读：objc-os.mm</h5><ul><li>_objc_init</li><li>load_images</li><li>prepare_load_methods<ul><li>schedule_class_load</li><li>add_class_to_loadable_list</li><li>add_category_to_loadable_list</li></ul></li><li>call_load_methods<ul><li>call_class_loads</li><li>call_category_loads</li></ul></li></ul><h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><ul><li><p>_objc_init</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">* _objc_init</span><br><span class="line">* Bootstrap initialization. Registers our image notifier with dyld.</span><br><span class="line">* Called by libSystem BEFORE library initialization time</span><br><span class="line">**********************************************************************/</span><br><span class="line"></span><br><span class="line">void _objc_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    static bool initialized = false;</span><br><span class="line">    if (initialized) return;</span><br><span class="line">    initialized = true;</span><br><span class="line">    </span><br><span class="line">    // fixme defer initialization until an objc-using image is found?</span><br><span class="line">    environ_init();</span><br><span class="line">    tls_init();</span><br><span class="line">    static_init();</span><br><span class="line">    lock_init();</span><br><span class="line">    exception_init();</span><br><span class="line"></span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>load_images，在objc-runtime-new.mm文件中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">* load_images</span><br><span class="line">* Process +load in the given images which are being mapped in by dyld.</span><br><span class="line">*</span><br><span class="line">* Locking: write-locks runtimeLock and loadMethodLock</span><br><span class="line">**********************************************************************/</span><br><span class="line">extern bool hasLoadMethods(const headerType *mhdr);</span><br><span class="line">extern void prepare_load_methods(const headerType *mhdr);</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">load_images(const char *path __unused, const struct mach_header *mh)</span><br><span class="line">&#123;</span><br><span class="line">    // Return without taking locks if there are no +load methods here.</span><br><span class="line">    if (!hasLoadMethods((const headerType *)mh)) return;</span><br><span class="line"></span><br><span class="line">    recursive_mutex_locker_t lock(loadMethodLock);</span><br><span class="line"></span><br><span class="line">    // Discover load methods</span><br><span class="line">    &#123;</span><br><span class="line">        rwlock_writer_t lock2(runtimeLock);</span><br><span class="line">        </span><br><span class="line">        //准备加载方法</span><br><span class="line">        prepare_load_methods((const headerType *)mh);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Call +load methods (without runtimeLock - re-entrant)</span><br><span class="line">    // 加载方法</span><br><span class="line">    call_load_methods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>prepare_load_methods</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void prepare_load_methods(const headerType *mhdr)</span><br><span class="line">&#123;</span><br><span class="line">    size_t count, i;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line"></span><br><span class="line">    classref_t *classlist = </span><br><span class="line">        _getObjc2NonlazyClassList(mhdr, &amp;count);</span><br><span class="line">    for (i = 0; i &lt; count; i++) &#123;</span><br><span class="line">    </span><br><span class="line">        // 安排/预定类方法</span><br><span class="line">        schedule_class_load(remapClass(classlist[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    category_t **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);</span><br><span class="line">    for (i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        category_t *cat = categorylist[i];</span><br><span class="line">        Class cls = remapClass(cat-&gt;cls);</span><br><span class="line">        if (!cls) continue;  // category for ignored weak-linked class</span><br><span class="line">        realizeClass(cls);</span><br><span class="line">        assert(cls-&gt;ISA()-&gt;isRealized());</span><br><span class="line">        </span><br><span class="line">        // 添加分类到加载列表中</span><br><span class="line">        add_category_to_loadable_list(cat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>schedule_class_load</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">* prepare_load_methods</span><br><span class="line">* Schedule +load for classes in this image, any un-+load-ed </span><br><span class="line">* superclasses in other images, and any categories in this image.</span><br><span class="line">**********************************************************************/</span><br><span class="line">// Recursively schedule +load for cls and any un-+load-ed superclasses.</span><br><span class="line">// cls must already be connected.</span><br><span class="line">static void schedule_class_load(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cls) return;</span><br><span class="line">    assert(cls-&gt;isRealized());  // _read_images should realize</span><br><span class="line"></span><br><span class="line">    if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return;</span><br><span class="line"></span><br><span class="line">    // Ensure superclass-first ordering</span><br><span class="line">    schedule_class_load(cls-&gt;superclass);</span><br><span class="line"></span><br><span class="line">    // 添加类到加载列表中</span><br><span class="line">    add_class_to_loadable_list(cls);</span><br><span class="line">    cls-&gt;setInfo(RW_LOADED); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>add_class_to_loadable_list</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">* add_class_to_loadable_list</span><br><span class="line">* Class cls has just become connected. Schedule it for +load if</span><br><span class="line">* it implements a +load method.</span><br><span class="line">**********************************************************************/</span><br><span class="line">void add_class_to_loadable_list(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    IMP method;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    method = cls-&gt;getLoadMethod();</span><br><span class="line">    if (!method) return;  // Don&#x27;t bother if cls has no +load method</span><br><span class="line">    </span><br><span class="line">    if (PrintLoading) &#123;</span><br><span class="line">        _objc_inform(&quot;LOAD: class &#x27;%s&#x27; scheduled for +load&quot;, </span><br><span class="line">                     cls-&gt;nameForLogging());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (loadable_classes_used == loadable_classes_allocated) &#123;</span><br><span class="line">        loadable_classes_allocated = loadable_classes_allocated*2 + 16;</span><br><span class="line">        loadable_classes = (struct loadable_class *)</span><br><span class="line">            realloc(loadable_classes,</span><br><span class="line">                              loadable_classes_allocated *</span><br><span class="line">                              sizeof(struct loadable_class));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    loadable_classes[loadable_classes_used].cls = cls;</span><br><span class="line">    loadable_classes[loadable_classes_used].method = method;</span><br><span class="line">    loadable_classes_used++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>add_category_to_loadable_list</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">* add_category_to_loadable_list</span><br><span class="line">* Category cat&#x27;s parent class exists and the category has been attached</span><br><span class="line">* to its class. Schedule this category for +load after its parent class</span><br><span class="line">* becomes connected and has its own +load method called.</span><br><span class="line">**********************************************************************/</span><br><span class="line">void add_category_to_loadable_list(Category cat)</span><br><span class="line">&#123;</span><br><span class="line">    IMP method;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    method = _category_getLoadMethod(cat);</span><br><span class="line"></span><br><span class="line">    // Don&#x27;t bother if cat has no +load method</span><br><span class="line">    if (!method) return;</span><br><span class="line"></span><br><span class="line">    if (PrintLoading) &#123;</span><br><span class="line">        _objc_inform(&quot;LOAD: category &#x27;%s(%s)&#x27; scheduled for +load&quot;, </span><br><span class="line">                     _category_getClassName(cat), _category_getName(cat));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (loadable_categories_used == loadable_categories_allocated) &#123;</span><br><span class="line">        loadable_categories_allocated = loadable_categories_allocated*2 + 16;</span><br><span class="line">        loadable_categories = (struct loadable_category *)</span><br><span class="line">            realloc(loadable_categories,</span><br><span class="line">                              loadable_categories_allocated *</span><br><span class="line">                              sizeof(struct loadable_category));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    loadable_categories[loadable_categories_used].cat = cat;</span><br><span class="line">    loadable_categories[loadable_categories_used].method = method;</span><br><span class="line">    loadable_categories_used++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>call_load_methods</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">void call_load_methods(void)</span><br><span class="line">&#123;</span><br><span class="line">    static bool loading = NO;</span><br><span class="line">    bool more_categories;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    // Re-entrant calls do nothing; the outermost call will finish the job.</span><br><span class="line">    if (loading) return;</span><br><span class="line">    loading = YES;</span><br><span class="line"></span><br><span class="line">    void *pool = objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line">        // 1. Repeatedly call class +loads until there aren&#x27;t any more</span><br><span class="line">        while (loadable_classes_used &gt; 0) &#123;</span><br><span class="line">        </span><br><span class="line">            //调用类load方法</span><br><span class="line">            call_class_loads();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 2. Call category +loads ONCE</span><br><span class="line"></span><br><span class="line">        // 调用分类的load方法</span><br><span class="line">        more_categories = call_category_loads();</span><br><span class="line"></span><br><span class="line">        // 3. Run more +loads if there are classes OR more untried categories</span><br><span class="line">    &#125; while (loadable_classes_used &gt; 0  ||  more_categories);</span><br><span class="line"></span><br><span class="line">    objc_autoreleasePoolPop(pool);</span><br><span class="line"></span><br><span class="line">    loading = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>call_class_loads</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">* call_class_loads</span><br><span class="line">* Call all pending class +load methods.</span><br><span class="line">* If new classes become loadable, +load is NOT called for them.</span><br><span class="line">*</span><br><span class="line">* Called only by call_load_methods().</span><br><span class="line">**********************************************************************/</span><br><span class="line">static void call_class_loads(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    </span><br><span class="line">    // Detach current loadable list.</span><br><span class="line">    struct loadable_class *classes = loadable_classes;</span><br><span class="line">    int used = loadable_classes_used;</span><br><span class="line">    loadable_classes = nil;</span><br><span class="line">    loadable_classes_allocated = 0;</span><br><span class="line">    loadable_classes_used = 0;</span><br><span class="line">    </span><br><span class="line">    // Call all +loads for the detached list.</span><br><span class="line">    for (i = 0; i &lt; used; i++) &#123;</span><br><span class="line">        Class cls = classes[i].cls;</span><br><span class="line">        load_method_t load_method = (load_method_t)classes[i].method;</span><br><span class="line">        if (!cls) continue; </span><br><span class="line"></span><br><span class="line">        if (PrintLoading) &#123;</span><br><span class="line">            _objc_inform(&quot;LOAD: +[%s load]\n&quot;, cls-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line">        (*load_method)(cls, SEL_load);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Destroy the detached list.</span><br><span class="line">    if (classes) free(classes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>call_category_loads</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">* call_category_loads</span><br><span class="line">* Call some pending category +load methods.</span><br><span class="line">* The parent class of the +load-implementing categories has all of </span><br><span class="line">*   its categories attached, in case some are lazily waiting for +initalize.</span><br><span class="line">* Don&#x27;t call +load unless the parent class is connected.</span><br><span class="line">* If new categories become loadable, +load is NOT called, and they </span><br><span class="line">*   are added to the end of the loadable list, and we return TRUE.</span><br><span class="line">* Return FALSE if no new categories became loadable.</span><br><span class="line">*</span><br><span class="line">* Called only by call_load_methods().</span><br><span class="line">**********************************************************************/</span><br><span class="line">static bool call_category_loads(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i, shift;</span><br><span class="line">    bool new_categories_added = NO;</span><br><span class="line">    </span><br><span class="line">    // Detach current loadable list.</span><br><span class="line">    struct loadable_category *cats = loadable_categories;</span><br><span class="line">    int used = loadable_categories_used;</span><br><span class="line">    int allocated = loadable_categories_allocated;</span><br><span class="line">    loadable_categories = nil;</span><br><span class="line">    loadable_categories_allocated = 0;</span><br><span class="line">    loadable_categories_used = 0;</span><br><span class="line"></span><br><span class="line">    // Call all +loads for the detached list.</span><br><span class="line">    for (i = 0; i &lt; used; i++) &#123;</span><br><span class="line">        Category cat = cats[i].cat;</span><br><span class="line">        load_method_t load_method = (load_method_t)cats[i].method;</span><br><span class="line">        Class cls;</span><br><span class="line">        if (!cat) continue;</span><br><span class="line"></span><br><span class="line">        cls = _category_getClass(cat);</span><br><span class="line">        if (cls  &amp;&amp;  cls-&gt;isLoadable()) &#123;</span><br><span class="line">            if (PrintLoading) &#123;</span><br><span class="line">                _objc_inform(&quot;LOAD: +[%s(%s) load]\n&quot;, </span><br><span class="line">                             cls-&gt;nameForLogging(), </span><br><span class="line">                             _category_getName(cat));</span><br><span class="line">            &#125;</span><br><span class="line">            (*load_method)(cls, SEL_load);</span><br><span class="line">            cats[i].cat = nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Compact detached list (order-preserving)</span><br><span class="line">    shift = 0;</span><br><span class="line">    for (i = 0; i &lt; used; i++) &#123;</span><br><span class="line">        if (cats[i].cat) &#123;</span><br><span class="line">            cats[i-shift] = cats[i];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            shift++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    used -= shift;</span><br><span class="line"></span><br><span class="line">    // Copy any new +load candidates from the new list to the detached list.</span><br><span class="line">    new_categories_added = (loadable_categories_used &gt; 0);</span><br><span class="line">    for (i = 0; i &lt; loadable_categories_used; i++) &#123;</span><br><span class="line">        if (used == allocated) &#123;</span><br><span class="line">            allocated = allocated*2 + 16;</span><br><span class="line">            cats = (struct loadable_category *)</span><br><span class="line">                realloc(cats, allocated *</span><br><span class="line">                                  sizeof(struct loadable_category));</span><br><span class="line">        &#125;</span><br><span class="line">        cats[used++] = loadable_categories[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Destroy the new list.</span><br><span class="line">    if (loadable_categories) free(loadable_categories);</span><br><span class="line"></span><br><span class="line">    // Reattach the (now augmented) detached list. </span><br><span class="line">    // But if there&#x27;s nothing left to load, destroy the list.</span><br><span class="line">    if (used) &#123;</span><br><span class="line">        loadable_categories = cats;</span><br><span class="line">        loadable_categories_used = used;</span><br><span class="line">        loadable_categories_allocated = allocated;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (cats) free(cats);</span><br><span class="line">        loadable_categories = nil;</span><br><span class="line">        loadable_categories_used = 0;</span><br><span class="line">        loadable_categories_allocated = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (PrintLoading) &#123;</span><br><span class="line">        if (loadable_categories_used != 0) &#123;</span><br><span class="line">            _objc_inform(&quot;LOAD: %d categories still waiting for +load\n&quot;,</span><br><span class="line">                         loadable_categories_used);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return new_categories_added;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h6 id="note"><a href="#note" class="headerlink" title="note"></a>note</h6><ul><li>+load方法是根据方法地址直接调用，并不是经过objc_msgSend函数调用</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;load&quot;&gt;&lt;a href=&quot;#load&quot; class=&quot;headerlink&quot; title=&quot;+load&quot;&gt;&lt;/a&gt;+load&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;+load方法会在runtime加载类、分类时调用&lt;/li&gt;
&lt;li&gt;每个类、分类的+load，在程序运行过</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="底层原理" scheme="http://www.hxtec.top/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    <category term="Category" scheme="http://www.hxtec.top/tags/Category/"/>
    
  </entry>
  
  <entry>
    <title>Category - 底层结构</title>
    <link href="http://www.hxtec.top/2022/09/17/Category-%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84/"/>
    <id>http://www.hxtec.top/2022/09/17/Category-%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84/</id>
    <published>2022-09-17T09:31:45.000Z</published>
    <updated>2022-09-17T09:34:59.342Z</updated>
    
    <content type="html"><![CDATA[<h4 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct _category_t &#123;</span><br><span class="line">    const char *name;</span><br><span class="line">    struct _class_t *cls;</span><br><span class="line">    const struct _method_list_t *instance_methods;</span><br><span class="line">    const struct _method_list_t *class_methods;</span><br><span class="line">    const struct _protocol_list_t *protocols;</span><br><span class="line">    const struct _prop_list_t *properties;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="加载处理过程"><a href="#加载处理过程" class="headerlink" title="加载处理过程"></a>加载处理过程</h4><ul><li>通过Runtime某个类的所有Category数据</li><li>把所有Category的方法，属性，协议数据，合并到一个在数组中<ul><li>后面参与编译的Category数据，会在数组的前面</li></ul></li><li>将合并后的分类数据（方法，属性，协议），插入到类原来数据的前面</li><li>源码解读顺序<ul><li>objc-os.mm<ul><li>_objc_init</li><li>map_images</li><li>map_images_nolock</li></ul></li><li>objc-runtim-new.mm<ul><li>_read_images</li><li>remethodizeClass</li><li>attachCategories</li><li>attachLists<ul><li>realloc, memmove, memcpy</li></ul></li></ul></li></ul></li></ul><h4 id="部分源码分析"><a href="#部分源码分析" class="headerlink" title="部分源码分析"></a>部分源码分析</h4><h6 id="objc-os-mm"><a href="#objc-os-mm" class="headerlink" title="objc-os.mm"></a>objc-os.mm</h6><ul><li>_objc_init<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">***********************************************************************</span><br><span class="line">* _objc_init</span><br><span class="line">* Bootstrap initialization. Registers our image notifier with dyld.</span><br><span class="line">* Called by libSystem BEFORE library initialization time</span><br><span class="line">**********************************************************************/</span><br><span class="line"></span><br><span class="line">void _objc_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    static bool initialized = false;</span><br><span class="line">    if (initialized) return;</span><br><span class="line">    initialized = true;</span><br><span class="line">    </span><br><span class="line">    // fixme defer initialization until an objc-using image is found?</span><br><span class="line">    environ_init();</span><br><span class="line">    tls_init();</span><br><span class="line">    static_init();</span><br><span class="line">    lock_init();</span><br><span class="line">    exception_init();</span><br><span class="line"></span><br><span class="line">    // map_images</span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>map_images_nolock<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/***********************************************************************</span><br><span class="line">* map_images_nolock</span><br><span class="line">* Process the given images which are being mapped in by dyld.</span><br><span class="line">* All class registration and fixups are performed (or deferred pending</span><br><span class="line">* discovery of missing superclasses etc), and +load methods are called.</span><br><span class="line">*</span><br><span class="line">* info[] is in bottom-up order i.e. libobjc will be earlier in the </span><br><span class="line">* array than any library that links to libobjc.</span><br><span class="line">*</span><br><span class="line">* Locking: loadMethodLock(old) or runtimeLock(new) acquired by map_images.</span><br><span class="line">**********************************************************************/</span><br><span class="line">#if __OBJC2__</span><br><span class="line">#include &quot;objc-file.h&quot;</span><br><span class="line">#else</span><br><span class="line">#include &quot;objc-file-old.h&quot;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">void </span><br><span class="line">map_images_nolock(unsigned mhCount, const char * const mhPaths[],</span><br><span class="line">                  const struct mach_header * const mhdrs[])</span><br><span class="line">&#123;</span><br><span class="line">// 省去其他代码...</span><br><span class="line"></span><br><span class="line">    if (hCount &gt; 0) &#123;</span><br><span class="line">    </span><br><span class="line">        //_read_images</span><br><span class="line">        _read_images(hList, hCount, totalClasses, unoptimizedTotalClasses);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 省去其他代码...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h6 id="objc-runtime-new-mm文件"><a href="#objc-runtime-new-mm文件" class="headerlink" title="objc-runtime-new.mm文件"></a>objc-runtime-new.mm文件</h6><ul><li><p>_read_images</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">* _read_images</span><br><span class="line">* Perform initial processing of the headers in the linked </span><br><span class="line">* list beginning with headerList. </span><br><span class="line">*</span><br><span class="line">* Called by: map_images_nolock</span><br><span class="line">*</span><br><span class="line">* Locking: runtimeLock acquired by map_images</span><br><span class="line">**********************************************************************/</span><br><span class="line">void _read_images(header_info **hList, uint32_t hCount, int totalClasses, int unoptimizedTotalClasses)</span><br><span class="line">&#123;</span><br><span class="line">// 省去其他代码...</span><br><span class="line"></span><br><span class="line">            // Process this category. </span><br><span class="line">            // First, register the category with its target class. </span><br><span class="line">            // Then, rebuild the class&#x27;s method lists (etc) if </span><br><span class="line">            // the class is realized. </span><br><span class="line">            bool classExists = NO;</span><br><span class="line">            if (cat-&gt;instanceMethods ||  cat-&gt;protocols  </span><br><span class="line">                ||  cat-&gt;instanceProperties) </span><br><span class="line">            &#123;</span><br><span class="line">                addUnattachedCategoryForClass(cat, cls, hi);</span><br><span class="line">                if (cls-&gt;isRealized()) &#123;</span><br><span class="line">                </span><br><span class="line">                    //重新组织类的方法</span><br><span class="line">                    remethodizeClass(cls);</span><br><span class="line">                    classExists = YES;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                if (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(&quot;CLASS: found category -%s(%s) %s&quot;, </span><br><span class="line">                                 cls-&gt;nameForLogging(), cat-&gt;name, </span><br><span class="line">                                 classExists ? &quot;on existing class&quot; : &quot;&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (cat-&gt;classMethods  ||  cat-&gt;protocols  </span><br><span class="line">                ||  (hasClassProperties &amp;&amp; cat-&gt;_classProperties)) </span><br><span class="line">            &#123;</span><br><span class="line">                addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi);</span><br><span class="line">                if (cls-&gt;ISA()-&gt;isRealized()) &#123;</span><br><span class="line">                </span><br><span class="line">                    //重新组织类的方法</span><br><span class="line">                    remethodizeClass(cls-&gt;ISA());</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                if (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(&quot;CLASS: found category +%s(%s)&quot;, </span><br><span class="line">                                 cls-&gt;nameForLogging(), cat-&gt;name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">// 省去其他代码...</span><br></pre></td></tr></table></figure></li><li><p>remethodizeClass</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">* remethodizeClass</span><br><span class="line">* Attach outstanding categories to an existing class.</span><br><span class="line">* Fixes up cls&#x27;s method list, protocol list, and property list.</span><br><span class="line">* Updates method caches for cls and its subclasses.</span><br><span class="line">* Locking: runtimeLock must be held by the caller</span><br><span class="line">**********************************************************************/</span><br><span class="line">static void remethodizeClass(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    category_list *cats;</span><br><span class="line">    bool isMeta;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line"></span><br><span class="line">    isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    // Re-methodizing: check for more categories</span><br><span class="line">    if ((cats = unattachedCategoriesForClass(cls, false/*not realizing*/))) &#123;</span><br><span class="line">        if (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(&quot;CLASS: attaching categories to class &#x27;%s&#x27; %s&quot;, </span><br><span class="line">                         cls-&gt;nameForLogging(), isMeta ? &quot;(meta)&quot; : &quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // </span><br><span class="line">        attachCategories(cls, cats, true /*flush caches*/);        </span><br><span class="line">        free(cats);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>attachCategories</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">attachCategories(Class cls, category_list *cats, bool flush_caches)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cats) return;</span><br><span class="line">    if (PrintReplacedMethods) printReplacements(cls, cats);</span><br><span class="line"></span><br><span class="line">    bool isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    // fixme rearrange to remove these intermediate allocations</span><br><span class="line">    // 方法数组，二维数组</span><br><span class="line">    /*</span><br><span class="line">    [</span><br><span class="line">        [method_t, method_t],</span><br><span class="line">        [method_t, method_t]</span><br><span class="line">    ]</span><br><span class="line">     */</span><br><span class="line">    method_list_t **mlists = (method_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*mlists));</span><br><span class="line">    // 属性数组</span><br><span class="line">    property_list_t **proplists = (property_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*proplists));</span><br><span class="line">    // 协议数组</span><br><span class="line">    protocol_list_t **protolists = (protocol_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*protolists));</span><br><span class="line"></span><br><span class="line">    // Count backwards through cats to get newest categories first</span><br><span class="line">    int mcount = 0;</span><br><span class="line">    int propcount = 0;</span><br><span class="line">    int protocount = 0;</span><br><span class="line">    int i = cats-&gt;count;</span><br><span class="line">    bool fromBundle = NO;</span><br><span class="line">    while (i--) &#123;</span><br><span class="line">        //取出某个分类</span><br><span class="line">        auto&amp; entry = cats-&gt;list[i];</span><br><span class="line"></span><br><span class="line">        // 取出分类中的对象/类方法</span><br><span class="line">        method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);</span><br><span class="line">        if (mlist) &#123;</span><br><span class="line">            mlists[mcount++] = mlist;</span><br><span class="line">            fromBundle |= entry.hi-&gt;isBundle();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        property_list_t *proplist = </span><br><span class="line">            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</span><br><span class="line">        if (proplist) &#123;</span><br><span class="line">            proplists[propcount++] = proplist;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protocol_list_t *protolist = entry.cat-&gt;protocols;</span><br><span class="line">        if (protolist) &#123;</span><br><span class="line">            protolists[protocount++] = protolist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    auto rw = cls-&gt;data();</span><br><span class="line"></span><br><span class="line">    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</span><br><span class="line">    // 将所有分类的对象/类方法，附加到类对象的方法列表中</span><br><span class="line">    rw-&gt;methods.attachLists(mlists, mcount);</span><br><span class="line">    free(mlists);</span><br><span class="line">    if (flush_caches  &amp;&amp;  mcount &gt; 0) flushCaches(cls);</span><br><span class="line">    </span><br><span class="line">    // 将所有分类的属性，附加到类对象的属性列表中</span><br><span class="line">    rw-&gt;properties.attachLists(proplists, propcount);</span><br><span class="line">    free(proplists);</span><br><span class="line">    </span><br><span class="line">    // 将所有分类的协议，附加到类对象的协议列表中</span><br><span class="line">    rw-&gt;protocols.attachLists(protolists, protocount);</span><br><span class="line">    free(protolists);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h6 id="objc-runtime-new-h"><a href="#objc-runtime-new-h" class="headerlink" title="objc-runtime-new.h"></a>objc-runtime-new.h</h6><ul><li>attachLists<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">void attachLists(List* const * addedLists, uint32_t addedCount) &#123;</span><br><span class="line">        if (addedCount == 0) return;</span><br><span class="line"></span><br><span class="line">        if (hasArray()) &#123;</span><br><span class="line">            // many lists -&gt; many lists</span><br><span class="line">            uint32_t oldCount = array()-&gt;count;</span><br><span class="line">            uint32_t newCount = oldCount + addedCount;</span><br><span class="line">            setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));</span><br><span class="line">            array()-&gt;count = newCount;</span><br><span class="line">            </span><br><span class="line">            //先进行内存挪动，array()-&gt;lists，原来的方法列表</span><br><span class="line">            memmove(array()-&gt;lists + addedCount, </span><br><span class="line">                             array()-&gt;lists, </span><br><span class="line">                             oldCount * sizeof(array()-&gt;lists[0]));</span><br><span class="line">            </span><br><span class="line">            //再进行，copy操作到挪动后腾出的位置，addedLists,原有分类的方法列表</span><br><span class="line">            memcpy(array()-&gt;lists, </span><br><span class="line">                            addedLists, </span><br><span class="line">                            addedCount * sizeof(array()-&gt;lists[0]));</span><br><span class="line">        &#125;</span><br><span class="line">        else if (!list  &amp;&amp;  addedCount == 1) &#123;</span><br><span class="line">            // 0 lists -&gt; 1 list</span><br><span class="line">            list = addedLists[0];</span><br><span class="line">        &#125; </span><br><span class="line">        else &#123;</span><br><span class="line">            // 1 list -&gt; many lists</span><br><span class="line">            List* oldList = list;</span><br><span class="line">            uint32_t oldCount = oldList ? 1 : 0;</span><br><span class="line">            uint32_t newCount = oldCount + addedCount;</span><br><span class="line">            setArray((array_t *)malloc(array_t::byteSize(newCount)));</span><br><span class="line">            array()-&gt;count = newCount;</span><br><span class="line">            if (oldList) array()-&gt;lists[addedCount] = oldList;</span><br><span class="line">            memcpy(array()-&gt;lists, addedLists, </span><br><span class="line">                   addedCount * sizeof(array()-&gt;lists[0]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="高频试题"><a href="#高频试题" class="headerlink" title="高频试题"></a>高频试题</h4><ul><li>Category的使用场景？<ul><li>为原有类添加对象方法和类方法</li><li>拆分模块，将原来一个大的模块，拆分成多个小模块，方便维护和管理</li><li>添加关联对象</li></ul></li><li>Cateory的实现原理<ul><li>Category编译之后的底层结构是 struct category_t，里面存储着分类 的对象方法，属性，协议信息</li><li>在程序运行的时候，runtime会将Category的数据，合并到类信息中（类对象，元类对象）</li></ul></li><li>Cateogyr和Class Extension的区别是什么？<ul><li>Class Extension在编译的时候，它的数据就已经包含在类信息中</li><li>Category是在运行时，才会将数据合并到类信息中</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;底层结构&quot;&gt;&lt;a href=&quot;#底层结构&quot; class=&quot;headerlink&quot; title=&quot;底层结构&quot;&gt;&lt;/a&gt;底层结构&lt;/h4&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="底层原理" scheme="http://www.hxtec.top/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>KVO &amp; KVC</title>
    <link href="http://www.hxtec.top/2022/09/17/KVO-KVC/"/>
    <id>http://www.hxtec.top/2022/09/17/KVO-KVC/</id>
    <published>2022-09-17T09:29:35.000Z</published>
    <updated>2022-09-17T09:30:17.404Z</updated>
    
    <content type="html"><![CDATA[<h3 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h3><ul><li><p>KVO的全称是Key-Value Observing，俗称“键值监听”，可以用于监听某个对象属性值的改变</p></li><li><p>添加KVO方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">self.person = [[Person alloc] init];</span><br><span class="line"></span><br><span class="line">// 给person对象添加KVO监听</span><br><span class="line">NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;</span><br><span class="line">[self.person addObserver:self forKeyPath:@&quot;age&quot; options:options context:@&quot;123&quot;];</span><br><span class="line"></span><br><span class="line">// observeValueForKeyPath:ofObject:change:context:</span><br><span class="line">// 当监听对象的属性值发生改变时，就会调用</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;监听到%@的%@属性值改变了 - %@ - %@&quot;, object, keyPath, change, context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//移除监听</span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    [self.person1 removeObserver:self forKeyPath:@&quot;age&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h5><ul><li>利用RuntimeAPI动态生成一个子类，并且让instance对象的isa指向这个全新的子类</li><li>当修改instance对象的属性时，会调用Foundation的_NSSetXXXValueAndNotify函数<ul><li>willChangeValueForKey:</li><li>父类原来的setter</li><li>didChangeValueForKey:<ul><li>内部会触发监听器（Oberser）的监听方法( observeValueForKeyPath:ofObject:change:context:）</li></ul></li></ul></li></ul><h5 id="手动触发KVO"><a href="#手动触发KVO" class="headerlink" title="手动触发KVO"></a>手动触发KVO</h5><ul><li>手动调用willChangeValueForKey:和didChangeValueForKey:</li></ul><h5 id="直接修改成员变量会触发KVO么？"><a href="#直接修改成员变量会触发KVO么？" class="headerlink" title="直接修改成员变量会触发KVO么？"></a>直接修改成员变量会触发KVO么？</h5><ul><li>不会触发KVO</li></ul><h6 id="获取类的所有方法"><a href="#获取类的所有方法" class="headerlink" title="获取类的所有方法"></a>获取类的所有方法</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (void)printMethodNamesOfClass:(Class)cls</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int count;</span><br><span class="line">    // 获得方法数组</span><br><span class="line">    Method *methodList = class_copyMethodList(cls, &amp;count);</span><br><span class="line">    </span><br><span class="line">    // 存储方法名</span><br><span class="line">    NSMutableString *methodNames = [NSMutableString string];</span><br><span class="line">    </span><br><span class="line">    // 遍历所有的方法</span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        // 获得方法</span><br><span class="line">        Method method = methodList[i];</span><br><span class="line">        // 获得方法名</span><br><span class="line">        NSString *methodName = NSStringFromSelector(method_getName(method));</span><br><span class="line">        // 拼接方法名</span><br><span class="line">        [methodNames appendString:methodName];</span><br><span class="line">        [methodNames appendString:@&quot;, &quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 释放</span><br><span class="line">    free(methodList);</span><br><span class="line">    </span><br><span class="line">    // 打印方法名</span><br><span class="line">    NSLog(@&quot;%@ %@&quot;, cls, methodNames);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用</span><br><span class="line">[self printMethodNamesOfClass:object_getClass(self.person)];</span><br><span class="line"></span><br><span class="line">//打印结果，即为中间派生类的方法</span><br><span class="line">NSKVONotifying_Person setAge:, class, dealloc, _isKVOA,</span><br></pre></td></tr></table></figure><h3 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h3><ul><li>KVC的全称是Key-Value Coding，俗称“键值编码”，可以通过一个key来访问某个属性</li><li>常见的API有<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)setValue:(id)value forKeyPath:(NSString *)keyPath;</span><br><span class="line">- (void)setValue:(id)value forKey:(NSString *)key;</span><br><span class="line"></span><br><span class="line">- (id)valueForKeyPath:(NSString *)keyPath;</span><br><span class="line">- (id)valueForKey:(NSString *)key; </span><br></pre></td></tr></table></figure></li></ul><h6 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@interface Cat : NSObject</span><br><span class="line">@property (assign, nonatomic) int weight;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface Person : NSObject</span><br><span class="line">@property (assign, nonatomic) int age;</span><br><span class="line"></span><br><span class="line">@property (assign, nonatomic) Cat *cat;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">Person *person = [[Person alloc] init];</span><br><span class="line">// 进行赋值</span><br><span class="line">//[person setValue:[NSNumber numberWithInt:10] forKey:@&quot;age&quot;];</span><br><span class="line">[person setValue:@10 forKey:@&quot;age&quot;];</span><br><span class="line"></span><br><span class="line">//通过keyPath，进行赋值</span><br><span class="line">person.cat = [[Cat alloc] init];</span><br><span class="line">[person setValue:@10 forKeyPath:@&quot;cat.weight&quot;];</span><br></pre></td></tr></table></figure><h5 id="setValue-forKey-的原理"><a href="#setValue-forKey-的原理" class="headerlink" title="setValue:forKey:的原理"></a>setValue:forKey:的原理</h5><ul><li>setValue:forKey: </li><li>按照setKey: _setKey: 顺序查找方法</li><li>找到方法 -&gt; 传递参数，调用方法</li><li>没有找到方法 -&gt; 查看 &#x3D;&#x3D;accessInstanceVariablesDirectly&#x3D;&#x3D; 方法的返回值</li><li>返回 YES -&gt; 按照 _key、_isKey、key、isKey 顺序查找&#x3D;&#x3D;成员变量&#x3D;&#x3D;，直接赋值，如果还是没有找到，走下一步</li><li>返回NO -&gt; 调用 &#x3D;&#x3D;setValue:forUndefinedKey:&#x3D;&#x3D; 并抛出异常NSUnknownKeyException<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">&#123;</span><br><span class="line">    @public</span><br><span class="line">// 按钮 _key、_isKey、key、isKey 顺序查找</span><br><span class="line">//    int _age;</span><br><span class="line">//    int _isAge;</span><br><span class="line">//    int age;</span><br><span class="line">//    int isAge;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MJPerson</span><br><span class="line">//先找setAge方法，进行赋值</span><br><span class="line">//- (void)setAge:(int)age</span><br><span class="line">//&#123;</span><br><span class="line">//    NSLog(@&quot;setAge: - %d&quot;, age);</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">//再找_setAge方法，进行赋值</span><br><span class="line">//- (void)_setAge:(int)age</span><br><span class="line">//&#123;</span><br><span class="line">//    NSLog(@&quot;_setAge: - %d&quot;, age);</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">// 默认的返回值就是YES</span><br><span class="line">//+ (BOOL)accessInstanceVariablesDirectly</span><br><span class="line">//&#123;</span><br><span class="line">//    return YES;//默认的返回值就是YES</span><br><span class="line">//    return NO;//抛出异常NSUnknownKeyException, setValue:forUndefinedKey:</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></li></ul><h5 id="valueForKey-的原理"><a href="#valueForKey-的原理" class="headerlink" title="valueForKey:的原理"></a>valueForKey:的原理</h5><ul><li>valueForKey:</li><li>按照 getKey、key、 isKey、_key 顺序查找方</li><li>找到方法 -&gt; 调用方法，返回值</li><li>没有找到方法 -&gt; 查看 &#x3D;&#x3D;accessInstanceVariablesDirectly&#x3D;&#x3D; 方法的返回值</li><li>返回 YES -&gt; 按照 _key、_isKey、key、isKey 顺序查找成员变量，直接赋值，如果还是没有找到成员变量，走下一步</li><li>返回NO -&gt; 调用 调用 &#x3D;&#x3D;valueForUndefinedKey:&#x3D;&#x3D; 并抛出异常NSUnknownKeyException<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">&#123;</span><br><span class="line">    @public</span><br><span class="line">// 按照 _key、_isKey、key、isKey 顺序查找</span><br><span class="line">//    int _age;</span><br><span class="line">//    int _isAge;</span><br><span class="line">//    int age;</span><br><span class="line">//    int isAge;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MJPerson</span><br><span class="line">//- (int)getAge</span><br><span class="line">//&#123;</span><br><span class="line">//    return 11;</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">//- (int)age</span><br><span class="line">//&#123;</span><br><span class="line">//    return 12;</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">//- (int)isAge</span><br><span class="line">//&#123;</span><br><span class="line">//    return 13;</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">//- (int)_age</span><br><span class="line">//&#123;</span><br><span class="line">//    return 14;</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">// 默认的返回值就是YES</span><br><span class="line">//+ (BOOL)accessInstanceVariablesDirectly</span><br><span class="line">//&#123;</span><br><span class="line">//    return YES;//默认的返回值就是YES</span><br><span class="line">//    return NO;//抛出异常NSUnknownKeyException, setValue:forUndefinedKey:</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></li></ul><h5 id="通过KVC修改属性是否会触发KVO？"><a href="#通过KVC修改属性是否会触发KVO？" class="headerlink" title="通过KVC修改属性是否会触发KVO？"></a>通过KVC修改属性是否会触发KVO？</h5><ul><li>会触发KVO<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Observer *observer = [[Observer alloc] init];</span><br><span class="line">Person *person = [[Person alloc] init];</span><br><span class="line"></span><br><span class="line">// 添加KVO监听</span><br><span class="line">[person addObserver:observer forKeyPath:@&quot;age&quot; options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:NULL];</span><br><span class="line"></span><br><span class="line">// 通过KVC修改age属性</span><br><span class="line">[person setValue:@10 forKey:@&quot;age&quot;];</span><br><span class="line"></span><br><span class="line">// 也可手动触发KVO</span><br><span class="line">// [person willChangeValueForKey:@&quot;age&quot;];</span><br><span class="line">// person-&gt;_age = 10;</span><br><span class="line">// [person didChangeValueForKey:@&quot;age&quot;];</span><br><span class="line"></span><br><span class="line">// 移除KVO监听</span><br><span class="line">[person removeObserver:observer forKeyPath:@&quot;age&quot;];</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;KVO&quot;&gt;&lt;a href=&quot;#KVO&quot; class=&quot;headerlink&quot; title=&quot;KVO&quot;&gt;&lt;/a&gt;KVO&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;KVO的全称是Key-Value Observing，俗称“键值监听”，可以用于监听某个对象属性值的改变&lt;/p&gt;
</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="底层原理" scheme="http://www.hxtec.top/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>OC语法</title>
    <link href="http://www.hxtec.top/2022/09/17/OC%E8%AF%AD%E6%B3%95/"/>
    <id>http://www.hxtec.top/2022/09/17/OC%E8%AF%AD%E6%B3%95/</id>
    <published>2022-09-17T08:58:57.000Z</published>
    <updated>2022-09-17T09:13:11.760Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Objective-c语法"><a href="#Objective-c语法" class="headerlink" title="Objective-c语法"></a>Objective-c语法</h1><h4 id="Objective-C的本质"><a href="#Objective-C的本质" class="headerlink" title="Objective-C的本质"></a>Objective-C的本质</h4><ul><li>平时编写的OC代码，底层实现其实都是C&#x2F;C++代码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Objective-C -&gt; C/C++ -&gt; 汇编语言 -&gt; 机器语言</span><br></pre></td></tr></table></figure><ul><li>OC的面向对象都是基于C&#x2F;C++的数据结构实现的，即 <strong>结构体</strong></li></ul><h4 id="NSObject的底层实现"><a href="#NSObject的底层实现" class="headerlink" title="NSObject的底层实现"></a>NSObject的底层实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@interface NSObject &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">底层结构体形式：</span><br><span class="line">struct NSObject_IMPL &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>创建一个实例对象，至少需要多少内存？</p><ul><li>至少需要8个字节<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line">class_getInstanceSize([NSObjcet class]);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>创建一个实例对象，实际上分配了多少内存？</p><ul><li>实际分配了16个字节   </li><li>底层是Buckets size, 16, 32, 48, 64…. 都是16的位数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line">malloc_size((__bridge const void *)obj)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="OC对象的分类"><a href="#OC对象的分类" class="headerlink" title="OC对象的分类"></a>OC对象的分类</h4><ul><li>instance对象（实例对象）<ul><li>alloc出来的对象，在内存中存储的信息包括：<ol><li>isa指针</li><li>其他成员变量</li></ol></li></ul></li><li>class对象（类对象）<ul><li>每个类在内存中有且只有一个class对象</li><li>class对象在内存中存储的信息主要包括：<ol><li>isa指针</li><li>superClass指针</li><li>类的属性信息(property)、类的对象方法信息(instance method)</li><li>类的协议信息(protocol)、类的成员变量信息(ivar)</li><li>……</li></ol></li></ul></li><li>meta-class对象（元类对象）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class objectMetaClass = objc_getClass([NSObject class]);//Runtime API</span><br></pre></td></tr></table></figure></li></ul><h6 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h6><ul><li><p>objectMetaClass是NSObject的meta-class对象(元类对象)</p></li><li><p>每个类在内存中只有一个meta-class对象</p></li><li><p>meta-class对象和class对象的内存结构是一样的，但是用途不一样</p><ul><li>主要包括：<ol><li>isa指针</li><li>superclass指针</li><li>类的方法信息(class method)</li><li>……</li></ol></li></ul></li><li><p>查看Class是否为meta-class，方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bool result = class_isMetaClass([NSObjce class]);</span><br></pre></td></tr></table></figure></li></ul><h5 id="isa指针"><a href="#isa指针" class="headerlink" title="isa指针"></a>isa指针</h5><p><img src="http://rfshxohrg.hn-bkt.clouddn.com/WX20220730-105146.png" alt="image"></p><ul><li>instance的&#x3D;&#x3D;isa&#x3D;&#x3D;指向class<ul><li>当调用&#x3D;&#x3D;对象方法&#x3D;&#x3D;时，通过instance的&#x3D;&#x3D;isa&#x3D;&#x3D;找到class，最后找到&#x3D;&#x3D;对象方法&#x3D;&#x3D;的实现进行调用</li></ul></li><li>class的&#x3D;&#x3D;isa&#x3D;&#x3D;指向meta-class<ul><li>当调用&#x3D;&#x3D;类方法&#x3D;&#x3D;时，通过class的&#x3D;&#x3D;isa&#x3D;&#x3D;找到meta-class，最后找到&#x3D;&#x3D;类方法&#x3D;&#x3D;的实现进行调用<br><img src="http://rfshxohrg.hn-bkt.clouddn.com/WX20220730-112038.png" alt="image"></li></ul></li></ul><p><strong>&#x3D;&#x3D;note:&#x3D;&#x3D;</strong> 从64位开始，isa需要进行一次位运算，才能计算出真实地址</p><h5 id="class对象的superclass指针"><a href="#class对象的superclass指针" class="headerlink" title="class对象的superclass指针"></a>class对象的superclass指针</h5><p><img src="http://rfshxohrg.hn-bkt.clouddn.com/WX20220730-110416.png" alt="image"></p><p><strong>&#x3D;&#x3D;note:&#x3D;&#x3D;</strong> 当student的instance对象要调用Person的对象方法时，会先通过&#x3D;&#x3D;isa&#x3D;&#x3D;找到Student的class，然后通过&#x3D;&#x3D;superclass&#x3D;&#x3D;找到Person的class，最后找到对象方法的实现进行调用</p><h5 id="meta-class对象的superclass指针"><a href="#meta-class对象的superclass指针" class="headerlink" title="meta-class对象的superclass指针"></a>meta-class对象的superclass指针</h5><p><img src="http://rfshxohrg.hn-bkt.clouddn.com/WX20220730-111359.png" alt="image"></p><p><strong>&#x3D;&#x3D;note:&#x3D;&#x3D;</strong> 当Student的class要调用Person的类方法时，会先通过&#x3D;&#x3D;isa&#x3D;&#x3D;找到Student的meta-class，然后通过&#x3D;&#x3D;superclass&#x3D;&#x3D;找到Person的meta-class，最后找到类方法的实现进行调用</p><h4 id="isa、superclass总结"><a href="#isa、superclass总结" class="headerlink" title="isa、superclass总结"></a>isa、superclass总结</h4><p><img src="http://rfshxohrg.hn-bkt.clouddn.com/%E5%9B%BE%E7%89%871.png" alt="image"></p><ol><li>instance的isa指向class</li><li>class的isa指向meta-class</li><li>meta-class的isa指向基类的meta-class</li><li>class的superclass指向父类的class<br>如果没有父类，superclass指针为nil</li><li>meta-class的superclass指向父类的meta-class<br>基类的meta-class的superclass指向基类的class</li><li>instance调用对象方法的轨迹<br>isa找到class，方法不存在，就通过superclass找父类</li><li>class调用类方法的轨迹<br>isa找meta-class，方法不存在，就通过superclass找父类</li></ol><h5 id="64位isa指针"><a href="#64位isa指针" class="headerlink" title="64位isa指针"></a>64位isa指针</h5><ul><li>从64bit开始，isa需要进行一次位运算(isa地址 &amp; ISA_MASK)，才能计算出真实地址<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># if __arm64__</span><br><span class="line">#   define ISA_MASK        0x0000000ffffffff8ULL</span><br><span class="line"># elif __x86_64__</span><br><span class="line">#   define ISA_MASK        0x00007ffffffffff8ULL</span><br><span class="line"># endif</span><br></pre></td></tr></table></figure></li></ul><h5 id="struct-objc-class的结构"><a href="#struct-objc-class的结构" class="headerlink" title="struct objc_class的结构"></a>struct objc_class的结构</h5><ul><li>class、meta-class对象的本质结构都是struct objc_class<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">struct class_ro_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t instanceStart;</span><br><span class="line">    uint32_t instanceSize;  // instance对象占用的内存空间</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    uint32_t reserved;</span><br><span class="line">#endif</span><br><span class="line">    const uint8_t * ivarLayout;</span><br><span class="line">    const char * name;  // 类名</span><br><span class="line">    method_list_t * baseMethodList;</span><br><span class="line">    protocol_list_t * baseProtocols;</span><br><span class="line">    const ivar_list_t * ivars;  // 成员变量列表</span><br><span class="line">    const uint8_t * weakIvarLayout;</span><br><span class="line">    property_list_t *baseProperties;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct class_rw_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t version;</span><br><span class="line">    const class_ro_t *ro;</span><br><span class="line">    method_list_t * methods;    // 方法列表</span><br><span class="line">    property_list_t *properties;    // 属性列表</span><br><span class="line">    const protocol_list_t * protocols;  // 协议列表</span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line">    char *demangledName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#define FAST_DATA_MASK          0x00007ffffffffff8UL</span><br><span class="line">struct class_data_bits_t &#123;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">public:</span><br><span class="line">    class_rw_t* data() &#123;</span><br><span class="line">        return (class_rw_t *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* OC对象 */</span><br><span class="line">struct hx_objc_object &#123;</span><br><span class="line">    void *isa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* 类对象 */</span><br><span class="line">struct hx_objc_class : hx_objc_object &#123;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;</span><br><span class="line">    class_data_bits_t bits;</span><br><span class="line">public:</span><br><span class="line">    class_rw_t* data() &#123;</span><br><span class="line">        return bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    hx_objc_class* metaClass() &#123;</span><br><span class="line">        return (hx_objc_class *)((long long)isa &amp; ISA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>用如下方法进行断点查看，内部结构内容<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//实例对象</span><br><span class="line">hx_objc_class *studentClass = (__bridge hx_objc_class *)([Student class]);</span><br><span class="line">hx_objc_class *personClass = (__bridge hx_objc_class *)([Person class]);</span><br><span class="line"></span><br><span class="line">//类对象</span><br><span class="line">class_rw_t *studentClassData = studentClass-&gt;data();</span><br><span class="line">class_rw_t *personClassData = personClass-&gt;data();</span><br><span class="line"></span><br><span class="line">//元类对象</span><br><span class="line">class_rw_t *studentMetaClassData = studentClass-&gt;metaClass()-&gt;data();</span><br><span class="line">class_rw_t *personMetaClassData = personClass-&gt;metaClass()-&gt;data();</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Objective-c语法&quot;&gt;&lt;a href=&quot;#Objective-c语法&quot; class=&quot;headerlink&quot; title=&quot;Objective-c语法&quot;&gt;&lt;/a&gt;Objective-c语法&lt;/h1&gt;&lt;h4 id=&quot;Objective-C的本质&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="底层原理" scheme="http://www.hxtec.top/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
</feed>
