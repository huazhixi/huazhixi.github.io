<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ivan&#39;s Blog</title>
  
  <subtitle>华曦之家</subtitle>
  <link href="http://www.hxtec.top/atom.xml" rel="self"/>
  
  <link href="http://www.hxtec.top/"/>
  <updated>2022-09-17T10:28:10.201Z</updated>
  <id>http://www.hxtec.top/</id>
  
  <author>
    <name>ivan_华之曦</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>佳能相机</title>
    <link href="http://www.hxtec.top/2022/09/17/%E4%BD%B3%E8%83%BD%E7%9B%B8%E6%9C%BA/"/>
    <id>http://www.hxtec.top/2022/09/17/%E4%BD%B3%E8%83%BD%E7%9B%B8%E6%9C%BA/</id>
    <published>2022-09-17T10:25:51.000Z</published>
    <updated>2022-09-17T10:28:10.201Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、佳能单反相机的相关问题"><a href="#一、佳能单反相机的相关问题" class="headerlink" title="一、佳能单反相机的相关问题"></a>一、佳能单反相机的相关问题</h2><h3 id="1-佳能单反和尼康单反哪个好"><a href="#1-佳能单反和尼康单反哪个好" class="headerlink" title="1.佳能单反和尼康单反哪个好"></a>1.佳能单反和尼康单反哪个好</h3><p>1、尼康的使用评价：<strong>上手较难，风景很好</strong></p><ul><li>尼康偏向金属风，所以材质坚硬，沉重的质感不得不说是相机品质的体现，<strong>风景拍摄</strong>很赞。但同时也增加了<strong>携带的困难</strong>。</li><li>繁琐和困难的上手教程是很多新手头疼的问题，所以<strong>新手上路并不推荐</strong>。</li></ul><p>2、佳能的使用体验：<strong>上手容易，成像优质</strong></p><ul><li>佳能优越的<strong>人像摄影</strong>使佳能在摄影人像方面非常受人欢迎。搭载优秀的图像处理器，使得佳能拍出来的照片在后期处理非常出色。</li><li>简单易学的操作，让佳能深受新手欢迎。人们可以很容易地上手色彩和操作页面。</li></ul><p><strong>结论：</strong></p><ul><li>如果你是新手，对人像拍摄要求高，那么佳能可能更适合你；</li><li>反之如果你也是个专业大佬了，对风景拍摄要求高，那么可以选尼康。</li></ul><h3 id="2-单反相机-VS-微单相机-VS-普通数码相机（三者的比较）"><a href="#2-单反相机-VS-微单相机-VS-普通数码相机（三者的比较）" class="headerlink" title="2.单反相机 VS 微单相机 VS 普通数码相机（三者的比较）"></a>2.单反相机 VS 微单相机 VS 普通数码相机（三者的比较）</h3><h3 id="3-佳能单反型号的比较"><a href="#3-佳能单反型号的比较" class="headerlink" title="3.佳能单反型号的比较"></a>3.佳能单反型号的比较</h3><p>佳能所有数码单反采用以数字加字母D方式命名。在数字方面，数字位数越少，型号越高端。</p><ul><li>全画幅和旗舰APS-C画幅单反：一位数机型XD</li><li>高端APS-C画幅单反：两位数XXD）</li><li>中端APS-C画幅单反：三位数XXXD</li><li>低端APS-C画幅单反：四位数XXXXD</li></ul><h2 id="二、如何去选购一台好的佳能单反相机"><a href="#二、如何去选购一台好的佳能单反相机" class="headerlink" title="二、如何去选购一台好的佳能单反相机"></a>二、如何去选购一台好的佳能单反相机</h2><p>下面我们介绍几个最重要的性能：</p><p><strong>1、图像处理器和传感器</strong></p><p>单反相机的图像处理器就像是电脑的CPU芯片一样，他是这个相机的核心所在。在图片呈现的过程中，图像处理器负责接收感光器的数据，也就是说，他是照相的第一步，也是最关键的一步。</p><p>它需要一个好的传感器，传感器的类型分为全画幅，中画幅等。画幅越大的相机越优秀，就像屏幕越大的电子设备也就越贵，在选购单反相机时，选择全画幅才能有好的图像处理。</p><p><strong>2、像素</strong></p><p>它是计算数码影像的一种单位。 我们的照片由大量的像素构成。像素是决定一个相机的关键因素,根据预算和个人需求，大部分是越高的像素成像越好，结合个人要求来选择合适自己的像素，不必追求过高的像素。当下绝大部分单反和微单相机的像素都在两千万以上。</p><p><strong>小结：</strong> 尽管理论上像素越大越好，不过目前主流的相机的像素使用过来完全绰绰有余。</p><p><strong>3、续航能力</strong></p><p>当你在出去旅游或者野外拍摄时，你最关心的除了风景是否优美，然后就是你相机的电量问题，如果你拿着一部随时都要充电的相机的话，那么这个在拍摄过程中是没有任何快乐所言的，所以买相机最重要的因素之一，是他的续航能力，选择续航能力强的相机会，让你的旅途拍摄过程中更加愉快。</p><p><strong>4、连拍速度</strong></p><p>当你想要捕捉到旅途中一个动态的美景时，这个时候就要考虑你相机的连拍速度了。把你的相机连拍速度很快的话，那么你可以轻易捕捉到一张富有动态美的图片，在考虑相机参数的同时也要把连拍速度考虑进去，因为这一功能也是彰显相机性能是否强大的原因之一。</p><p><strong>5、感光度</strong></p><p>感光器有CCD和CMOS。原理是将感受到的物理光学信号转化为数码信息。在拍摄过程中，通过调解感光度可以获得不同光线下的照片。高感光度的相机可以给照片带来质的飞跃。</p><p><strong>6、其他功能</strong></p><p>防抖：相机的防抖功能可以让相片拍摄的更加清晰，减少因手抖导致的画面模糊，具备防抖功能的机身可以将任何一款镜头变为防抖镜头，增加相片的画质和清晰度。<br>防尘防水：当相机在日常使用和存放中，防水防尘的功能可以让相机的使用寿命延长，是相机的防护伞。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、佳能单反相机的相关问题&quot;&gt;&lt;a href=&quot;#一、佳能单反相机的相关问题&quot; class=&quot;headerlink&quot; title=&quot;一、佳能单反相机的相关问题&quot;&gt;&lt;/a&gt;一、佳能单反相机的相关问题&lt;/h2&gt;&lt;h3 id=&quot;1-佳能单反和尼康单反哪个好&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="相机" scheme="http://www.hxtec.top/categories/%E7%9B%B8%E6%9C%BA/"/>
    
    
    <category term="Camera" scheme="http://www.hxtec.top/tags/Camera/"/>
    
  </entry>
  
  <entry>
    <title>思考致富</title>
    <link href="http://www.hxtec.top/2022/09/17/%E6%80%9D%E8%80%83%E8%87%B4%E5%AF%8C/"/>
    <id>http://www.hxtec.top/2022/09/17/%E6%80%9D%E8%80%83%E8%87%B4%E5%AF%8C/</id>
    <published>2022-09-17T10:10:01.000Z</published>
    <updated>2022-09-17T10:24:38.837Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、心想才能事成"><a href="#一、心想才能事成" class="headerlink" title="一、心想才能事成"></a>一、心想才能事成</h2><ul><li>如果一个人真想做一件事，那他一定会做成。</li><li>成功人士，最伟大的成功在于，面临失败时能坚持再迈出一步。</li><li>不管一件事有多困难，都要坚持做下去。</li><li>成功钟情于那些有成功意识的人。</li><li>我们是自己命运的主宰者。</li></ul><h2 id="二、欲望"><a href="#二、欲望" class="headerlink" title="二、欲望"></a>二、欲望</h2><ul><li>拥有梦想，希望，愿望，欲望和计划。</li><li>明确的目标</li><li>绝不轻言放弃</li><li>没有人能被打败，除非接受失败的事实</li><li>一个人只有相信自己能得到某物，都会准备接受它。</li><li><code>每一种逆境，都隐藏着相同的优势。 </code></li></ul><h2 id="三、信心"><a href="#三、信心" class="headerlink" title="三、信心"></a>三、信心</h2><ul><li>信心，爱和性的力量最为强大。</li><li><code>不断反复并确定地对潜意识发号施令，是自发培养信心的唯一方法。 </code></li><li><code>抑制、排队消极负面情感，是一个人最基本的态度。 </code></li><li>一切都与心态有关，最后的胜利，属于那个相信自己能行的我。</li><li>杰出人物，他们每个人的背后几乎都有一个女性的爱在支持着他。</li></ul><h2 id="四、自我暗示"><a href="#四、自我暗示" class="headerlink" title="四、自我暗示"></a>四、自我暗示</h2><ul><li>你，只有你，来决定你为之奋斗的回报（即多钱意识），是否值得你为之辛苦地付出。</li></ul><h2 id="五、专业知识"><a href="#五、专业知识" class="headerlink" title="五、专业知识"></a>五、专业知识</h2><ul><li>知识只是潜在的力量，只有与明确的行动计划和目标相结合，知识才能成为力量。</li><li>人们只珍惜那些需要付费的东西。</li><li>那些安排业余时间在家学习的人，尤其是那些靠薪水为生的人，很少会满足于久居低层的现状，他们的行动为自己开辟了一条晋升之路，清除了前进道路上的障碍，赢得了有权给予他们机会的人的青睐。</li><li>从最底层做起，往往会让人感到前途暗淡，沮丧绝望， <code>它会扼杀一个人的抱负。 </code></li><li>不论一个人是升至高位，还是屈居低职，都取决于他对环境的控制能力。</li><li><code>成败在很大程度上才是“习惯”的结果 </code></li><li><code>和一个不向逆境妥协的人共事并密切接触，将是一笔永远无法用多钱衡量的财富。 </code></li><li>靠周密计划，避免从低层做起。</li><li>专业知识易得，而创新构想难求。</li></ul><h2 id="六、想象力"><a href="#六、想象力" class="headerlink" title="六、想象力"></a>六、想象力</h2><ul><li>想象力会因为疏于使用而变得迟钝，但也会因为使用而变得活跃、敏锐。</li><li>欲望是一种意念冲动，意念冲动就是一种能量形式。</li><li>当一股炽烈的欲望支撑着一个明确的目标时，一个人就会被激发出内在的热情、生机和力量。</li><li><code>假如你认为辛苦工作和诚实守信是唯一的致富之路，那么你一定要打消这个念头。 </code></li><li><code>一般的欲望不可能战胜失望、气馁、、暂时的挫折及批评，那是一种强烈的欲望，一种萦绕于心、挥之不去的意念。 </code></li><li>构想是一股无形的力量，却比产生它们的有形的头脑更强大。</li></ul><h2 id="七、精心策划"><a href="#七、精心策划" class="headerlink" title="七、精心策划"></a>七、精心策划</h2><ul><li>大部分人会遭遇失败的关键，是由于缺乏创造新计划来取代失败计划的持久毅力。</li><li><code>暂时的挫折并不代表永远的失败。 </code></li><li><code>如果轻易放弃，就是一个半途而废的人，一个半途而废的人，永远不可能成功，成功的人，绝不会半途而废。 </code></li><li>欲望才是赚钱的媒介。</li><li>无法控制自我的人，永远无法控制其他人。</li><li>最伟大的领导是众人之仆。</li><li>教育必须多讲实践，少讲理论。</li><li>关注自己能做什么。</li><li>有教养的人懂得在不侵犯他人利益的前提下，支获得自己想要的东西。</li><li>只有先控制自己，才能控制环境。</li><li><code>如果婚姻不和谐，失败会接踵而至，表现为不幸和痛苦，它能摧毁一个人所有的雄心壮志。 </code></li><li>任何形式的放纵，对成功来说都是致命的。</li><li>一夜暴富比贫穷理可怕。</li><li><code>诚实是一种不可替代的品质。 </code></li><li><code>谋求新的职位时，必须确保自己的价值高于目前所得到的报酬。 </code></li><li>一年一度的自我分析非常必要， <code>一个人的目标应该是不断前进。 </code></li><li>机会就在眼前。</li></ul><blockquote><p> 领导者的主要素质</p></blockquote><ol><li>因对自我以及所从事职业的认知而产生的毫不动摇的勇气</li><li>自制力</li><li>强烈的正义感</li><li>果断的决策</li><li>明确的计划</li><li>不计报酬的工作习惯</li><li>愉悦随和的个性</li><li>同情与体谅</li><li>掌握细节</li><li>愿负全责</li><li>合作</li></ol><p>能引起下属情感共鸣与认同的领导为佳</p><h2 id="八、决心"><a href="#八、决心" class="headerlink" title="八、决心"></a>八、决心</h2><ul><li>意见是世界上最廉价的商品，如果做决策时晚受他人影响，那么很难做成任何事。</li><li>如果总是受别人观点的影响，那么将失去自己的目标。</li><li><code>自己大脑，就要用它做出自己的决策。 </code></li><li><code>真正的智慧通常表现为谦虚和沉默。 </code></li><li>先做后说</li><li>各行种业的领导者都是那些能下决心的人。</li></ul><h2 id="九、毅力"><a href="#九、毅力" class="headerlink" title="九、毅力"></a>九、毅力</h2><ul><li><p>多钱意识必须刻意培养，除非一个人生来就有这种意识。</p></li><li><p>财富不会回应愿望，只能通过欲望的力量，借助持久的毅力，来回应明确的计划。</p></li><li><p>每一次失败都蕴藏着一颗潜在成功的种子。</p><blockquote><p> <strong>毅力形成具有明确的因素：</strong></p><ol><li>明确的目标，知道自己想要什么，强烈的动机会驱使人克服任何困难。</li><li>欲望</li><li>自信</li><li>明确的计划</li><li>认清自我</li><li>合作</li><li>意志力</li><li>习惯</li></ol></blockquote></li><li><p><code>如果坚持下去，机遇迟早会降临到自己头上。 </code></p></li><li><p><code>机遇都是自己创造的 </code>，来自毅力，其出发点是明确的目的。</p></li><li><p><code>财富不会回应欲望，只能通过欲望的力量，借助持久的毅力，来回应明确的计划。 </code></p><blockquote><p>如何培养毅力：</p><ol><li>在强烈欲望的驱使下，拥有明确的目的。</li><li>不断用行动体现出明确计划。</li><li>不受消极懈怠思想的影响，包括来自家人，朋友和熟人等思想的影响。</li><li>结交一个或几个能鼓励你依照计划和目标行事的人。</li></ol></blockquote></li><li><p>除了毅力，再找不到任何特质可以与其惊人成就相关的了。</p></li></ul><h2 id="十、智囊团的力量"><a href="#十、智囊团的力量" class="headerlink" title="十、智囊团的力量"></a>十、智囊团的力量</h2><ul><li>人类的大脑是一种能量形式</li><li>使他人的智慧与自己的智慧结合在一起。这正是获得力量的秘诀。</li><li>伟大的力量可以通过智慧的友善结盟而产生。</li><li>追求金钱时，那股力量必须再加上信心、欲望和毅力。</li><li><code>积极的思想情感会形成个人通往财富 </code>的那一侧水流，消极的情感形成带领个人流向贫穷的另一侧水流。</li></ul><h2 id="十一、性欲转换的奥秘"><a href="#十一、性欲转换的奥秘" class="headerlink" title="十一、性欲转换的奥秘"></a>十一、性欲转换的奥秘</h2><ul><li>性激情隐含三种建设性潜在力量：<blockquote><ol><li>人类的繁衍</li><li>保持健康（它的治疗作用无可比拟）</li><li>通过转化性欲力量，将庸才变成天才</li></ol></blockquote></li><li><code>性欲是人类最强烈的一种欲望。 </code></li><li>性欲的表达是天生的，自然的。</li><li><code>假如不用创造性的方式加以引导，它就会以不具有价值的渠道发泄出来。 </code></li><li><code>获得卓越成就的人，其背后都有女性的力量在驱动他们。 </code></li><li>大部分人只有通过情感才能受到影响。</li><li>“当事的女主角”通常都是个谦逊，甘愿自我牺牲的妻子。</li><li><code>一般人要在4-~60岁才能进入创造力最强的阶段，接近这个年纪是，不应心怀恐惧、忧虑，而是应该满怀希望、热切期待。 </code> 40~60岁是创造人生业绩的黄金时期。</li><li><code>30~40岁，人们开始学习性欲转换的技巧。 </code></li></ul><blockquote><p>开启情感动力</p></blockquote><ul><li>当爱开始和性的激情融合起来是，其结果就是目标专一、心态稳定、判断准确、身心平衡。<br> <code>一个人到了40岁之后，如果仍然无法体会并以自己的经验来加以印证这些的话，那真可谓是最大的不幸。 </code>    </li><li>当性激情里有了爱的情感之后，同样一个人就可能会更明智，心态更平和地引导自己的行为。</li><li>抑制所有破坏性情感的产生。</li><li><code>要想成为天才，除了通过自我努力之外，别无他法。 </code></li><li>爱、浪漫和性都能驱使男人达到成就的巅峰。    </li><li>爱的作用犹如安全阀，能确保身心平衡、宁静，做出建设性的工作。</li></ul><blockquote><p>真爱永存</p></blockquote><ul><li>得不到爱的激励而无法登上成就高峰的人是没有希望的——他会犹如行尸走肉。    </li><li>真正爱过的人不可能完全失去爱，也别存有真爱只有一次的念头。爱去了还会再来，没有一定的次数，但从来没有两份爱会以相同的方式影响一个人。</li><li>所有的爱都是财富，除非一个在爱离去时变得愤世嫉俗。    </li><li>爱是精神的，性是生理的。    </li><li>无疑，爱是人生最大的体验。  </li><li>只有爱，或者只有性，都无法为婚姻带来幸福， <code>这两种美好情感互相融合所产生的婚姻，是世人追求的理想精神境界。 </code></li></ul><blockquote><p>女人可以成就男人，也可以毁灭男人</p></blockquote><ul><li><code>如果妻子能了解爱、性激情和浪漫之间的真正关系，那么她的丈夫是幸运的。 </code> 受到这三种神圣组合所激励时，没有一种劳动会成为负担，因为此时，即使最低等的劳动形式也是基于爱而产生的。  </li><li>成就和毁灭，其实就在于女人是否了解“爱”，“性”和“浪漫情感”。</li><li>假如一个女人让男人对她失去兴趣而去对另外一个女人产生兴趣，通常是因为她对于性、爱和浪漫情感的无知和漠视所导致的，这种说法的前提当然是假设他们之间曾经存在一份真爱。</li></ul><blockquote><p>没有女性的财富毫无价值</p></blockquote><ul><li>男人最强的动力是取悦女人的欲望！    </li><li>现代男人取悦女人的欲望与史前没有改变。  </li><li>如果生命中的女人被夺走，那么再多的财富对于大多数男人而言都没有意义。    </li><li>了解男人的本性并巧妙地迎合其需要的女人，无须担心来自其他女人的竞争。    </li><li>用积极的心态，面对惨淡的人生，永远相信美好的事情即将到来。</li></ul><h2 id="十二、潜意识——连接环节"><a href="#十二、潜意识——连接环节" class="headerlink" title="十二、潜意识——连接环节"></a>十二、潜意识——连接环节</h2><ul><li>潜意识只有通过习惯才能受到自己的意愿指引。</li></ul><blockquote><p>利用积极情感</p></blockquote><ul><li>只有被赋予情感的意念，才能对潜意识产生行动的影响力</li><li>积极情感和消极情感不会同时存在于心，一定是只有一种占据主导地位。    </li><li>认识不到这一重要事实的男人，就失去了取得成就所需的最强大的力量。</li><li><code>我们有责任让积极情感成为内心的主宰力量。 </code></li></ul><h2 id="十三、大脑——思想的广播站和接收站"><a href="#十三、大脑——思想的广播站和接收站" class="headerlink" title="十三、大脑——思想的广播站和接收站"></a>十三、大脑——思想的广播站和接收站</h2><ul><li>就强度和马士图而言，性高居人类各种情感之首。</li><li>潜意识、创造型想象力和自我暗示。</li></ul><h2 id="十四、第六感——通往智慧殿堂之门"><a href="#十四、第六感——通往智慧殿堂之门" class="headerlink" title="十四、第六感——通往智慧殿堂之门"></a>十四、第六感——通往智慧殿堂之门</h2><ul><li>即使无法成为真正的伟人，也要模仿伟人，在感觉和行动上尽可能地接近他们。</li><li>让个人可以正确无误地指引自己，获得人生中追求的一切。</li><li><code>任何成就的起点都是欲望，终极目标则是寻求认识——认识自我，认识他人，认识自然规律，认识和理解幸福。 </code></li></ul><h2 id="十五、6种恐惧——剖析自我，找出成功路上的“拦路虎”"><a href="#十五、6种恐惧——剖析自我，找出成功路上的“拦路虎”" class="headerlink" title="十五、6种恐惧——剖析自我，找出成功路上的“拦路虎”"></a>十五、6种恐惧——剖析自我，找出成功路上的“拦路虎”</h2><ul><li>除掉的三个敌人：犹豫、怀疑和恐惧。</li><li>财富可能是多钱，还可能是大于多钱价值的心态。</li><li>6各恐惧：1.贫穷 2.批评 3.病痛 4.失去爱情 5.衰老 6.死亡</li><li>一个人的心态是可以控制和引导的。</li><li><code>人的意念冲动，不管是自觉的，还是不自觉的，都会很快转化为它的实质对等物。 </code></li><li><code>每个人都有能力完全控制自己的意志。 </code></li><li>通往财富之路的起点，就是欲望。</li><li><code>带给人类痛苦和屈辱的莫过于贫穷了。 </code></li><li>疾病有时始于消极的意念冲动。</li><li>40~60岁是一个人的黄金时期，身心两方面都是如此，应该因为到了这个充满智慧和领悟的年龄而心存感激。</li><li>忙碌的人无暇想到死亡。</li><li><code>不安定的心是无助的。 </code></li><li>要成功，必须有平和的心态。</li><li><code>你有能力控制自己的意志，也一定能掌握自己的命运。 </code></li><li><code>我们可以影响、指引并最终控制自己的环境，创造自己想要的人生。 </code></li><li>刻意与那些能从正面影响你、让你为自己思考和行动的人为伴。</li><li>意志控制是自律和习惯的结果。如果你不控制意志，那么它就会控制你。</li><li>寻找托词并以它来为失败辩护，这是所有的人都乐此不疲的习惯，编造托词是个根深蒂固的习惯。</li><li><code>生命就像一盘棋，你的对手就是时间。 </code></li><li>满足感属于那些征服自我，向生活索取回报的人，这种回报值得你为之努力。</li></ul><h4 id="精选"><a href="#精选" class="headerlink" title="精选"></a>精选</h4><ul><li>所有的成就，所有的财富，都有其意念的源泉。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、心想才能事成&quot;&gt;&lt;a href=&quot;#一、心想才能事成&quot; class=&quot;headerlink&quot; title=&quot;一、心想才能事成&quot;&gt;&lt;/a&gt;一、心想才能事成&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;如果一个人真想做一件事，那他一定会做成。&lt;/li&gt;
&lt;li&gt;成功人士，最伟大的成</summary>
      
    
    
    
    <category term="读书笔记" scheme="http://www.hxtec.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="励志" scheme="http://www.hxtec.top/tags/%E5%8A%B1%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>好好学习</title>
    <link href="http://www.hxtec.top/2022/09/17/%E5%A5%BD%E5%A5%BD%E5%AD%A6%E4%B9%A0/"/>
    <id>http://www.hxtec.top/2022/09/17/%E5%A5%BD%E5%A5%BD%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-09-17T10:07:34.000Z</published>
    <updated>2022-09-17T10:17:28.147Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、知识管理与认识优势"><a href="#一、知识管理与认识优势" class="headerlink" title="一、知识管理与认识优势"></a>一、知识管理与认识优势</h2><p>知识与知识是不一样的，有些知识比其他知识的威力更大，少数的知识能够给我们带来关键的影响，这就是临界知识。</p><h3 id="在海量信息即时获取时代，我们拼什么？"><a href="#在海量信息即时获取时代，我们拼什么？" class="headerlink" title="在海量信息即时获取时代，我们拼什么？"></a>在海量信息即时获取时代，我们拼什么？</h3><ul><li>一阶段，知识数量构建认识优势</li><li>二阶段，知识获取速度构建认知优势</li><li>三阶段，知识深度构建认知优势，认识的深度</li></ul><h3 id="如何提升认知深度？"><a href="#如何提升认知深度？" class="headerlink" title="如何提升认知深度？"></a>如何提升认知深度？</h3><h3 id="为什么大多数人的学习层次上不去？"><a href="#为什么大多数人的学习层次上不去？" class="headerlink" title="为什么大多数人的学习层次上不去？"></a>为什么大多数人的学习层次上不去？</h3><ul><li>重要的是：认识效率</li><li>对于大多数人而言，我们知道的，只是我们以为自己知道了</li><li>如果我们的学习是在了解问题本质，了解解决方案的底层规律，能够让我们认清楚问题表象背后的实质，那我们就是在提升认知效率。</li></ul><h3 id="到底哪些知识值得学？"><a href="#到底哪些知识值得学？" class="headerlink" title="到底哪些知识值得学？"></a>到底哪些知识值得学？</h3><ul><li>斜杠&#x3D;兼职？ 你更多的只是经历了一下而已，认知深度资并没有明显增加。</li><li>斜杠是结果，不是原因。斜杠是提升认知深度的结果，而不是追求多元的结果。</li><li>一开始就能带来直接利益和诱惑的事情，很可能要拿未来的机会作代价。</li><li>一个人，活成一支队伍。</li><li>无用之用，方为大用。</li><li>执行能力、专业能力和结构能力都应该学。</li></ul><h2 id="二、掌握临界知识的底层思维与方法"><a href="#二、掌握临界知识的底层思维与方法" class="headerlink" title="二、掌握临界知识的底层思维与方法"></a>二、掌握临界知识的底层思维与方法</h2><p>对于学习临界知识而言，首先要掌握的底层思维与方法，其次才是具体的知识和技能</p><h3 id="跳出“低水平勤奋陷阱”"><a href="#跳出“低水平勤奋陷阱”" class="headerlink" title="跳出“低水平勤奋陷阱”"></a>跳出“低水平勤奋陷阱”</h3><ul><li>读书，自然是最基本而又重要的方式。</li><li>在新旧知识间建立联系，理解和记忆一个个孤立的信息，可不是我们大脑擅长的高效行为。</li><li>用记忆宫殿法，花时间去加工这些信息。</li><li>读书一定要花时间、耐心和思考力，将获得的新知识和已有的知识进行网络状的联系。</li><li>生命有限，不要把有限的生命浪费在那些“低水平勤奋陷阱”里。</li></ul><h3 id="学习临界知识"><a href="#学习临界知识" class="headerlink" title="学习临界知识"></a>学习临界知识</h3><ul><li>绿灯思维</li><li>习惯性防卫的根源是惧怕暴露出我们想法背后的思维。</li><li>以慢为快</li><li>真正高效的学习，其实是知识融会贯通的结果。</li><li>读书的目的：打通知识的阻塞，实现融会贯通</li><li>知道、明白一个道理，和相信、践行一个道理是两码事。</li><li>真正阻碍我们的是我们的不确定和恐惧。</li><li>别说读书无用，是你不认真、没读好。</li></ul><h3 id="提升学习能力的三个底层方法"><a href="#提升学习能力的三个底层方法" class="headerlink" title="提升学习能力的三个底层方法"></a>提升学习能力的三个底层方法</h3><ul><li>学习临界知识的过程，本身就是深度思考的过程。</li><li>复盘我们每天的生活：复盘每一天的决策都是在什么样的假设下做出的，又产生了什么样的效果。</li><li>让自己安静，向内求。</li><li>加速改变理假设、发现新假设的过程，就是在提升我们的学习能力。</li><li>反思、以教为学和刻意练习。</li><li>反思的实质是对假设进行校正。<ul><li>做事的顺序：做出假设-&gt;采取行动-&gt;产生结果</li><li>反思的顺序：观察结果(现象)-&gt;研究原先假设-&gt;反思校正假设</li></ul></li><li>把生活的点滴细节管理好，就是在管理我们自己的人生。</li><li>我们读书就是读别人的生活经历和感悟，而最好的书，其实是我们自己的生活经历和感悟。</li><li>人之所以会改变，是因为他得到了反馈。（人的进步和行为的改变，往往源自反馈）</li><li>人与人之间的差距不是来自年龄，甚至不是来自经验，而是来自经验总结、反思和升华的能力。</li><li>如何与我们的负面情绪相处，以及如何积极地调动我们的正面情绪，使之发挥更大的作用。</li><li>所谓心理表征，是指我们的大脑在思考问题时对应的心理结构。</li><li>元认知，是对我们思考过程的思考。正是我们的思考过程，决定了我们思考的结果。</li><li>刻意练习，就是提升元认识能力的过程。差别表现为认知效率与认知深度。</li><li>元认知与临界知识，一个是思考过程，一个是思考工具。</li><li>刻意练习最关键的还不是掌握具体的临界知识，而是要改变我们的思考过程，有意识地应用更高级的心理表征解决问题，提升元认知能力。</li><li><code>持续、刻意地进行大量专注练习 </code>。</li></ul><h3 id="持续提升学习能力的三个技巧"><a href="#持续提升学习能力的三个技巧" class="headerlink" title="持续提升学习能力的三个技巧"></a>持续提升学习能力的三个技巧</h3><blockquote><p> 记录、定期回顾与付费购买。</p></blockquote><ul><li>记录是主动思考的过程，是挖掘看得见的事情背后看不见的关系。</li><li>记录的时间跨度越长，就越可能让自己看到更深层的规律。</li><li>如果看不到事情背后的长期规律，那么我们就只能对发生的事情本身做出反应，而无法顾及更长远的利益。</li><li>越是复杂的问题，越要用基本、简单的原则思考，比如正直、不撒谎、不贪婪、不给人添乱。</li><li>影响提升认知效率的因素有两个：<ul><li>学习内容的数量和质量，故想办法提升自己学习内容的质量并增加数量</li><li>用于学习的时间，故增加有效学习时间。</li></ul></li><li>越早让自己的认知升级，就越能享受其带来的复利效应。</li></ul><h2 id="三、发现和应用自己的临界知识"><a href="#三、发现和应用自己的临界知识" class="headerlink" title="三、发现和应用自己的临界知识"></a>三、发现和应用自己的临界知识</h2><p>在掌握了理念和方法的基础上，回到核心问题：如何找到临界知识？怎样能够把临界知识真正应用起来，实现知行合一？</p><h3 id="为什么临界知识能四两拨千斤？"><a href="#为什么临界知识能四两拨千斤？" class="headerlink" title="为什么临界知识能四两拨千斤？"></a>为什么临界知识能四两拨千斤？</h3><ul><li>很多时候，复杂的世界是由简单的基本规律决定的。</li><li>复杂系统不是简单的因果关系累加，而是各因素相互影响的动态系统。</li><li>用临界知识学习和思考是效率最高的。</li></ul><h3 id="如何发现自己的临界知识？"><a href="#如何发现自己的临界知识？" class="headerlink" title="如何发现自己的临界知识？"></a>如何发现自己的临界知识？</h3><ul><li>临界知识其实是对事物更底层规律的总结。</li><li>持续高强度练习是提升能力的必由之路。</li><li>只有构建提升心理表征，才能把练习从低水平重复提升到更高层次。</li><li>我们不是要找一个答案，而是要培养自己找出答案的能力。</li></ul><h3 id="天赋与学习临界知识的关系"><a href="#天赋与学习临界知识的关系" class="headerlink" title="天赋与学习临界知识的关系"></a>天赋与学习临界知识的关系</h3><ul><li>坚持努力这件事情，除了要有意志力外，更重要的应该是对这个成长过程从心底热爱和喜欢。</li><li>你的优势就是那些让你感到自己很强大的事。</li><li>方法和技巧永远只是工具：内心的热情和天赋，才是让生活创造精彩奇迹的剑刃。</li><li>真正重要的是：我们应当对这个世界充满好奇，有自己的热情和独立思考。</li></ul><h3 id="如何应用临界知识？"><a href="#如何应用临界知识？" class="headerlink" title="如何应用临界知识？"></a>如何应用临界知识？</h3><ul><li>刻意练习必须关注两点：1.抓住问题的本质进行训练；2.大量地持续练习。</li><li>认知能力提升的背后，偷不得一点懒。</li><li>我们能成为顶级选手并没有什么秘诀，而是对可能是基本技能的东西有更深刻的理解。</li><li>我们的决策是基于我们获得的信息质量。</li><li>穷人的思维带宽被眼前的危机占满了，他们没有多余的时间来考虑长远。</li><li>解释大致分为三个层次：现象解释，技术规律解释和通用规律解释。</li></ul><h3 id="用临界知识构建自己的“能力圈”"><a href="#用临界知识构建自己的“能力圈”" class="headerlink" title="用临界知识构建自己的“能力圈”"></a>用临界知识构建自己的“能力圈”</h3><ul><li>在能力圈中投资。</li><li>要配得上自己的欲望。 <code>你必须让自己配得上自己的欲望。 </code></li><li>不能界定边界的能力，称不上真正的能力。</li><li><code>重大的决策，请在你的能力圈内做出。 </code> 即使那是一个看起来很好的机会。</li><li>做狙击手，而非敢死队，因为我们80%的成功，是由20%的决定引发的。</li><li><code>你的本事是不是真的好，一个重要的标准是有没有人愿意为此埋单。 </code></li></ul><h2 id="四、案例：核心临界知识及其应用"><a href="#四、案例：核心临界知识及其应用" class="headerlink" title="四、案例：核心临界知识及其应用"></a>四、案例：核心临界知识及其应用</h2><p>每个人都应当有自己的框架来安排自己的临界知识，不过，确实有一些重要的临界知识是通用的。<br>《穷查理宝典》提及的几个临界知识：复利效应、概率论、黄金思维圈、进化论、系统思考、二八法则、安全空间。</p><h3 id="复利效应"><a href="#复利效应" class="headerlink" title="复利效应"></a>复利效应</h3><blockquote><p> 复利 - 世界第八大奇迹</p></blockquote><ul><li>被爱因斯坦称为世界第八大奇迹的，是“复利”。</li><li>复利的本质： <code>做事情A，会导致结果B，而结果B又会加强A，不断循环。 </code></li><li>数学就是一个思考工具，表达工具，而不是计算工具。</li><li>数学的本质是表达的艺术。</li><li>幂律分布，正太分布。</li><li>只有执行的次数足够多时，复利的效应才能发挥出来。</li><li>你所触碰的世界比你想象的更广阔。</li><li>运气只能左右黑天鹅事件的迟早，却不能左右它是否发生。</li><li>拓展人脉的关键： <code>首先是不断地提升自己的价值，让自己变得对他人有帮助，其次，才是让别人知道自己的价值。 </code></li><li><code>当你的收入扣除生活成本和自我成长之外，还有闲置资金的时候 </code>，这些钱，才是应该拿去理财投资的，这才是真正理解了复利模型。</li></ul><h3 id="概率论"><a href="#概率论" class="headerlink" title="概率论"></a>概率论</h3><ul><li>我们不能仅仅凭借结果来判断之前的决策是好的。</li><li>生活是一个各项条件随机发生的概率分布。</li><li>解读已经发生的事情，应对不确定的未来。</li><li>过去的每一件事情的结果，是众多可能的结果之一。</li><li>如果我们在大概率事件上持续投入，在概率事件发生的可能性会极大增加。</li><li>我们要有冗余备份、安全备份，防止小概率事件给我们造成无法挽回的损失。</li><li>极致努力可以改变获胜的概率，概率不是固定值，而是动态值。</li></ul><h3 id="黄金思维圈"><a href="#黄金思维圈" class="headerlink" title="黄金思维圈"></a>黄金思维圈</h3><ul><li>技术层面的事情有很多成熟的方法，给予时间训练就能提高；而思维方式的问题，因为涉及很多底层的假设和思维模式，如果没有一定的基础是难以改变的。</li><li>优秀的人，在思考问题时，不会被表象迷惑。</li><li>以始为终地去开展工作。</li></ul><blockquote><p> 工作话题，建议：</p></blockquote><ul><li><code>关注你接下来会和谁一起工作，做什么事情，能收获什么。 </code></li><li><code>创造各种机会参与多种问题的解决过程，寻找你喜欢并且敬佩的导师。 </code></li><li>新人尽快成长，职场老人，靠的是业绩能力和全局视野，让人相信新的可能性。</li><li><code>好工作真正的价值在于训练你的思维方式，开拓视野。 </code></li></ul><h3 id="进化论"><a href="#进化论" class="headerlink" title="进化论"></a>进化论</h3><ul><li>坐以待毙，是最危险的</li><li><code>位置比努力重要 </code></li><li>你在哪儿比你干什么更重要，因为你所处的位置拥有信息优势。</li><li>找到人脉中心，要么自己成为人脉中心，要么结识更多的人脉中心</li><li>说大道理，人人可以，可是践行的，就微乎其微。</li><li>破局知道的太多，却没有行动：<ol><li>祈祷自己拥有冒险的基因</li><li>精益创业，最小成本试错，最小成本，快速试错，快速改进</li><li>模仿领先者的行动， 模仿也是管理学上的对标，真正的模仿是理解“为什么”。</li></ol></li><li>所以， <code>重要的不是你知道多少，而是你能采取行动，改变多少。 </code> 知道和做到是两码事儿。</li></ul><h3 id="系统思考"><a href="#系统思考" class="headerlink" title="系统思考"></a>系统思考</h3><ul><li>群体是无法思考的。</li><li>当因和果在系统中有延迟之时，我们就很难看到背后的动作规律。</li><li>训练系统思考能力：<ol><li>关注“关系”而非“事物”</li><li>分析系统结构，也可以从历史情况入手</li><li>独立思考，快速试错，观察系统的结果</li><li>系统关键解有时在信息制高点</li></ol></li><li>及时反馈，对系统的行为有很大的影响， <code>有时候成功，不是因为努力，只是幸运地处在正确的位置。 </code></li></ul><h3 id="二八法则"><a href="#二八法则" class="headerlink" title="二八法则"></a>二八法则</h3><ul><li>人脉的三个价值：<ol><li>情感，提供情感慰藉</li><li>信息，提供信息情报</li><li>能力，分享资源能力</li></ol></li><li>结构洞，非重复关系</li><li><code>信息和财富一样，从来不会均匀地传播。 </code></li><li>真正的人脉，应该是促成连接，促成信息交流的。</li><li><code>信任，是构建能力交换的基础。 </code></li><li>能够成为好朋友，最核心的是价值观的认同。</li><li>真诚，永远是你赢得别人信任的好伙伴。</li><li>快速建立对方信任：<ol><li>自我暴露</li><li>做一个给予者，互惠原理，将欲取之，必先予之。</li></ol></li><li>等到未来的某一天，只注意到结果的人会对你说：当初你真是走了狗屎运了。你一笑就好。</li></ul><h3 id="安全空间"><a href="#安全空间" class="headerlink" title="安全空间"></a>安全空间</h3><ul><li>应该有一个可以保证自己生存的计划</li></ul><blockquote><p> 综合应用</p></blockquote><ul><li>术从简，道从心</li><li><code>只有能够改变你行动的信息才是知识。 </code></li><li><code>对于学习这件事情，自己是最好的老师。 </code></li><li>一切的学习和努力无非三个目标：一是解释问题，二是解决问题，三是预测问题。</li><li>真正的优势不是去追那些what，而是 <code>问自己why </code></li><li>不追热点，关注经典。</li><li>诚然， <code>任何一个问题都没有标准答案。 </code></li><li><code>深度的认知学习，永远要耐得住寂寞，下得去苦功夫。 </code></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、知识管理与认识优势&quot;&gt;&lt;a href=&quot;#一、知识管理与认识优势&quot; class=&quot;headerlink&quot; title=&quot;一、知识管理与认识优势&quot;&gt;&lt;/a&gt;一、知识管理与认识优势&lt;/h2&gt;&lt;p&gt;知识与知识是不一样的，有些知识比其他知识的威力更大，少数的知识能够给</summary>
      
    
    
    
    <category term="读书笔记" scheme="http://www.hxtec.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="励志" scheme="http://www.hxtec.top/tags/%E5%8A%B1%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Block - __block本质</title>
    <link href="http://www.hxtec.top/2022/09/17/Block-block%E6%9C%AC%E8%B4%A8/"/>
    <id>http://www.hxtec.top/2022/09/17/Block-block%E6%9C%AC%E8%B4%A8/</id>
    <published>2022-09-17T09:54:02.000Z</published>
    <updated>2022-09-17T09:58:41.299Z</updated>
    
    <content type="html"><![CDATA[<h2 id="block修饰符"><a href="#block修饰符" class="headerlink" title="__block修饰符"></a>__block修饰符</h2><ul><li>__block可以用于解决block内部无法修改auto变量值的问题</li><li>__block不能修饰全局变量、静态变量（static）</li><li>编译器会将__block变量包装成一个对象</li></ul><blockquote><p>示例1：__block修饰auto常量时</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">__block int age = 10;</span><br><span class="line">^&#123;</span><br><span class="line">    NSLog(@&quot;age is %d&quot;, age);</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line">//C++源码分析</span><br><span class="line">//block对象信息</span><br><span class="line">struct __block_impl &#123;</span><br><span class="line">    void *isa;</span><br><span class="line">    int Flags;</span><br><span class="line">    int Reserved;</span><br><span class="line">    void *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//block描述信息，大小，copy, dispose操作</span><br><span class="line">struct __main_block_desc_0 &#123;</span><br><span class="line">    size_t reserved;</span><br><span class="line">    size_t Block_size;</span><br><span class="line">    void (*copy)(void);</span><br><span class="line">    void (*dispose)(void);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//被包装成__Block_byref_age_0结构体</span><br><span class="line">struct __Block_byref_age_0 &#123;</span><br><span class="line">  void *__isa;</span><br><span class="line">__Block_byref_age_0 *__forwarding;</span><br><span class="line"> int __flags;</span><br><span class="line"> int __size;</span><br><span class="line"> int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//block结构体内容</span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  NSObject *p;</span><br><span class="line">  </span><br><span class="line">  //被包装成一个函数</span><br><span class="line">  __Block_byref_age_0 *age; // by ref</span><br><span class="line">  </span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, NSObject *_p, __Block_byref_age_0 *_age, int flags=0) : p(_p), age(_age-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>示例1：__block修饰对象时</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">//ARC环境下，编译器会对block进行copy操作。</span><br><span class="line">Person *person = [[Person alloc] init];</span><br><span class="line">Block block = ^&#123;</span><br><span class="line">    NSLog(@&quot;%p&quot;, person);</span><br><span class="line">&#125;;</span><br><span class="line">block();</span><br><span class="line">        </span><br><span class="line">//C++源码解析：</span><br><span class="line">struct __block_impl &#123;</span><br><span class="line">    void *isa;</span><br><span class="line">    int Flags;</span><br><span class="line">    int Reserved;</span><br><span class="line">    void *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct __main_block_desc_0 &#123;</span><br><span class="line">    size_t reserved;</span><br><span class="line">    size_t Block_size;</span><br><span class="line">    void (*copy)(void);</span><br><span class="line">    void (*dispose)(void);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct __Block_byref_weakPerson_0 &#123;</span><br><span class="line">  void *__isa; // 8</span><br><span class="line"> __Block_byref_weakPerson_0 *__forwarding; // 8</span><br><span class="line"> int __flags; // 4</span><br><span class="line"> int __size; // 4</span><br><span class="line"> </span><br><span class="line"> //内存管理相关</span><br><span class="line"> void (*__Block_byref_id_object_copy)(void*, void*); // 8</span><br><span class="line"> void (*__Block_byref_id_object_dispose)(void*); // 8</span><br><span class="line"> </span><br><span class="line"> Person *__weak weakPerson;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  </span><br><span class="line">  __Block_byref_weakPerson_0 *weakPerson; // by ref</span><br><span class="line">  </span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_weakPerson_0 *_weakPerson, int flags=0) : weakPerson(_weakPerson-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="block的内存管理"><a href="#block的内存管理" class="headerlink" title="__block的内存管理"></a>__block的内存管理</h2><ul><li>当block在栈上时，并不会对__block变量产生强引用</li><li>当block被copy到堆时<ul><li>会调用block内部的copy函数</li><li>copy函数内部会调用_Block_object_assign函数</li><li>_Block_object_assign函数会对__block变量形成强引用（retain）</li></ul></li><li>当block从堆中移除时<ul><li>会调用block内部的dispose函数</li><li>dispose函数内部会调用_Block_object_dispose函数</li><li>_Block_object_dispose函数会自动释放引用的__block变量（release）</li></ul></li></ul><h3 id="block的-forwarding指针"><a href="#block的-forwarding指针" class="headerlink" title="__block的__forwarding指针"></a>__block的__forwarding指针</h3><ul><li>在栈上的话，__forwarding指向自己</li><li>在堆上的话，__forwarding指向复制到堆上的的__block变量结构体的指针</li></ul><h3 id="对象类型的auto变量、-block变量"><a href="#对象类型的auto变量、-block变量" class="headerlink" title="对象类型的auto变量、__block变量"></a>对象类型的auto变量、__block变量</h3><ul><li>当block在栈上时，对它们都不会产生强引用</li><li>当block拷贝到堆上时，都会通过copy函数来处理它们<ul><li>__block变量（假设变量名叫做a）</li><li>_Block_object_assign((void*)&amp;dst-&gt;a, (void*)src-&gt;a, 8&#x2F;<em>BLOCK_FIELD_IS_BYREF</em>&#x2F;);</li></ul></li><li>对象类型的auto变量（假设变量名叫做p）<ul><li>_Block_object_assign((void*)&amp;dst-&gt;p, (void*)src-&gt;p, 3&#x2F;<em>BLOCK_FIELD_IS_OBJECT</em>&#x2F;);</li></ul></li><li>当block从堆上移除时，都会通过dispose函数来释放它们<ul><li>__block变量（假设变量名叫做a）</li><li>_Block_object_dispose((void*)src-&gt;a, 8&#x2F;<em>BLOCK_FIELD_IS_BYREF</em>&#x2F;);</li></ul></li><li>对象类型的auto变量（假设变量名叫做p）<ul><li>_Block_object_dispose((void*)src-&gt;p, 3&#x2F;<em>BLOCK_FIELD_IS_OBJECT</em>&#x2F;);</li></ul></li></ul><h3 id="被-block修饰的对象类型"><a href="#被-block修饰的对象类型" class="headerlink" title="被__block修饰的对象类型"></a>被__block修饰的对象类型</h3><ul><li>当__block变量在栈上时，不会对指向的对象产生强引用</li><li>当__block变量被copy到堆时<ul><li>会调用__block变量内部的copy函数</li><li>copy函数内部会调用_Block_object_assign函数</li><li>_Block_object_assign函数会根据所指向对象的修饰符（__strong、__weak、__unsafe_unretained）做出相应的操作，形成强引用（retain）或者弱引用（ <code>注意：这里仅限于ARC时会retain，MRC时不会retain </code>）</li></ul></li><li>如果__block变量从堆上移除<ul><li>会调用__block变量内部的dispose函数</li><li>dispose函数内部会调用_Block_object_dispose函数</li><li>_Block_object_dispose函数会自动释放指向的对象（release）</li></ul></li></ul><h3 id="循环引用问题"><a href="#循环引用问题" class="headerlink" title="循环引用问题"></a>循环引用问题</h3><h4 id="解决循环引用问题-ARC"><a href="#解决循环引用问题-ARC" class="headerlink" title="解决循环引用问题 - ARC"></a>解决循环引用问题 - ARC</h4><blockquote><p>用__weak、__unsafe_unretained解决</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//用__weak解决</span><br><span class="line">__weak typeof(self) weakSelf = self;</span><br><span class="line">self.block = ^&#123;</span><br><span class="line">    NSLog(@&quot;%p&quot;, weakSelf);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//用__unsafe_unretained解决</span><br><span class="line">__unsafe_unretained id weakSelf = self;</span><br><span class="line">self.block = ^&#123;</span><br><span class="line">    NSLog(@&quot;%p&quot;, weakSelf);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">注：</span><br><span class="line">// __weak：不会产生强引用，指向的对象销毁时，会自动让指针置为nil</span><br><span class="line">// __unsafe_unretained：不会产生强引用，不安全，指向的对象销毁时，指针存储的地址值不变</span><br></pre></td></tr></table></figure><blockquote><p>用__block解决（必须要调用block）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__block id weakSelf = self;</span><br><span class="line">self.block = ^&#123;</span><br><span class="line">    NSLog(@&quot;%p&quot;, weakSelf);</span><br><span class="line">    weakSelf = nil;</span><br><span class="line">&#125;;</span><br><span class="line">self.block()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;block修饰符&quot;&gt;&lt;a href=&quot;#block修饰符&quot; class=&quot;headerlink&quot; title=&quot;__block修饰符&quot;&gt;&lt;/a&gt;__block修饰符&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;__block可以用于解决block内部无法修改auto变量值的问题&lt;/</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="底层原理" scheme="http://www.hxtec.top/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    <category term="Category" scheme="http://www.hxtec.top/tags/Category/"/>
    
  </entry>
  
  <entry>
    <title>Block - 本质认识，变量捕获，类型</title>
    <link href="http://www.hxtec.top/2022/09/17/Block-%E6%9C%AC%E8%B4%A8%E8%AE%A4%E8%AF%86%EF%BC%8C%E5%8F%98%E9%87%8F%E6%8D%95%E8%8E%B7%EF%BC%8C%E7%B1%BB%E5%9E%8B/"/>
    <id>http://www.hxtec.top/2022/09/17/Block-%E6%9C%AC%E8%B4%A8%E8%AE%A4%E8%AF%86%EF%BC%8C%E5%8F%98%E9%87%8F%E6%8D%95%E8%8E%B7%EF%BC%8C%E7%B1%BB%E5%9E%8B/</id>
    <published>2022-09-17T09:45:57.000Z</published>
    <updated>2022-09-17T09:51:48.316Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本认识"><a href="#基本认识" class="headerlink" title="基本认识"></a>基本认识</h2><ul><li>block本质上也是一个OC对象，它内部也有个isa指针</li><li>block是封装了函数调用以及函数调用环境的OC对象</li><li>以下是一个block：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int age = 20;</span><br><span class="line">        </span><br><span class="line">void (^block)(int, int) =  ^(int a , int b)&#123;</span><br><span class="line">    NSLog(@&quot;this is a block! -- %d&quot;, age);</span><br><span class="line">&#125;;</span><br><span class="line">block()</span><br></pre></td></tr></table></figure></li></ul><h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_desc_0 &#123;</span><br><span class="line">    size_t reserved;</span><br><span class="line">    size_t Block_size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct __block_impl &#123;</span><br><span class="line">    void *isa;</span><br><span class="line">    int Flags;</span><br><span class="line">    int Reserved;</span><br><span class="line">    void *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">    struct __block_impl impl;</span><br><span class="line">    struct __main_block_desc_0* Desc;</span><br><span class="line">    int age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="block变量捕获"><a href="#block变量捕获" class="headerlink" title="block变量捕获"></a>block变量捕获</h3><ul><li>为了保证block内部能够正常访问外部的变量，block有个变量捕获机制<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">变量类型        捕获到block内部         访问方式</span><br><span class="line">局部变量          auto    √            值传递</span><br><span class="line">               static    √            指针传递</span><br><span class="line">全局变量                  ×            直接访问</span><br></pre></td></tr></table></figure></li></ul><h3 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h3><blockquote><p>auto和static局部变量捕获</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">void test &#123;</span><br><span class="line">    auto int a = 10;</span><br><span class="line">    static int b = 10;</span><br><span class="line">    block = ^&#123;</span><br><span class="line">        NSLog(@&quot;age is %d, height is %d&quot;, a, b);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//prama mark: - 编译后的源码</span><br><span class="line"></span><br><span class="line">struct __test_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __test_block_desc_0* Desc;</span><br><span class="line">  int a;//值传递</span><br><span class="line">  int *b;//指针传递</span><br><span class="line">  __test_block_impl_0(void *fp, struct __test_block_desc_0 *desc, int _a, int *_b, int flags=0) : a(_a), b(_b) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __test_block_func_0(struct __test_block_impl_0 *__cself) &#123;</span><br><span class="line">  int a = __cself-&gt;a; // bound by copy，值传递</span><br><span class="line">  int *b = __cself-&gt;b; // bound by copy 指针传递</span><br><span class="line"></span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_2r__m13fp2x2n9dvlr8d68yry500000gn_T_main_fd2a14_mi_0, a, (*b));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">static struct __test_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __test_block_desc_0_DATA = &#123; 0, sizeof(struct __test_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    auto int a = 10;</span><br><span class="line">    static int b = 10;</span><br><span class="line">    block = ((void (*)())&amp;__test_block_impl_0((void *)__test_block_func_0, &amp;__test_block_desc_0_DATA, a, &amp;b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="block类型"><a href="#block类型" class="headerlink" title="block类型"></a>block类型</h3><ul><li>block有3种类型，可以通过调用class方法或者isa指针查看具体类型，最终都是继承自NSBlock类型<ul><li><strong>NSGlobalBlock</strong> （ _NSConcreteGlobalBlock ）（数据区）</li><li><strong>NSStackBlock</strong> （ _NSConcreteStackBlock ）（栈区）</li><li><strong>NSMallocBlock</strong> （ _NSConcreteMallocBlock ）（堆区）</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// Global：没有访问auto变量</span><br><span class="line">void (^block1)(void) = ^&#123;</span><br><span class="line">    NSLog(@&quot;block1---------&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">// Stack：访问了auto变量</span><br><span class="line">int age = 10;</span><br><span class="line">void (^block2)(void) = ^&#123;</span><br><span class="line">    NSLog(@&quot;block2---------%d&quot;, age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// NSMallocBlock（MRC环境下）</span><br><span class="line">//对stack类型的block进行copy操作，就会变成malloc类型的block</span><br><span class="line">int age = 10;</span><br><span class="line">block = [^&#123;</span><br><span class="line">    NSLog(@&quot;block---------%d&quot;, age);</span><br><span class="line">&#125; copy];</span><br><span class="line">[block release];</span><br></pre></td></tr></table></figure><blockquote><p> block父类层级结构，如下：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// __NSGlobalBlock__ : __NSGlobalBlock : NSBlock : NSObject</span><br><span class="line">void (^block)(void) = ^&#123;</span><br><span class="line">    NSLog(@&quot;Hello&quot;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@&quot;, [block class]);</span><br><span class="line">NSLog(@&quot;%@&quot;, [[block class] superclass]);</span><br><span class="line">NSLog(@&quot;%@&quot;, [[[block class] superclass] superclass]);</span><br><span class="line">NSLog(@&quot;%@&quot;, [[[[block class] superclass] superclass] superclass]);</span><br></pre></td></tr></table></figure><h3 id="block的copy"><a href="#block的copy" class="headerlink" title="block的copy"></a>block的copy</h3><ul><li>在ARC环境下，编译器会根据情况自动将栈上的block复制到堆上，比如以下情况<ul><li>block作为函数返回值时</li><li>将block赋值给__strong指针时</li><li>block作为Cocoa API中方法名含有usingBlock的方法参数时</li><li>block作为GCD API的方法参数时</li></ul></li><li>MRC下block属性的建议写法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (copy, nonatomic) void (^block)(void);</span><br></pre></td></tr></table></figure></li><li>ARC下block属性的建议写法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@property (strong, nonatomic) void (^block)(void);</span><br><span class="line">@property (copy, nonatomic) void (^block)(void);</span><br></pre></td></tr></table></figure></li></ul><h3 id="对象类型的auto变量"><a href="#对象类型的auto变量" class="headerlink" title="对象类型的auto变量"></a>对象类型的auto变量</h3><ul><li>当block内部访问了对象类型的auto变量时，如果block是在栈上，将不会对auto变量产生强引用</li><li>如果block被拷贝到堆上，会调用block内部的copy函数<ul><li>copy函数内部会调用<code>_Block_object_assign</code>函数</li><li><code>_Block_object_assign</code>函数会根据auto变量的修饰符（__strong、__weak、__unsafe_unretained）做出相应的操作，形成强引用（retain）或者弱引用</li></ul></li><li>如果block从堆上移除，会调用block内部的dispose函数<ul><li>dispose函数内部会调用<code>_Block_object_dispose</code>函数</li><li><code>_Block_object_dispose</code>会自动释放引用的auto变量（release）</li></ul></li></ul><blockquote><p>代码解析：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">typedef void (^Block)(void);</span><br><span class="line">Block block;</span><br><span class="line">&#123;</span><br><span class="line">    Person *person = [[Person alloc] init];</span><br><span class="line">    person.age = 10;</span><br><span class="line"></span><br><span class="line">    //__weak Person *weakPerson = person;</span><br><span class="line">    block = ^&#123;</span><br><span class="line">        NSLog(@&quot;---------%d&quot;, person.age);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//编译后的源代码 </span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  MJPerson *__strong person;//由于没有使用weakPerson,所以这里是strong</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, MJPerson *__strong _person, int flags=0) : person(_person) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  MJPerson *__strong person = __cself-&gt;person; // bound by copy</span><br><span class="line"></span><br><span class="line">                NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_2r__m13fp2x2n9dvlr8d68yry500000gn_T_main_c41e64_mi_0, ((int (*)(id, SEL))(void *)objc_msgSend)((id)person, sel_registerName(&quot;age&quot;)));</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;</span><br><span class="line">    _Block_object_assign((void*)&amp;dst-&gt;person,//对block进行一个引用计数的操作，外界是strong，retain就引用计数加1，外界是weak就是一个弱引用。</span><br><span class="line">    (void*)src-&gt;person, 3/*BLOCK_FIELD_IS_OBJECT*/);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;person, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class="line"></span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);// 将栈上的bock，复制到椎上</span><br><span class="line">  void (*dispose)(struct __main_block_impl_0*);//堆上的block被废弃时，进行dispose操作</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="weak问题解决"><a href="#weak问题解决" class="headerlink" title="__weak问题解决"></a>__weak问题解决</h3><ul><li>ARC环境下，默认对block进行一个copy操作</li><li>在使用clang转换OC为C++代码时，可能会遇到以下问题<ul><li>cannot create __weak reference in file using manual reference</li></ul></li><li>解决方案：支持ARC、指定运行时系统版本，比如<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基本认识&quot;&gt;&lt;a href=&quot;#基本认识&quot; class=&quot;headerlink&quot; title=&quot;基本认识&quot;&gt;&lt;/a&gt;基本认识&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;block本质上也是一个OC对象，它内部也有个isa指针&lt;/li&gt;
&lt;li&gt;block是封装了函数调用以及函数调</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="底层原理" scheme="http://www.hxtec.top/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    <category term="Block" scheme="http://www.hxtec.top/tags/Block/"/>
    
  </entry>
  
  <entry>
    <title>Category - 关联对象</title>
    <link href="http://www.hxtec.top/2022/09/17/Category-%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/"/>
    <id>http://www.hxtec.top/2022/09/17/Category-%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/</id>
    <published>2022-09-17T09:40:41.000Z</published>
    <updated>2022-09-17T09:42:46.420Z</updated>
    
    <content type="html"><![CDATA[<h4 id="关联对象"><a href="#关联对象" class="headerlink" title="关联对象"></a>关联对象</h4><ul><li>默认情况下，因为分类底层结构的限制，不能添加&#x3D;&#x3D;成员变量&#x3D;&#x3D;到分类中,但可以通过&#x3D;&#x3D;关联对象&#x3D;&#x3D;来间接实现</li><li>关联对象提供了以下API：<ul><li>添加关联对象<ul><li>void objc_setAssociatedObject(id object, const void * key,<br>                  id value, objc_AssociationPolicy policy)</li></ul></li><li>获得关联对象<ul><li>id objc_getAssociatedObject(id object, const void * key)</li></ul></li><li>移除所有的关联对象<ul><li>void objc_removeAssociatedObjects(id object)</li></ul></li></ul></li></ul><h4 id="key的常见用法"><a href="#key的常见用法" class="headerlink" title="key的常见用法"></a>key的常见用法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static void *MyKey = &amp;MyKey;</span><br><span class="line">objc_setAssociatedObject(obj, MyKey, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><br><span class="line">objc_getAssociatedObject(obj, MyKey)</span><br><span class="line"></span><br><span class="line">static char MyKey;</span><br><span class="line">objc_setAssociatedObject(obj, &amp;MyKey, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><br><span class="line">objc_getAssociatedObject(obj, &amp;MyKey)</span><br><span class="line"></span><br><span class="line">使用属性名作为key</span><br><span class="line">objc_setAssociatedObject(obj, @&quot;property&quot;, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">objc_getAssociatedObject(obj, @&quot;property&quot;);</span><br><span class="line"></span><br><span class="line">使用get方法的@selecor作为key</span><br><span class="line">objc_setAssociatedObject(obj, @selector(getter), value, OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><br><span class="line">objc_getAssociatedObject(obj, @selector(getter))</span><br></pre></td></tr></table></figure><ul><li>objc_AssociationPolicy，关联策略<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">objc_AssociationPolicy                    对应的修饰符</span><br><span class="line">OBJC_ASSOCIATION_ASSIGN                        assign</span><br><span class="line">OBJC_ASSOCIATION_RETAIN_NONATOMIC       strong, nonatomic</span><br><span class="line">OBJC_ASSOCIATION_COPY_NONATOMIC         copy, nonatomic</span><br><span class="line">OBJC_ASSOCIATION_RETAIN                    strong, atomic</span><br><span class="line">OBJC_ASSOCIATION_COPY                    copy, atomic</span><br></pre></td></tr></table></figure></li></ul><h4 id="关联对象的原理"><a href="#关联对象的原理" class="headerlink" title="关联对象的原理"></a>关联对象的原理</h4><ul><li>实现关联对象技术的核心对象有<ul><li>AssociationsManager</li><li>AssociationsHashMap</li><li>ObjectAssociationMap</li><li>ObjcAssociation</li></ul></li></ul><h5 id="objc4源码：objc-references-mm"><a href="#objc4源码：objc-references-mm" class="headerlink" title="objc4源码：objc-references.mm"></a>objc4源码：objc-references.mm</h5><blockquote><p>AssociationsManager</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class AssociationsManager &#123;</span><br><span class="line">    // associative references: object pointer -&gt; PtrPtrHashMap.</span><br><span class="line">    static AssociationsHashMap *_map;</span><br><span class="line">public:</span><br><span class="line">    AssociationsManager()   &#123; AssociationsManagerLock.lock(); &#125;</span><br><span class="line">    ~AssociationsManager()  &#123; AssociationsManagerLock.unlock(); &#125;</span><br><span class="line">    </span><br><span class="line">    // </span><br><span class="line">    AssociationsHashMap &amp;associations() &#123;</span><br><span class="line">        if (_map == NULL)</span><br><span class="line">            _map = new AssociationsHashMap();</span><br><span class="line">        return *_map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>AssociationsHashMap</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class AssociationsHashMap : public unordered_map&lt;disguised_ptr_t, ObjectAssociationMap *, DisguisedPointerHash, DisguisedPointerEqual, AssociationsHashMapAllocator&gt; &#123;</span><br><span class="line">public:</span><br><span class="line">    void *operator new(size_t n) &#123; return ::malloc(n); &#125;</span><br><span class="line">    void operator delete(void *ptr) &#123; ::free(ptr); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>ObjectAssociationMap</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class ObjectAssociationMap : public std::map&lt;void *, ObjcAssociation, ObjectPointerLess, ObjectAssociationMapAllocator&gt; &#123;</span><br><span class="line">public:</span><br><span class="line">    void *operator new(size_t n) &#123; return ::malloc(n); &#125;</span><br><span class="line">    void operator delete(void *ptr) &#123; ::free(ptr); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>ObjcAssociation</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class ObjcAssociation &#123;</span><br><span class="line">    </span><br><span class="line">    uintptr_t _policy;</span><br><span class="line">    id _value;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    ObjcAssociation(uintptr_t policy, id value) : _policy(policy), _value(value) &#123;&#125;</span><br><span class="line">    ObjcAssociation() : _policy(0), _value(nil) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    uintptr_t policy() const &#123; return _policy; &#125;</span><br><span class="line">    id value() const &#123; return _value; &#125;</span><br><span class="line">    </span><br><span class="line">    bool hasValue() &#123; return _value != nil; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><strong>notes:</strong></p></blockquote><ul><li>关联对象并不是存储在被关联对象本身内存中</li><li>关联对象存储在全局的统一的一个AssociationsManager中</li><li>设置关联对象为nil，就相当于是移除关联对象</li><li>即为以下的关系：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">AssociationsManager</span><br><span class="line">AssociationsHashMap *_map;</span><br><span class="line"></span><br><span class="line">AssociationsHashMap</span><br><span class="line">disguised_ptr_t    ObjectAssociationMap</span><br><span class="line">disguised_ptr_t    ObjectAssociationMap</span><br><span class="line">...    ...</span><br><span class="line"></span><br><span class="line">AssociationsMap</span><br><span class="line">void *    ObjectAssociation</span><br><span class="line">void *    ObjectAssociation</span><br><span class="line">...    ...</span><br><span class="line"></span><br><span class="line">ObjectAssociation</span><br><span class="line">uintptr_t _policy;</span><br><span class="line">id _value;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;关联对象&quot;&gt;&lt;a href=&quot;#关联对象&quot; class=&quot;headerlink&quot; title=&quot;关联对象&quot;&gt;&lt;/a&gt;关联对象&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;默认情况下，因为分类底层结构的限制，不能添加&amp;#x3D;&amp;#x3D;成员变量&amp;#x3D;&amp;#x3D;到分类中,但</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="底层原理" scheme="http://www.hxtec.top/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    <category term="Category" scheme="http://www.hxtec.top/tags/Category/"/>
    
  </entry>
  
  <entry>
    <title>Category - initialize</title>
    <link href="http://www.hxtec.top/2022/09/17/Category-initialize/"/>
    <id>http://www.hxtec.top/2022/09/17/Category-initialize/</id>
    <published>2022-09-17T09:38:43.000Z</published>
    <updated>2022-09-17T10:50:52.477Z</updated>
    
    <content type="html"><![CDATA[<h2 id="initialized"><a href="#initialized" class="headerlink" title="initialized"></a>initialized</h2><ul><li>+initialized方法会在类第一次接收到消息时调用 </li><li>调用顺序<ul><li>先调用父类的+initialize，再调用子类的+initialize</li><li>先初始化父类，再初始化子类，每个类只会初始化1次</li></ul></li><li>+initialize和+load的很大区别是，+initialize是通过objc_msgSend进行调用的，所以有以下特点<ul><li>如果子类没有实现+initialize，会调用父类的+initialize（所以父类的+initialize可能会被调用多次）</li><li>如果分类实现了+initialize，就覆盖类本身的+initialize调用</li></ul></li></ul><h4 id="objc4源码解读"><a href="#objc4源码解读" class="headerlink" title="objc4源码解读"></a>objc4源码解读</h4><blockquote><ul><li>objc-msg-arm64.s，汇编级别的源码<ul><li>objc_msgSend，消息发送汇编源码</li></ul></li><li>objc-runtime-new.mm<ul><li>class_getInstanceMethod</li><li>lookUpImpOrNil</li><li>lookUpImpOrForward</li><li>_class_initialize</li><li>callInitialize</li><li>objc_msgSend(cls, SEL_initialize)</li></ul></li></ul></blockquote><h4 id="源码分析，objc-runtime-new-mm文件"><a href="#源码分析，objc-runtime-new-mm文件" class="headerlink" title="源码分析，objc-runtime-new.mm文件"></a>源码分析，objc-runtime-new.mm文件</h4><blockquote><p>class_getInstanceMethod</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/***********************************************************************</span><br><span class="line">* class_getInstanceMethod.  Return the instance method for the</span><br><span class="line">* specified class and selector.</span><br><span class="line">**********************************************************************/</span><br><span class="line">Method class_getInstanceMethod(Class cls, SEL sel)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cls  ||  !sel) return nil;</span><br><span class="line"></span><br><span class="line">    // This deliberately avoids +initialize because it historically did so.</span><br><span class="line"></span><br><span class="line">    // This implementation is a bit weird because it&#x27;s the only place that </span><br><span class="line">    // wants a Method instead of an IMP.</span><br><span class="line"></span><br><span class="line">#warning fixme build and search caches</span><br><span class="line">        </span><br><span class="line">    // Search method lists, try method resolver, etc.</span><br><span class="line">    // 查找方法</span><br><span class="line">    lookUpImpOrNil(cls, sel, nil, </span><br><span class="line">                   NO/*initialize*/, NO/*cache*/, YES/*resolver*/);</span><br><span class="line"></span><br><span class="line">#warning fixme build and search caches</span><br><span class="line"></span><br><span class="line">    return _class_getMethod(cls, sel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>lookUpImpOrNil</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">* lookUpImpOrNil.</span><br><span class="line">* Like lookUpImpOrForward, but returns nil instead of _objc_msgForward_impcache</span><br><span class="line">**********************************************************************/</span><br><span class="line">IMP lookUpImpOrNil(Class cls, SEL sel, id inst, </span><br><span class="line">                   bool initialize, bool cache, bool resolver)</span><br><span class="line">&#123;</span><br><span class="line">    IMP imp = lookUpImpOrForward(cls, sel, inst, initialize, cache, resolver);</span><br><span class="line">    if (imp == _objc_msgForward_impcache) return nil;</span><br><span class="line">    else return imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>lookUpImpOrForward</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">IMP lookUpImpOrForward(Class cls, SEL sel, id inst, </span><br><span class="line">                       bool initialize, bool cache, bool resolver)</span><br><span class="line">&#123;</span><br><span class="line">    IMP imp = nil;</span><br><span class="line">    bool triedResolver = NO;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line"></span><br><span class="line">    // 省去代码...   </span><br><span class="line"></span><br><span class="line">    // 判断是否初始化过类，没有就进行初始化</span><br><span class="line">    if (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</span><br><span class="line">        runtimeLock.unlockRead();</span><br><span class="line">        </span><br><span class="line">        // 初始化操作</span><br><span class="line">        _class_initialize (_class_getNonMetaClass(cls, inst));</span><br><span class="line">        </span><br><span class="line">        runtimeLock.read();</span><br><span class="line">        // If sel == initialize, _class_initialize will send +initialize and </span><br><span class="line">        // then the messenger will send +initialize again after this </span><br><span class="line">        // procedure finishes. Of course, if this is not being called </span><br><span class="line">        // from the messenger then it won&#x27;t happen. 2778172</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>_class_initialize</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">* class_initialize.  Send the &#x27;+initialize&#x27; message on demand to any</span><br><span class="line">* uninitialized class. Force initialization of superclasses first.</span><br><span class="line">**********************************************************************/</span><br><span class="line">void _class_initialize(Class cls)</span><br><span class="line">&#123;    </span><br><span class="line">    // 省去代码...   </span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            // 调用自己的初始化方法</span><br><span class="line">            callInitialize(cls);</span><br><span class="line"></span><br><span class="line">            if (PrintInitializing) &#123;</span><br><span class="line">                _objc_inform(&quot;INITIALIZE: thread %p: finished +[%s initialize]&quot;,</span><br><span class="line">                             pthread_self(), cls-&gt;nameForLogging());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    // 省去代码...   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>callInitialize</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void callInitialize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    // 消息发送机制</span><br><span class="line">    ((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);</span><br><span class="line">    asm(&quot;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高频面试"><a href="#高频面试" class="headerlink" title="高频面试"></a>高频面试</h2><ul><li><p>Category中有load方法吗？load方法是什么时候调用的？load 方法能继承吗？</p><ul><li>有load方法</li><li>load方法在runtime加载类、分类的时候调用</li><li>load方法可以继承，但是一般情况下不会主动去调用load方法，都是让系统自动调用</li></ul></li><li><p>load、initialize方法的区别什么？它们在category中的调用的顺序？以及出现继承时他们之间的调用过程？</p><ul><li>分别在两个笔记里面顶部体现</li></ul></li><li><p>Category能否添加成员变量？如果可以，如何给Category添加成员变量？</p><ul><li>不能直接给Category添加成员变量，但是可以间接实现Category有成员变量的效果</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;initialized&quot;&gt;&lt;a href=&quot;#initialized&quot; class=&quot;headerlink&quot; title=&quot;initialized&quot;&gt;&lt;/a&gt;initialized&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;+initialized方法会在类第一次接收到消息时调用</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="底层原理" scheme="http://www.hxtec.top/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    <category term="Category" scheme="http://www.hxtec.top/tags/Category/"/>
    
  </entry>
  
  <entry>
    <title>Category - load</title>
    <link href="http://www.hxtec.top/2022/09/17/Category-load/"/>
    <id>http://www.hxtec.top/2022/09/17/Category-load/</id>
    <published>2022-09-17T09:35:26.000Z</published>
    <updated>2022-09-17T10:51:16.922Z</updated>
    
    <content type="html"><![CDATA[<h2 id="load"><a href="#load" class="headerlink" title="+load"></a>+load</h2><ul><li>+load方法会在runtime加载类、分类时调用</li><li>每个类、分类的+load，在程序运行过程中只调用一次</li><li>调用顺序<ol><li>先调用类的+load<ul><li>按照编译先后顺序调用（先编译，先调用）</li><li>调用子类+load之前会先调用父类的+load</li></ul></li><li>再调用分类的+load<ul><li>按照编译先后顺序调用（先编译，先调用）</li></ul></li></ol></li></ul><h4 id="objc4源码解读：objc-os-mm"><a href="#objc4源码解读：objc-os-mm" class="headerlink" title="objc4源码解读：objc-os.mm"></a>objc4源码解读：objc-os.mm</h4><blockquote><ul><li>_objc_init</li><li>load_images</li><li>prepare_load_methods<ul><li>schedule_class_load</li><li>add_class_to_loadable_list</li><li>add_category_to_loadable_list</li></ul></li><li>call_load_methods<ul><li>call_class_loads</li><li>call_category_loads</li></ul></li></ul></blockquote><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><blockquote><p> _objc_init</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">* _objc_init</span><br><span class="line">* Bootstrap initialization. Registers our image notifier with dyld.</span><br><span class="line">* Called by libSystem BEFORE library initialization time</span><br><span class="line">**********************************************************************/</span><br><span class="line"></span><br><span class="line">void _objc_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    static bool initialized = false;</span><br><span class="line">    if (initialized) return;</span><br><span class="line">    initialized = true;</span><br><span class="line">    </span><br><span class="line">    // fixme defer initialization until an objc-using image is found?</span><br><span class="line">    environ_init();</span><br><span class="line">    tls_init();</span><br><span class="line">    static_init();</span><br><span class="line">    lock_init();</span><br><span class="line">    exception_init();</span><br><span class="line"></span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>load_images，在objc-runtime-new.mm文件中</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">* load_images</span><br><span class="line">* Process +load in the given images which are being mapped in by dyld.</span><br><span class="line">*</span><br><span class="line">* Locking: write-locks runtimeLock and loadMethodLock</span><br><span class="line">**********************************************************************/</span><br><span class="line">extern bool hasLoadMethods(const headerType *mhdr);</span><br><span class="line">extern void prepare_load_methods(const headerType *mhdr);</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">load_images(const char *path __unused, const struct mach_header *mh)</span><br><span class="line">&#123;</span><br><span class="line">    // Return without taking locks if there are no +load methods here.</span><br><span class="line">    if (!hasLoadMethods((const headerType *)mh)) return;</span><br><span class="line"></span><br><span class="line">    recursive_mutex_locker_t lock(loadMethodLock);</span><br><span class="line"></span><br><span class="line">    // Discover load methods</span><br><span class="line">    &#123;</span><br><span class="line">        rwlock_writer_t lock2(runtimeLock);</span><br><span class="line">        </span><br><span class="line">        //准备加载方法</span><br><span class="line">        prepare_load_methods((const headerType *)mh);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Call +load methods (without runtimeLock - re-entrant)</span><br><span class="line">    // 加载方法</span><br><span class="line">    call_load_methods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>prepare_load_methods</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void prepare_load_methods(const headerType *mhdr)</span><br><span class="line">&#123;</span><br><span class="line">    size_t count, i;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line"></span><br><span class="line">    classref_t *classlist = </span><br><span class="line">        _getObjc2NonlazyClassList(mhdr, &amp;count);</span><br><span class="line">    for (i = 0; i &lt; count; i++) &#123;</span><br><span class="line">    </span><br><span class="line">        // 安排/预定类方法</span><br><span class="line">        schedule_class_load(remapClass(classlist[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    category_t **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);</span><br><span class="line">    for (i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        category_t *cat = categorylist[i];</span><br><span class="line">        Class cls = remapClass(cat-&gt;cls);</span><br><span class="line">        if (!cls) continue;  // category for ignored weak-linked class</span><br><span class="line">        realizeClass(cls);</span><br><span class="line">        assert(cls-&gt;ISA()-&gt;isRealized());</span><br><span class="line">        </span><br><span class="line">        // 添加分类到加载列表中</span><br><span class="line">        add_category_to_loadable_list(cat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>schedule_class_load</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">* prepare_load_methods</span><br><span class="line">* Schedule +load for classes in this image, any un-+load-ed </span><br><span class="line">* superclasses in other images, and any categories in this image.</span><br><span class="line">**********************************************************************/</span><br><span class="line">// Recursively schedule +load for cls and any un-+load-ed superclasses.</span><br><span class="line">// cls must already be connected.</span><br><span class="line">static void schedule_class_load(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cls) return;</span><br><span class="line">    assert(cls-&gt;isRealized());  // _read_images should realize</span><br><span class="line"></span><br><span class="line">    if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return;</span><br><span class="line"></span><br><span class="line">    // Ensure superclass-first ordering</span><br><span class="line">    schedule_class_load(cls-&gt;superclass);</span><br><span class="line"></span><br><span class="line">    // 添加类到加载列表中</span><br><span class="line">    add_class_to_loadable_list(cls);</span><br><span class="line">    cls-&gt;setInfo(RW_LOADED); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>add_class_to_loadable_list</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">* add_class_to_loadable_list</span><br><span class="line">* Class cls has just become connected. Schedule it for +load if</span><br><span class="line">* it implements a +load method.</span><br><span class="line">**********************************************************************/</span><br><span class="line">void add_class_to_loadable_list(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    IMP method;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    method = cls-&gt;getLoadMethod();</span><br><span class="line">    if (!method) return;  // Don&#x27;t bother if cls has no +load method</span><br><span class="line">    </span><br><span class="line">    if (PrintLoading) &#123;</span><br><span class="line">        _objc_inform(&quot;LOAD: class &#x27;%s&#x27; scheduled for +load&quot;, </span><br><span class="line">                     cls-&gt;nameForLogging());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (loadable_classes_used == loadable_classes_allocated) &#123;</span><br><span class="line">        loadable_classes_allocated = loadable_classes_allocated*2 + 16;</span><br><span class="line">        loadable_classes = (struct loadable_class *)</span><br><span class="line">            realloc(loadable_classes,</span><br><span class="line">                              loadable_classes_allocated *</span><br><span class="line">                              sizeof(struct loadable_class));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    loadable_classes[loadable_classes_used].cls = cls;</span><br><span class="line">    loadable_classes[loadable_classes_used].method = method;</span><br><span class="line">    loadable_classes_used++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>add_category_to_loadable_list</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">* add_category_to_loadable_list</span><br><span class="line">* Category cat&#x27;s parent class exists and the category has been attached</span><br><span class="line">* to its class. Schedule this category for +load after its parent class</span><br><span class="line">* becomes connected and has its own +load method called.</span><br><span class="line">**********************************************************************/</span><br><span class="line">void add_category_to_loadable_list(Category cat)</span><br><span class="line">&#123;</span><br><span class="line">    IMP method;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    method = _category_getLoadMethod(cat);</span><br><span class="line"></span><br><span class="line">    // Don&#x27;t bother if cat has no +load method</span><br><span class="line">    if (!method) return;</span><br><span class="line"></span><br><span class="line">    if (PrintLoading) &#123;</span><br><span class="line">        _objc_inform(&quot;LOAD: category &#x27;%s(%s)&#x27; scheduled for +load&quot;, </span><br><span class="line">                     _category_getClassName(cat), _category_getName(cat));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (loadable_categories_used == loadable_categories_allocated) &#123;</span><br><span class="line">        loadable_categories_allocated = loadable_categories_allocated*2 + 16;</span><br><span class="line">        loadable_categories = (struct loadable_category *)</span><br><span class="line">            realloc(loadable_categories,</span><br><span class="line">                              loadable_categories_allocated *</span><br><span class="line">                              sizeof(struct loadable_category));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    loadable_categories[loadable_categories_used].cat = cat;</span><br><span class="line">    loadable_categories[loadable_categories_used].method = method;</span><br><span class="line">    loadable_categories_used++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>call_load_methods</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">void call_load_methods(void)</span><br><span class="line">&#123;</span><br><span class="line">    static bool loading = NO;</span><br><span class="line">    bool more_categories;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    // Re-entrant calls do nothing; the outermost call will finish the job.</span><br><span class="line">    if (loading) return;</span><br><span class="line">    loading = YES;</span><br><span class="line"></span><br><span class="line">    void *pool = objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line">        // 1. Repeatedly call class +loads until there aren&#x27;t any more</span><br><span class="line">        while (loadable_classes_used &gt; 0) &#123;</span><br><span class="line">        </span><br><span class="line">            //调用类load方法</span><br><span class="line">            call_class_loads();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 2. Call category +loads ONCE</span><br><span class="line"></span><br><span class="line">        // 调用分类的load方法</span><br><span class="line">        more_categories = call_category_loads();</span><br><span class="line"></span><br><span class="line">        // 3. Run more +loads if there are classes OR more untried categories</span><br><span class="line">    &#125; while (loadable_classes_used &gt; 0  ||  more_categories);</span><br><span class="line"></span><br><span class="line">    objc_autoreleasePoolPop(pool);</span><br><span class="line"></span><br><span class="line">    loading = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>call_class_loads</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">* call_class_loads</span><br><span class="line">* Call all pending class +load methods.</span><br><span class="line">* If new classes become loadable, +load is NOT called for them.</span><br><span class="line">*</span><br><span class="line">* Called only by call_load_methods().</span><br><span class="line">**********************************************************************/</span><br><span class="line">static void call_class_loads(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    </span><br><span class="line">    // Detach current loadable list.</span><br><span class="line">    struct loadable_class *classes = loadable_classes;</span><br><span class="line">    int used = loadable_classes_used;</span><br><span class="line">    loadable_classes = nil;</span><br><span class="line">    loadable_classes_allocated = 0;</span><br><span class="line">    loadable_classes_used = 0;</span><br><span class="line">    </span><br><span class="line">    // Call all +loads for the detached list.</span><br><span class="line">    for (i = 0; i &lt; used; i++) &#123;</span><br><span class="line">        Class cls = classes[i].cls;</span><br><span class="line">        load_method_t load_method = (load_method_t)classes[i].method;</span><br><span class="line">        if (!cls) continue; </span><br><span class="line"></span><br><span class="line">        if (PrintLoading) &#123;</span><br><span class="line">            _objc_inform(&quot;LOAD: +[%s load]\n&quot;, cls-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line">        (*load_method)(cls, SEL_load);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Destroy the detached list.</span><br><span class="line">    if (classes) free(classes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>call_category_loads</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">* call_category_loads</span><br><span class="line">* Call some pending category +load methods.</span><br><span class="line">* The parent class of the +load-implementing categories has all of </span><br><span class="line">*   its categories attached, in case some are lazily waiting for +initalize.</span><br><span class="line">* Don&#x27;t call +load unless the parent class is connected.</span><br><span class="line">* If new categories become loadable, +load is NOT called, and they </span><br><span class="line">*   are added to the end of the loadable list, and we return TRUE.</span><br><span class="line">* Return FALSE if no new categories became loadable.</span><br><span class="line">*</span><br><span class="line">* Called only by call_load_methods().</span><br><span class="line">**********************************************************************/</span><br><span class="line">static bool call_category_loads(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i, shift;</span><br><span class="line">    bool new_categories_added = NO;</span><br><span class="line">    </span><br><span class="line">    // Detach current loadable list.</span><br><span class="line">    struct loadable_category *cats = loadable_categories;</span><br><span class="line">    int used = loadable_categories_used;</span><br><span class="line">    int allocated = loadable_categories_allocated;</span><br><span class="line">    loadable_categories = nil;</span><br><span class="line">    loadable_categories_allocated = 0;</span><br><span class="line">    loadable_categories_used = 0;</span><br><span class="line"></span><br><span class="line">    // Call all +loads for the detached list.</span><br><span class="line">    for (i = 0; i &lt; used; i++) &#123;</span><br><span class="line">        Category cat = cats[i].cat;</span><br><span class="line">        load_method_t load_method = (load_method_t)cats[i].method;</span><br><span class="line">        Class cls;</span><br><span class="line">        if (!cat) continue;</span><br><span class="line"></span><br><span class="line">        cls = _category_getClass(cat);</span><br><span class="line">        if (cls  &amp;&amp;  cls-&gt;isLoadable()) &#123;</span><br><span class="line">            if (PrintLoading) &#123;</span><br><span class="line">                _objc_inform(&quot;LOAD: +[%s(%s) load]\n&quot;, </span><br><span class="line">                             cls-&gt;nameForLogging(), </span><br><span class="line">                             _category_getName(cat));</span><br><span class="line">            &#125;</span><br><span class="line">            (*load_method)(cls, SEL_load);</span><br><span class="line">            cats[i].cat = nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Compact detached list (order-preserving)</span><br><span class="line">    shift = 0;</span><br><span class="line">    for (i = 0; i &lt; used; i++) &#123;</span><br><span class="line">        if (cats[i].cat) &#123;</span><br><span class="line">            cats[i-shift] = cats[i];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            shift++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    used -= shift;</span><br><span class="line"></span><br><span class="line">    // Copy any new +load candidates from the new list to the detached list.</span><br><span class="line">    new_categories_added = (loadable_categories_used &gt; 0);</span><br><span class="line">    for (i = 0; i &lt; loadable_categories_used; i++) &#123;</span><br><span class="line">        if (used == allocated) &#123;</span><br><span class="line">            allocated = allocated*2 + 16;</span><br><span class="line">            cats = (struct loadable_category *)</span><br><span class="line">                realloc(cats, allocated *</span><br><span class="line">                                  sizeof(struct loadable_category));</span><br><span class="line">        &#125;</span><br><span class="line">        cats[used++] = loadable_categories[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Destroy the new list.</span><br><span class="line">    if (loadable_categories) free(loadable_categories);</span><br><span class="line"></span><br><span class="line">    // Reattach the (now augmented) detached list. </span><br><span class="line">    // But if there&#x27;s nothing left to load, destroy the list.</span><br><span class="line">    if (used) &#123;</span><br><span class="line">        loadable_categories = cats;</span><br><span class="line">        loadable_categories_used = used;</span><br><span class="line">        loadable_categories_allocated = allocated;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (cats) free(cats);</span><br><span class="line">        loadable_categories = nil;</span><br><span class="line">        loadable_categories_used = 0;</span><br><span class="line">        loadable_categories_allocated = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (PrintLoading) &#123;</span><br><span class="line">        if (loadable_categories_used != 0) &#123;</span><br><span class="line">            _objc_inform(&quot;LOAD: %d categories still waiting for +load\n&quot;,</span><br><span class="line">                         loadable_categories_used);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return new_categories_added;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>note：<br>+load方法是根据方法地址直接调用，并不是经过objc_msgSend函数调用</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;load&quot;&gt;&lt;a href=&quot;#load&quot; class=&quot;headerlink&quot; title=&quot;+load&quot;&gt;&lt;/a&gt;+load&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;+load方法会在runtime加载类、分类时调用&lt;/li&gt;
&lt;li&gt;每个类、分类的+load，在程序运行过</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="底层原理" scheme="http://www.hxtec.top/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    <category term="Category" scheme="http://www.hxtec.top/tags/Category/"/>
    
  </entry>
  
  <entry>
    <title>Category - 底层结构</title>
    <link href="http://www.hxtec.top/2022/09/17/Category-%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84/"/>
    <id>http://www.hxtec.top/2022/09/17/Category-%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84/</id>
    <published>2022-09-17T09:31:45.000Z</published>
    <updated>2022-09-17T10:45:53.792Z</updated>
    
    <content type="html"><![CDATA[<h2 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct _category_t &#123;</span><br><span class="line">    const char *name;</span><br><span class="line">    struct _class_t *cls;</span><br><span class="line">    const struct _method_list_t *instance_methods;</span><br><span class="line">    const struct _method_list_t *class_methods;</span><br><span class="line">    const struct _protocol_list_t *protocols;</span><br><span class="line">    const struct _prop_list_t *properties;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="加载处理过程"><a href="#加载处理过程" class="headerlink" title="加载处理过程"></a>加载处理过程</h2><ul><li>通过Runtime某个类的所有Category数据</li><li>把所有Category的方法，属性，协议数据，合并到一个在数组中<ul><li>后面参与编译的Category数据，会在数组的前面</li></ul></li><li>将合并后的分类数据（方法，属性，协议），插入到类原来数据的前面</li><li>源码解读顺序<ul><li>objc-os.mm<ul><li>_objc_init</li><li>map_images</li><li>map_images_nolock</li></ul></li><li>objc-runtim-new.mm<ul><li>_read_images</li><li>remethodizeClass</li><li>attachCategories</li><li>attachLists<ul><li>realloc, memmove, memcpy</li></ul></li></ul></li></ul></li></ul><h3 id="部分源码分析"><a href="#部分源码分析" class="headerlink" title="部分源码分析"></a>部分源码分析</h3><h4 id="objc-os-mm文件"><a href="#objc-os-mm文件" class="headerlink" title="objc-os.mm文件"></a>objc-os.mm文件</h4><blockquote><p> _objc_init</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">***********************************************************************</span><br><span class="line">* _objc_init</span><br><span class="line">* Bootstrap initialization. Registers our image notifier with dyld.</span><br><span class="line">* Called by libSystem BEFORE library initialization time</span><br><span class="line">**********************************************************************/</span><br><span class="line"></span><br><span class="line">void _objc_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    static bool initialized = false;</span><br><span class="line">    if (initialized) return;</span><br><span class="line">    initialized = true;</span><br><span class="line">    </span><br><span class="line">    // fixme defer initialization until an objc-using image is found?</span><br><span class="line">    environ_init();</span><br><span class="line">    tls_init();</span><br><span class="line">    static_init();</span><br><span class="line">    lock_init();</span><br><span class="line">    exception_init();</span><br><span class="line"></span><br><span class="line">    // map_images</span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>map_images_nolock</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">* map_images_nolock</span><br><span class="line">* Process the given images which are being mapped in by dyld.</span><br><span class="line">* All class registration and fixups are performed (or deferred pending</span><br><span class="line">* discovery of missing superclasses etc), and +load methods are called.</span><br><span class="line">*</span><br><span class="line">* info[] is in bottom-up order i.e. libobjc will be earlier in the </span><br><span class="line">* array than any library that links to libobjc.</span><br><span class="line">*</span><br><span class="line">* Locking: loadMethodLock(old) or runtimeLock(new) acquired by map_images.</span><br><span class="line">**********************************************************************/</span><br><span class="line">#if __OBJC2__</span><br><span class="line">#include &quot;objc-file.h&quot;</span><br><span class="line">#else</span><br><span class="line">#include &quot;objc-file-old.h&quot;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">void </span><br><span class="line">map_images_nolock(unsigned mhCount, const char * const mhPaths[],</span><br><span class="line">                  const struct mach_header * const mhdrs[])</span><br><span class="line">&#123;</span><br><span class="line">// 省去其他代码...</span><br><span class="line"></span><br><span class="line">    if (hCount &gt; 0) &#123;</span><br><span class="line">    </span><br><span class="line">        //_read_images</span><br><span class="line">        _read_images(hList, hCount, totalClasses, unoptimizedTotalClasses);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 省去其他代码...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="objc-runtime-new-mm文件"><a href="#objc-runtime-new-mm文件" class="headerlink" title="objc-runtime-new.mm文件"></a>objc-runtime-new.mm文件</h4><blockquote><p>_read_images</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">* _read_images</span><br><span class="line">* Perform initial processing of the headers in the linked </span><br><span class="line">* list beginning with headerList. </span><br><span class="line">*</span><br><span class="line">* Called by: map_images_nolock</span><br><span class="line">*</span><br><span class="line">* Locking: runtimeLock acquired by map_images</span><br><span class="line">**********************************************************************/</span><br><span class="line">void _read_images(header_info **hList, uint32_t hCount, int totalClasses, int unoptimizedTotalClasses)</span><br><span class="line">&#123;</span><br><span class="line">// 省去其他代码...</span><br><span class="line"></span><br><span class="line">    // Process this category. </span><br><span class="line">    // First, register the category with its target class. </span><br><span class="line">    // Then, rebuild the class&#x27;s method lists (etc) if </span><br><span class="line">    // the class is realized. </span><br><span class="line">    bool classExists = NO;</span><br><span class="line">    if (cat-&gt;instanceMethods ||  cat-&gt;protocols  </span><br><span class="line">        ||  cat-&gt;instanceProperties) </span><br><span class="line">    &#123;</span><br><span class="line">        addUnattachedCategoryForClass(cat, cls, hi);</span><br><span class="line">        if (cls-&gt;isRealized()) &#123;</span><br><span class="line">        </span><br><span class="line">            //重新组织类的方法</span><br><span class="line">            remethodizeClass(cls);</span><br><span class="line">            classExists = YES;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        if (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(&quot;CLASS: found category -%s(%s) %s&quot;, </span><br><span class="line">                         cls-&gt;nameForLogging(), cat-&gt;name, </span><br><span class="line">                         classExists ? &quot;on existing class&quot; : &quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (cat-&gt;classMethods  ||  cat-&gt;protocols  </span><br><span class="line">        ||  (hasClassProperties &amp;&amp; cat-&gt;_classProperties)) </span><br><span class="line">    &#123;</span><br><span class="line">        addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi);</span><br><span class="line">        if (cls-&gt;ISA()-&gt;isRealized()) &#123;</span><br><span class="line">        </span><br><span class="line">            //重新组织类的方法</span><br><span class="line">            remethodizeClass(cls-&gt;ISA());</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        if (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(&quot;CLASS: found category +%s(%s)&quot;, </span><br><span class="line">                         cls-&gt;nameForLogging(), cat-&gt;name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">// 省去其他代码...</span><br></pre></td></tr></table></figure><blockquote><p>remethodizeClass</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">* remethodizeClass</span><br><span class="line">* Attach outstanding categories to an existing class.</span><br><span class="line">* Fixes up cls&#x27;s method list, protocol list, and property list.</span><br><span class="line">* Updates method caches for cls and its subclasses.</span><br><span class="line">* Locking: runtimeLock must be held by the caller</span><br><span class="line">**********************************************************************/</span><br><span class="line">static void remethodizeClass(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    category_list *cats;</span><br><span class="line">    bool isMeta;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line"></span><br><span class="line">    isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    // Re-methodizing: check for more categories</span><br><span class="line">    if ((cats = unattachedCategoriesForClass(cls, false/*not realizing*/))) &#123;</span><br><span class="line">        if (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(&quot;CLASS: attaching categories to class &#x27;%s&#x27; %s&quot;, </span><br><span class="line">                         cls-&gt;nameForLogging(), isMeta ? &quot;(meta)&quot; : &quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // </span><br><span class="line">        attachCategories(cls, cats, true /*flush caches*/);        </span><br><span class="line">        free(cats);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>attachCategories</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">attachCategories(Class cls, category_list *cats, bool flush_caches)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cats) return;</span><br><span class="line">    if (PrintReplacedMethods) printReplacements(cls, cats);</span><br><span class="line"></span><br><span class="line">    bool isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    // fixme rearrange to remove these intermediate allocations</span><br><span class="line">    // 方法数组，二维数组</span><br><span class="line">    /*</span><br><span class="line">    [</span><br><span class="line">        [method_t, method_t],</span><br><span class="line">        [method_t, method_t]</span><br><span class="line">    ]</span><br><span class="line">     */</span><br><span class="line">    method_list_t **mlists = (method_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*mlists));</span><br><span class="line">    // 属性数组</span><br><span class="line">    property_list_t **proplists = (property_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*proplists));</span><br><span class="line">    // 协议数组</span><br><span class="line">    protocol_list_t **protolists = (protocol_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*protolists));</span><br><span class="line"></span><br><span class="line">    // Count backwards through cats to get newest categories first</span><br><span class="line">    int mcount = 0;</span><br><span class="line">    int propcount = 0;</span><br><span class="line">    int protocount = 0;</span><br><span class="line">    int i = cats-&gt;count;</span><br><span class="line">    bool fromBundle = NO;</span><br><span class="line">    while (i--) &#123;</span><br><span class="line">        //取出某个分类</span><br><span class="line">        auto&amp; entry = cats-&gt;list[i];</span><br><span class="line"></span><br><span class="line">        // 取出分类中的对象/类方法</span><br><span class="line">        method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);</span><br><span class="line">        if (mlist) &#123;</span><br><span class="line">            mlists[mcount++] = mlist;</span><br><span class="line">            fromBundle |= entry.hi-&gt;isBundle();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        property_list_t *proplist = </span><br><span class="line">            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</span><br><span class="line">        if (proplist) &#123;</span><br><span class="line">            proplists[propcount++] = proplist;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protocol_list_t *protolist = entry.cat-&gt;protocols;</span><br><span class="line">        if (protolist) &#123;</span><br><span class="line">            protolists[protocount++] = protolist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    auto rw = cls-&gt;data();</span><br><span class="line"></span><br><span class="line">    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</span><br><span class="line">    // 将所有分类的对象/类方法，附加到类对象的方法列表中</span><br><span class="line">    rw-&gt;methods.attachLists(mlists, mcount);</span><br><span class="line">    free(mlists);</span><br><span class="line">    if (flush_caches  &amp;&amp;  mcount &gt; 0) flushCaches(cls);</span><br><span class="line">    </span><br><span class="line">    // 将所有分类的属性，附加到类对象的属性列表中</span><br><span class="line">    rw-&gt;properties.attachLists(proplists, propcount);</span><br><span class="line">    free(proplists);</span><br><span class="line">    </span><br><span class="line">    // 将所有分类的协议，附加到类对象的协议列表中</span><br><span class="line">    rw-&gt;protocols.attachLists(protolists, protocount);</span><br><span class="line">    free(protolists);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="objc-runtime-new-h"><a href="#objc-runtime-new-h" class="headerlink" title="objc-runtime-new.h"></a>objc-runtime-new.h</h4><blockquote><p>attachLists</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">void attachLists(List* const * addedLists, uint32_t addedCount) &#123;</span><br><span class="line">    if (addedCount == 0) return;</span><br><span class="line"></span><br><span class="line">    if (hasArray()) &#123;</span><br><span class="line">        // many lists -&gt; many lists</span><br><span class="line">        uint32_t oldCount = array()-&gt;count;</span><br><span class="line">        uint32_t newCount = oldCount + addedCount;</span><br><span class="line">        setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));</span><br><span class="line">        array()-&gt;count = newCount;</span><br><span class="line">        </span><br><span class="line">        //先进行内存挪动，array()-&gt;lists，原来的方法列表</span><br><span class="line">        memmove(array()-&gt;lists + addedCount, </span><br><span class="line">                         array()-&gt;lists, </span><br><span class="line">                         oldCount * sizeof(array()-&gt;lists[0]));</span><br><span class="line">        </span><br><span class="line">        //再进行，copy操作到挪动后腾出的位置，addedLists,原有分类的方法列表</span><br><span class="line">        memcpy(array()-&gt;lists, </span><br><span class="line">                        addedLists, </span><br><span class="line">                        addedCount * sizeof(array()-&gt;lists[0]));</span><br><span class="line">    &#125;</span><br><span class="line">    else if (!list  &amp;&amp;  addedCount == 1) &#123;</span><br><span class="line">        // 0 lists -&gt; 1 list</span><br><span class="line">        list = addedLists[0];</span><br><span class="line">    &#125; </span><br><span class="line">    else &#123;</span><br><span class="line">        // 1 list -&gt; many lists</span><br><span class="line">        List* oldList = list;</span><br><span class="line">        uint32_t oldCount = oldList ? 1 : 0;</span><br><span class="line">        uint32_t newCount = oldCount + addedCount;</span><br><span class="line">        setArray((array_t *)malloc(array_t::byteSize(newCount)));</span><br><span class="line">        array()-&gt;count = newCount;</span><br><span class="line">        if (oldList) array()-&gt;lists[addedCount] = oldList;</span><br><span class="line">        memcpy(array()-&gt;lists, addedLists, </span><br><span class="line">               addedCount * sizeof(array()-&gt;lists[0]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高频试题"><a href="#高频试题" class="headerlink" title="高频试题"></a>高频试题</h2><ul><li>Category的使用场景？<ul><li>为原有类添加对象方法和类方法</li><li>拆分模块，将原来一个大的模块，拆分成多个小模块，方便维护和管理</li><li>添加关联对象</li></ul></li><li>Cateory的实现原理<ul><li>Category编译之后的底层结构是 struct category_t，里面存储着分类 的对象方法，属性，协议信息</li><li>在程序运行的时候，runtime会将Category的数据，合并到类信息中（类对象，元类对象）</li></ul></li><li>Cateogyr和Class Extension的区别是什么？<ul><li>Class Extension在编译的时候，它的数据就已经包含在类信息中</li><li>Category是在运行时，才会将数据合并到类信息中</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;底层结构&quot;&gt;&lt;a href=&quot;#底层结构&quot; class=&quot;headerlink&quot; title=&quot;底层结构&quot;&gt;&lt;/a&gt;底层结构&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="底层原理" scheme="http://www.hxtec.top/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>KVO &amp; KVC</title>
    <link href="http://www.hxtec.top/2022/09/17/KVO-KVC/"/>
    <id>http://www.hxtec.top/2022/09/17/KVO-KVC/</id>
    <published>2022-09-17T09:29:35.000Z</published>
    <updated>2022-09-17T10:41:59.665Z</updated>
    
    <content type="html"><![CDATA[<h2 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h2><ul><li><p>KVO的全称是Key-Value Observing，俗称“键值监听”，可以用于监听某个对象属性值的改变</p></li><li><p>添加KVO方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">self.person = [[Person alloc] init];</span><br><span class="line"></span><br><span class="line">// 给person对象添加KVO监听</span><br><span class="line">NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;</span><br><span class="line">[self.person addObserver:self forKeyPath:@&quot;age&quot; options:options context:@&quot;123&quot;];</span><br><span class="line"></span><br><span class="line">// observeValueForKeyPath:ofObject:change:context:</span><br><span class="line">// 当监听对象的属性值发生改变时，就会调用</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;监听到%@的%@属性值改变了 - %@ - %@&quot;, object, keyPath, change, context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//移除监听</span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    [self.person1 removeObserver:self forKeyPath:@&quot;age&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>获取类的所有方法</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (void)printMethodNamesOfClass:(Class)cls</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int count;</span><br><span class="line">    // 获得方法数组</span><br><span class="line">    Method *methodList = class_copyMethodList(cls, &amp;count);</span><br><span class="line">    </span><br><span class="line">    // 存储方法名</span><br><span class="line">    NSMutableString *methodNames = [NSMutableString string];</span><br><span class="line">    </span><br><span class="line">    // 遍历所有的方法</span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        // 获得方法</span><br><span class="line">        Method method = methodList[i];</span><br><span class="line">        // 获得方法名</span><br><span class="line">        NSString *methodName = NSStringFromSelector(method_getName(method));</span><br><span class="line">        // 拼接方法名</span><br><span class="line">        [methodNames appendString:methodName];</span><br><span class="line">        [methodNames appendString:@&quot;, &quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 释放</span><br><span class="line">    free(methodList);</span><br><span class="line">    </span><br><span class="line">    // 打印方法名</span><br><span class="line">    NSLog(@&quot;%@ %@&quot;, cls, methodNames);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用</span><br><span class="line">[self printMethodNamesOfClass:object_getClass(self.person)];</span><br><span class="line"></span><br><span class="line">//打印结果，即为中间派生类的方法</span><br><span class="line">NSKVONotifying_Person setAge:, class, dealloc, _isKVOA,</span><br></pre></td></tr></table></figure><h2 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h2><ul><li>KVC的全称是Key-Value Coding，俗称“键值编码”，可以通过一个key来访问某个属性</li><li>常见的API有<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)setValue:(id)value forKeyPath:(NSString *)keyPath;</span><br><span class="line">- (void)setValue:(id)value forKey:(NSString *)key;</span><br><span class="line"></span><br><span class="line">- (id)valueForKeyPath:(NSString *)keyPath;</span><br><span class="line">- (id)valueForKey:(NSString *)key; </span><br></pre></td></tr></table></figure><blockquote><p>示例：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@interface Cat : NSObject</span><br><span class="line">@property (assign, nonatomic) int weight;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface Person : NSObject</span><br><span class="line">@property (assign, nonatomic) int age;</span><br><span class="line"></span><br><span class="line">@property (assign, nonatomic) Cat *cat;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">Person *person = [[Person alloc] init];</span><br><span class="line">// 进行赋值</span><br><span class="line">//[person setValue:[NSNumber numberWithInt:10] forKey:@&quot;age&quot;];</span><br><span class="line">[person setValue:@10 forKey:@&quot;age&quot;];</span><br><span class="line"></span><br><span class="line">//通过keyPath，进行赋值</span><br><span class="line">person.cat = [[Cat alloc] init];</span><br><span class="line">[person setValue:@10 forKeyPath:@&quot;cat.weight&quot;];</span><br></pre></td></tr></table></figure></li></ul><h3 id="setValue-forKey-的原理"><a href="#setValue-forKey-的原理" class="headerlink" title="setValue:forKey:的原理"></a>setValue:forKey:的原理</h3><blockquote><ul><li>setValue:forKey: </li><li>按照setKey: _setKey: 顺序查找方法</li><li>找到方法 -&gt; 传递参数，调用方法</li><li>没有找到方法 -&gt; 查看 &#x3D;&#x3D;accessInstanceVariablesDirectly&#x3D;&#x3D; 方法的返回值</li><li>返回 YES -&gt; 按照 _key、_isKey、key、isKey 顺序查找&#x3D;&#x3D;成员变量&#x3D;&#x3D;，直接赋值，如果还是没有找到，走下一步</li><li>返回NO -&gt; 调用 &#x3D;&#x3D;setValue:forUndefinedKey:&#x3D;&#x3D; 并抛出异常NSUnknownKeyException</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">&#123;</span><br><span class="line">    @public</span><br><span class="line">// 按钮 _key、_isKey、key、isKey 顺序查找</span><br><span class="line">//    int _age;</span><br><span class="line">//    int _isAge;</span><br><span class="line">//    int age;</span><br><span class="line">//    int isAge;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MJPerson</span><br><span class="line">//先找setAge方法，进行赋值</span><br><span class="line">//- (void)setAge:(int)age</span><br><span class="line">//&#123;</span><br><span class="line">//    NSLog(@&quot;setAge: - %d&quot;, age);</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">//再找_setAge方法，进行赋值</span><br><span class="line">//- (void)_setAge:(int)age</span><br><span class="line">//&#123;</span><br><span class="line">//    NSLog(@&quot;_setAge: - %d&quot;, age);</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">// 默认的返回值就是YES</span><br><span class="line">//+ (BOOL)accessInstanceVariablesDirectly</span><br><span class="line">//&#123;</span><br><span class="line">//    return YES;//默认的返回值就是YES</span><br><span class="line">//    return NO;//抛出异常NSUnknownKeyException, setValue:forUndefinedKey:</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="valueForKey-的原理"><a href="#valueForKey-的原理" class="headerlink" title="valueForKey:的原理"></a>valueForKey:的原理</h3><blockquote><ul><li>valueForKey:</li><li>按照 getKey、key、 isKey、_key 顺序查找方</li><li>找到方法 -&gt; 调用方法，返回值</li><li>没有找到方法 -&gt; 查看 &#x3D;&#x3D;accessInstanceVariablesDirectly&#x3D;&#x3D; 方法的返回值</li><li>返回 YES -&gt; 按照 _key、_isKey、key、isKey 顺序查找成员变量，直接赋值，如果还是没有找到成员变量，走下一步</li><li>返回NO -&gt; 调用 调用 &#x3D;&#x3D;valueForUndefinedKey:&#x3D;&#x3D; 并抛出异常NSUnknownKeyException</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">&#123;</span><br><span class="line">    @public</span><br><span class="line">// 按照 _key、_isKey、key、isKey 顺序查找</span><br><span class="line">//    int _age;</span><br><span class="line">//    int _isAge;</span><br><span class="line">//    int age;</span><br><span class="line">//    int isAge;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MJPerson</span><br><span class="line">//- (int)getAge</span><br><span class="line">//&#123;</span><br><span class="line">//    return 11;</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">//- (int)age</span><br><span class="line">//&#123;</span><br><span class="line">//    return 12;</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">//- (int)isAge</span><br><span class="line">//&#123;</span><br><span class="line">//    return 13;</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">//- (int)_age</span><br><span class="line">//&#123;</span><br><span class="line">//    return 14;</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">// 默认的返回值就是YES</span><br><span class="line">//+ (BOOL)accessInstanceVariablesDirectly</span><br><span class="line">//&#123;</span><br><span class="line">//    return YES;//默认的返回值就是YES</span><br><span class="line">//    return NO;//抛出异常NSUnknownKeyException, setValue:forUndefinedKey:</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><blockquote><p>通过KVC修改属性是否会触发KVO？</p><ul><li>会触发KVO</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Observer *observer = [[Observer alloc] init];</span><br><span class="line">Person *person = [[Person alloc] init];</span><br><span class="line"></span><br><span class="line">// 添加KVO监听</span><br><span class="line">[person addObserver:observer forKeyPath:@&quot;age&quot; options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:NULL];</span><br><span class="line"></span><br><span class="line">// 通过KVC修改age属性</span><br><span class="line">[person setValue:@10 forKey:@&quot;age&quot;];</span><br><span class="line"></span><br><span class="line">// 也可手动触发KVO</span><br><span class="line">// [person willChangeValueForKey:@&quot;age&quot;];</span><br><span class="line">// person-&gt;_age = 10;</span><br><span class="line">// [person didChangeValueForKey:@&quot;age&quot;];</span><br><span class="line"></span><br><span class="line">// 移除KVO监听</span><br><span class="line">[person removeObserver:observer forKeyPath:@&quot;age&quot;];</span><br></pre></td></tr></table></figure><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><ul><li>利用RuntimeAPI动态生成一个子类，并且让instance对象的isa指向这个全新的子类</li><li>当修改instance对象的属性时，会调用Foundation的_NSSetXXXValueAndNotify函数<ul><li>willChangeValueForKey:</li><li>父类原来的setter</li><li>didChangeValueForKey:<ul><li>内部会触发监听器（Oberser）的监听方法( observeValueForKeyPath:ofObject:change:context:）</li></ul></li></ul></li></ul><h4 id="手动触发KVO"><a href="#手动触发KVO" class="headerlink" title="手动触发KVO"></a>手动触发KVO</h4><ul><li>手动调用willChangeValueForKey:和didChangeValueForKey:</li></ul><h4 id="直接修改成员变量会触发KVO么？"><a href="#直接修改成员变量会触发KVO么？" class="headerlink" title="直接修改成员变量会触发KVO么？"></a>直接修改成员变量会触发KVO么？</h4><ul><li>不会触发KVO</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;KVO&quot;&gt;&lt;a href=&quot;#KVO&quot; class=&quot;headerlink&quot; title=&quot;KVO&quot;&gt;&lt;/a&gt;KVO&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;KVO的全称是Key-Value Observing，俗称“键值监听”，可以用于监听某个对象属性值的改变&lt;/p&gt;
</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="底层原理" scheme="http://www.hxtec.top/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>OC语法</title>
    <link href="http://www.hxtec.top/2022/09/17/OC%E8%AF%AD%E6%B3%95/"/>
    <id>http://www.hxtec.top/2022/09/17/OC%E8%AF%AD%E6%B3%95/</id>
    <published>2022-09-17T08:58:57.000Z</published>
    <updated>2022-09-17T10:36:13.272Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Objective-c语法"><a href="#Objective-c语法" class="headerlink" title="Objective-c语法"></a>Objective-c语法</h2><h3 id="Objective-C的本质"><a href="#Objective-C的本质" class="headerlink" title="Objective-C的本质"></a>Objective-C的本质</h3><ul><li>平时编写的OC代码，底层实现其实都是C&#x2F;C++代码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Objective-C -&gt; C/C++ -&gt; 汇编语言 -&gt; 机器语言</span><br></pre></td></tr></table></figure><ul><li>OC的面向对象都是基于C&#x2F;C++的数据结构实现的，即 <strong>结构体</strong></li></ul><h3 id="NSObject的底层实现"><a href="#NSObject的底层实现" class="headerlink" title="NSObject的底层实现"></a>NSObject的底层实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@interface NSObject &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">底层结构体形式：</span><br><span class="line">struct NSObject_IMPL &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>创建一个实例对象，至少需要多少内存？</p><ul><li>至少需要8个字节<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line">class_getInstanceSize([NSObjcet class]);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>创建一个实例对象，实际上分配了多少内存？</p><ul><li>实际分配了16个字节   </li><li>底层是Buckets size, 16, 32, 48, 64…. 都是16的位数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line">malloc_size((__bridge const void *)obj)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="OC对象的分类"><a href="#OC对象的分类" class="headerlink" title="OC对象的分类"></a>OC对象的分类</h3><ul><li><p>instance对象（实例对象）</p><ul><li>alloc出来的对象，在内存中存储的信息包括：<ol><li>isa指针</li><li>其他成员变量</li></ol></li></ul></li><li><p>class对象（类对象）</p><ul><li>每个类在内存中有且只有一个class对象</li><li>class对象在内存中存储的信息主要包括：<ol><li>isa指针</li><li>superClass指针</li><li>类的属性信息(property)、类的对象方法信息(instance method)</li><li>类的协议信息(protocol)、类的成员变量信息(ivar)</li><li>……</li></ol></li></ul></li><li><p>meta-class对象（元类对象）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class objectMetaClass = objc_getClass([NSObject class]);//Runtime API</span><br></pre></td></tr></table></figure><blockquote><p>小结：</p><ul><li>objectMetaClass是NSObject的meta-class对象(元类对象)</li><li>每个类在内存中只有一个meta-class对象</li><li>meta-class对象和class对象的内存结构是一样的，但是用途不一样<br>主要包括：<br>    1. isa指针<br>    2. superclass指针<br>    3. 类的方法信息(class method)<br>    4. ……</li></ul></blockquote></li><li><p>查看Class是否为meta-class，方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bool result = class_isMetaClass([NSObjce class]);</span><br></pre></td></tr></table></figure></li></ul><h3 id="isa指针"><a href="#isa指针" class="headerlink" title="isa指针"></a>isa指针</h3><p><img src="http://rfshxohrg.hn-bkt.clouddn.com/WX20220730-105146.png" alt="image"></p><ul><li>instance的 <code>isa </code>指向class<ul><li>当调用 <code>对象方法 </code>时，通过instance的 <code>isa </code>找到class，最后找到 <code>对象方法 </code>的实现进行调用</li></ul></li><li>class的 <code>isa </code>指向meta-class<ul><li>当调用 <code>类方法 </code>时，通过class的 <code>isa </code>找到meta-class，最后找到 <code>类方法 </code>的实现进行调用<br><img src="http://rfshxohrg.hn-bkt.clouddn.com/WX20220730-112038.png" alt="image"></li></ul></li></ul><p>** <code>note: </code>** 从64位开始，isa需要进行一次位运算，才能计算出真实地址</p><h3 id="class对象的superclass指针"><a href="#class对象的superclass指针" class="headerlink" title="class对象的superclass指针"></a>class对象的superclass指针</h3><p><img src="http://rfshxohrg.hn-bkt.clouddn.com/WX20220730-110416.png" alt="image"></p><p>** <code>note: </code>** 当student的instance对象要调用Person的对象方法时，会先通过 <code>isa </code>找到Student的class，然后通过 <code>superclass </code>找到Person的class，最后找到对象方法的实现进行调用</p><h3 id="meta-class对象的superclass指针"><a href="#meta-class对象的superclass指针" class="headerlink" title="meta-class对象的superclass指针"></a>meta-class对象的superclass指针</h3><p><img src="http://rfshxohrg.hn-bkt.clouddn.com/WX20220730-111359.png" alt="image"></p><p>** <code>note: </code>** 当Student的class要调用Person的类方法时，会先通过 <code>isa </code>找到Student的meta-class，然后通过 <code>superclass </code>找到Person的meta-class，最后找到类方法的实现进行调用</p><h2 id="isa、superclass总结"><a href="#isa、superclass总结" class="headerlink" title="isa、superclass总结"></a>isa、superclass总结</h2><p><img src="http://rfshxohrg.hn-bkt.clouddn.com/%E5%9B%BE%E7%89%871.png" alt="image"></p><blockquote><ol><li>instance的isa指向class</li><li>class的isa指向meta-class</li><li>meta-class的isa指向基类的meta-class</li><li>class的superclass指向父类的class<br>如果没有父类，superclass指针为nil</li><li>meta-class的superclass指向父类的meta-class<br>基类的meta-class的superclass指向基类的class</li><li>instance调用对象方法的轨迹<br>isa找到class，方法不存在，就通过superclass找父类</li><li>class调用类方法的轨迹<br>isa找meta-class，方法不存在，就通过superclass找父类</li></ol></blockquote><h2 id="64位isa指针"><a href="#64位isa指针" class="headerlink" title="64位isa指针"></a>64位isa指针</h2><ul><li>从64bit开始，isa需要进行一次位运算(isa地址 &amp; ISA_MASK)，才能计算出真实地址<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># if __arm64__</span><br><span class="line">#   define ISA_MASK        0x0000000ffffffff8ULL</span><br><span class="line"># elif __x86_64__</span><br><span class="line">#   define ISA_MASK        0x00007ffffffffff8ULL</span><br><span class="line"># endif</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>struct objc_class的结构</p></blockquote><ul><li>class、meta-class对象的本质结构都是struct objc_class<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">struct class_ro_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t instanceStart;</span><br><span class="line">    uint32_t instanceSize;  // instance对象占用的内存空间</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    uint32_t reserved;</span><br><span class="line">#endif</span><br><span class="line">    const uint8_t * ivarLayout;</span><br><span class="line">    const char * name;  // 类名</span><br><span class="line">    method_list_t * baseMethodList;</span><br><span class="line">    protocol_list_t * baseProtocols;</span><br><span class="line">    const ivar_list_t * ivars;  // 成员变量列表</span><br><span class="line">    const uint8_t * weakIvarLayout;</span><br><span class="line">    property_list_t *baseProperties;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct class_rw_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t version;</span><br><span class="line">    const class_ro_t *ro;</span><br><span class="line">    method_list_t * methods;    // 方法列表</span><br><span class="line">    property_list_t *properties;    // 属性列表</span><br><span class="line">    const protocol_list_t * protocols;  // 协议列表</span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line">    char *demangledName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#define FAST_DATA_MASK          0x00007ffffffffff8UL</span><br><span class="line">struct class_data_bits_t &#123;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">public:</span><br><span class="line">    class_rw_t* data() &#123;</span><br><span class="line">        return (class_rw_t *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* OC对象 */</span><br><span class="line">struct hx_objc_object &#123;</span><br><span class="line">    void *isa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* 类对象 */</span><br><span class="line">struct hx_objc_class : hx_objc_object &#123;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;</span><br><span class="line">    class_data_bits_t bits;</span><br><span class="line">public:</span><br><span class="line">    class_rw_t* data() &#123;</span><br><span class="line">        return bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    hx_objc_class* metaClass() &#123;</span><br><span class="line">        return (hx_objc_class *)((long long)isa &amp; ISA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>用如下方法进行断点查看，内部结构内容<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//实例对象</span><br><span class="line">hx_objc_class *studentClass = (__bridge hx_objc_class *)([Student class]);</span><br><span class="line">hx_objc_class *personClass = (__bridge hx_objc_class *)([Person class]);</span><br><span class="line"></span><br><span class="line">//类对象</span><br><span class="line">class_rw_t *studentClassData = studentClass-&gt;data();</span><br><span class="line">class_rw_t *personClassData = personClass-&gt;data();</span><br><span class="line"></span><br><span class="line">//元类对象</span><br><span class="line">class_rw_t *studentMetaClassData = studentClass-&gt;metaClass()-&gt;data();</span><br><span class="line">class_rw_t *personMetaClassData = personClass-&gt;metaClass()-&gt;data();</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Objective-c语法&quot;&gt;&lt;a href=&quot;#Objective-c语法&quot; class=&quot;headerlink&quot; title=&quot;Objective-c语法&quot;&gt;&lt;/a&gt;Objective-c语法&lt;/h2&gt;&lt;h3 id=&quot;Objective-C的本质&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="底层原理" scheme="http://www.hxtec.top/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
</feed>
