<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ivan&#39;s Blog</title>
  
  <subtitle>华曦之家</subtitle>
  <link href="http://www.hxtec.top/atom.xml" rel="self"/>
  
  <link href="http://www.hxtec.top/"/>
  <updated>2022-09-22T12:08:51.869Z</updated>
  <id>http://www.hxtec.top/</id>
  
  <author>
    <name>ivan_华之曦</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Runtime - API及应用</title>
    <link href="http://www.hxtec.top/2022/09/22/Runtime-API%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    <id>http://www.hxtec.top/2022/09/22/Runtime-API%E5%8F%8A%E5%BA%94%E7%94%A8/</id>
    <published>2022-09-22T11:35:53.000Z</published>
    <updated>2022-09-22T12:08:51.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="API-01-类"><a href="#API-01-类" class="headerlink" title="API-01-类"></a>API-01-类</h2><blockquote><p>动态创建一个类（参数：父类，类名，额外的内存空间）<br>Class objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)</p></blockquote><blockquote><p>注册一个类（要在类注册之前添加成员变量）<br>void objc_registerClassPair(Class cls)</p></blockquote><blockquote><p>销毁一个类<br>void objc_disposeClassPair(Class cls)</p></blockquote><blockquote><p>获取isa指向的Class<br>Class object_getClass(id obj)</p></blockquote><blockquote><p>设置isa指向的Class<br>Class object_setClass(id obj, Class cls)</p></blockquote><blockquote><p>判断一个OC对象是否为Class<br>BOOL object_isClass(id obj)</p></blockquote><blockquote><p>判断一个Class是否为元类<br>BOOL class_isMetaClass(Class cls)</p></blockquote><blockquote><p>获取父类<br>Class class_getSuperclass(Class cls)</p></blockquote><blockquote><p>示例：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 创建类</span><br><span class="line">Class newClass = objc_allocateClassPair([NSObject class], &quot;Dog&quot;, 0);</span><br><span class="line"></span><br><span class="line">//添加成员变量</span><br><span class="line">class_addIvar(newClass, &quot;_age&quot;, 4, 1, @encode(int));</span><br><span class="line">class_addIvar(newClass, &quot;_weight&quot;, 4, 1, @encode(int));</span><br><span class="line"></span><br><span class="line">//添加方法</span><br><span class="line">class_addMethod(newClass, @selector(run), (IMP)run, &quot;v@:&quot;);</span><br><span class="line"></span><br><span class="line">// 注册类</span><br><span class="line">objc_registerClassPair(newClass);</span><br><span class="line"></span><br><span class="line">// 在不需要这个类时释放</span><br><span class="line">objc_disposeClassPair(newClass);</span><br><span class="line"></span><br><span class="line">Person *person = [[Person alloc] init];</span><br><span class="line">[person run];</span><br><span class="line">//设置isa指向的Class</span><br><span class="line">object_setClass(person, [Car class]);</span><br><span class="line">[person run];</span><br><span class="line"></span><br><span class="line">//判断一个OC对象是否为Class</span><br><span class="line">NSLog(@&quot;%d %d %d&quot;,</span><br><span class="line">      object_isClass(person),</span><br><span class="line">      object_isClass([Person class]),</span><br><span class="line">      object_isClass(object_getClass([Person class]))</span><br><span class="line">      );</span><br></pre></td></tr></table></figure><h2 id="API-02-成员变量"><a href="#API-02-成员变量" class="headerlink" title="API-02-成员变量"></a>API-02-成员变量</h2><blockquote><p>获取一个实例变量信息<br>Ivar class_getInstanceVariable(Class cls, const char *name)</p></blockquote><blockquote><p>拷贝实例变量列表（最后需要调用free释放）<br>Ivar *class_copyIvarList(Class cls, unsigned int *outCount)</p></blockquote><blockquote><p>设置和获取成员变量的值<br>void object_setIvar(id obj, Ivar ivar, id value)<br>id object_getIvar(id obj, Ivar ivar)</p></blockquote><blockquote><p>动态添加成员变量（已经注册的类是不能动态添加成员变量的）<br>BOOL class_addIvar(Class cls, const char * name, size_t size, uint8_t alignment, const char * types)</p></blockquote><blockquote><p>获取成员变量的相关信息<br>const char *ivar_getName(Ivar v)<br>const char *ivar_getTypeEncoding(Ivar v)</p></blockquote><blockquote><p>示例：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//获取成员变量信息</span><br><span class="line">var ageIvar = class_getInstanceVariable([Person class], &quot;_age&quot;);</span><br><span class="line">NSLog(@&quot;%s %s&quot;, ivar_getName(ageIvar), ivar_getTypeEncoding(ageIvar));</span><br><span class="line"></span><br><span class="line">// 设置和获取成员变量的值</span><br><span class="line">Ivar nameIvar = class_getInstanceVariable([Person class], &quot;_name&quot;);</span><br><span class="line"></span><br><span class="line">Person *person = [[Person alloc] init];</span><br><span class="line">object_setIvar(person, nameIvar, @&quot;123&quot;);</span><br><span class="line">object_setIvar(person, ageIvar, (__bridge id)(void *)10);</span><br><span class="line">NSLog(@&quot;%@ %d&quot;, person.name, person.age);</span><br><span class="line"></span><br><span class="line">// 成员变量的数量</span><br><span class="line">unsigned int count;</span><br><span class="line">Ivar *ivars = class_copyIvarList([Person class], &amp;count);</span><br><span class="line">for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">    // 取出i位置的成员变量</span><br><span class="line">    Ivar ivar = ivars[i];</span><br><span class="line">    NSLog(@&quot;%s %s&quot;, ivar_getName(ivar), ivar_getTypeEncoding(ivar));</span><br><span class="line">&#125;</span><br><span class="line">free(ivars);</span><br></pre></td></tr></table></figure><h2 id="API-03-属性"><a href="#API-03-属性" class="headerlink" title="API-03-属性"></a>API-03-属性</h2><blockquote><p>获取一个属性<br>objc_property_t class_getProperty(Class cls, const char *name)</p></blockquote><blockquote><p>拷贝属性列表（最后需要调用free释放）<br>objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount)</p></blockquote><blockquote><p>动态添加属性<br>BOOL class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attributes,<br>                  unsigned int attributeCount)</p></blockquote><blockquote><p>动态替换属性<br>void class_replaceProperty(Class cls, const char *name, const objc_property_attribute_t *attributes,<br>                      unsigned int attributeCount)</p></blockquote><blockquote><p>获取属性的一些信息<br>const char *property_getName(objc_property_t property)<br>const char *property_getAttributes(objc_property_t property)</p></blockquote><blockquote><p>示例：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">unsigned int count;</span><br><span class="line">Ivar *ivars = class_copyIvarList([UITextField class], &amp;count);</span><br><span class="line">for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">    // 取出i位置的成员变量</span><br><span class="line">    Ivar ivar = ivars[i];</span><br><span class="line">    NSLog(@&quot;%s %s&quot;, ivar_getName(ivar), ivar_getTypeEncoding(ivar));</span><br><span class="line">&#125;</span><br><span class="line">free(ivars);</span><br><span class="line"></span><br><span class="line">//下面的使用方法已经废弃，仅供参考</span><br><span class="line">self.textField.placeholder = @&quot;请输入用户名&quot;;</span><br><span class="line">[self.textField setValue:[UIColor redColor] forKeyPath:@&quot;_placeholderLabel.textColor&quot;];</span><br></pre></td></tr></table></figure><h2 id="API-04-方法"><a href="#API-04-方法" class="headerlink" title="API-04-方法"></a>API-04-方法</h2><blockquote><p>获得一个实例方法、类方法<br>Method class_getInstanceMethod(Class cls, SEL name)<br>Method class_getClassMethod(Class cls, SEL name)</p></blockquote><blockquote><p>方法实现相关操作<br>IMP class_getMethodImplementation(Class cls, SEL name)<br>IMP method_setImplementation(Method m, IMP imp)<br>void method_exchangeImplementations(Method m1, Method m2) </p></blockquote><blockquote><p>拷贝方法列表（最后需要调用free释放）<br>Method *class_copyMethodList(Class cls, unsigned int *outCount)</p></blockquote><blockquote><p>动态添加方法<br>BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)</p></blockquote><blockquote><p>动态替换方法<br>IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types)</p></blockquote><blockquote><p>获取方法的相关信息（带有copy的需要调用free去释放）<br>SEL method_getName(Method m)<br>IMP method_getImplementation(Method m)<br>const char *method_getTypeEncoding(Method m)<br>unsigned int method_getNumberOfArguments(Method m)<br>char *method_copyReturnType(Method m)<br>char *method_copyArgumentType(Method m, unsigned int index)</p></blockquote><blockquote><p>选择器相关<br>const char *sel_getName(SEL sel)<br>SEL sel_registerName(const char *str)</p></blockquote><blockquote><p>用block作为方法实现<br>IMP imp_implementationWithBlock(id block)<br>id imp_getBlock(IMP anImp)<br>BOOL imp_removeBlock(IMP anImp)</p></blockquote><blockquote><p>示例：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Person *person = [[Person alloc] init];</span><br><span class="line">//    class_replaceMethod([MJPerson class], @selector(run), (IMP)myrun, &quot;v&quot;);</span><br><span class="line">//block的形式</span><br><span class="line">class_replaceMethod([Person class], @selector(run), imp_implementationWithBlock(^&#123;</span><br><span class="line">    NSLog(@&quot;123&quot;);</span><br><span class="line">&#125;), &quot;v&quot;);</span><br><span class="line">[person run];</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>示例：方法交换</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Person *person = [[Person alloc] init];</span><br><span class="line"></span><br><span class="line">Method runMethod = class_getInstanceMethod([MJPerson class], @selector(run));</span><br><span class="line">Method testMethod = class_getInstanceMethod([MJPerson class], @selector(test));</span><br><span class="line">method_exchangeImplementations(runMethod, testMethod);</span><br><span class="line"></span><br><span class="line">[person run];</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;API-01-类&quot;&gt;&lt;a href=&quot;#API-01-类&quot; class=&quot;headerlink&quot; title=&quot;API-01-类&quot;&gt;&lt;/a&gt;API-01-类&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;动态创建一个类（参数：父类，类名，额外的内存空间）&lt;br&gt;Clas</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Objective-C" scheme="http://www.hxtec.top/tags/Objective-C/"/>
    
    <category term="底层原理" scheme="http://www.hxtec.top/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    <category term="Runtime" scheme="http://www.hxtec.top/tags/Runtime/"/>
    
  </entry>
  
  <entry>
    <title>Runtime - 消息发送机制</title>
    <link href="http://www.hxtec.top/2022/09/22/Runtime-%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E6%9C%BA%E5%88%B6/"/>
    <id>http://www.hxtec.top/2022/09/22/Runtime-%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E6%9C%BA%E5%88%B6/</id>
    <published>2022-09-22T10:38:49.000Z</published>
    <updated>2022-09-22T11:33:51.210Z</updated>
    
    <content type="html"><![CDATA[<h2 id="objc-msgSend执行流程"><a href="#objc-msgSend执行流程" class="headerlink" title="objc_msgSend执行流程"></a>objc_msgSend执行流程</h2><ul><li>OC中的方法调用，其实都是转换为objc_msgSend函数的调用</li><li>objc_msgSend的执行流程可以分为3大阶段<ul><li>消息发送</li><li>动态方法解析</li><li>消息转发</li></ul></li></ul><h3 id="源码跟读"><a href="#源码跟读" class="headerlink" title="源码跟读"></a>源码跟读</h3><blockquote><p>objc-msg-arm64.s</p><ul><li>ENTRY _objc_msgSend</li><li>b.le    LNilOrTagged</li><li>CacheLookup NORMAL</li><li>.macro CacheLookup</li><li>.macro CheckMiss</li><li>STATIC_ENTRY __objc_msgSend_uncached</li><li>.macro MethodTableLookup</li><li>__class_lookupMethodAndLoadCache3</li></ul></blockquote><blockquote><p>objc-runtime-new.mm</p><ul><li>_class_lookupMethodAndLoadCache3</li><li>lookUpImpOrForward</li><li>getMethodNoSuper_nolock、search_method_list、log_and_fill_cache</li><li>cache_getImp、log_and_fill_cache、getMethodNoSuper_nolock、log_and_fill_cache</li><li>_class_resolveInstanceMethod</li><li>_objc_msgForward_impcache</li></ul></blockquote><blockquote><p>objc-msg-arm64.s</p><ul><li>STATIC_ENTRY __objc_msgForward_impcache</li><li>ENTRY __objc_msgForward</li></ul></blockquote><blockquote><p>Core Foundation</p><ul><li>__forwarding__（不开源）</li></ul></blockquote><h3 id="消息发送-objc-msgSend执行流程1"><a href="#消息发送-objc-msgSend执行流程1" class="headerlink" title="消息发送 - objc_msgSend执行流程1"></a>消息发送 - objc_msgSend执行流程1</h3><ul><li>receiver是否为nil<ul><li>是，退出</li><li>否<ul><li>从receiverClass的cache中查找方法<ul><li>找到方法 -&gt; 调用方法结束查找</li><li>没有找到方法<ul><li>从receiverClass的<code>class_rw_t</code>中查找方法<ul><li>找到方法 -&gt; 调用方法结束查找，并将方法缓存到receiverClass的cache中</li><li>未找到方法<ul><li>从superClass的<code>cache</code>中查找方法<ul><li>找到方法 -&gt; 调用方法结束查找，并将方法缓存到receiverClass的cache中</li><li>未找到方法<ul><li>从<code>superClass</code>的cache中查找方法<ul><li>找到方法 -&gt; 调用方法结束查找，并将方法缓存到receiverClass的cache中</li><li>未找到方法<ul><li>上层是否还有<code>superClass</code><ul><li>是，继续 从superClass的cache中查找方法</li><li>否，进入 <code>动态方法解析</code> 阶段</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li>如果是从class_rw_t中查找方法<ul><li>已经排序的，二分查找</li><li>没有排序的，遍历查找</li></ul></li><li>receiver通过isa指针找到receiverClass</li><li>receiverClass通过superClass指针找到superClass</li></ul><h3 id="动态方法解析-objc-msgSend执行流程2"><a href="#动态方法解析-objc-msgSend执行流程2" class="headerlink" title="动态方法解析 - objc_msgSend执行流程2"></a>动态方法解析 - objc_msgSend执行流程2</h3><ul><li>是否曾经有动态解析<ul><li>是，进入 <code>消息转发</code> 阶段</li><li>否<ul><li>调用+resolveInstanceMethod:或者+resolveClassMethod:方法来动态解析方法</li><li>标记为已经动态解析</li><li>消息发送</li></ul></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void other(id self, SEL _cmd) &#123;</span><br><span class="line">    NSLog(@&quot;%@ - %s - %@&quot;, self, sel_getName(_cmd), __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    if (sel == @selector(test)) &#123;</span><br><span class="line">        Method method = class_getInstanceMethod(self, @selector(other));</span><br><span class="line">        class_addMethod(self,</span><br><span class="line">                        sel,</span><br><span class="line">                        method_getImplementation(method),</span><br><span class="line">                        method_getTypeEncoding(method));</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>开发者可以实现以下方法，来动态添加方法实现</p><ul><li>+resolveInstanceMethod:</li><li>+resolveClassMethod:</li></ul></blockquote><blockquote><p>动态解析过后，会重新走“消息发送”的流程<br>“从<code>receiverClass的cache</code>中查找方法”这一步开始执行</p></blockquote><h3 id="消息转发-objc-msgSend执行流程3"><a href="#消息转发-objc-msgSend执行流程3" class="headerlink" title="消息转发 - objc_msgSend执行流程3"></a>消息转发 - objc_msgSend执行流程3</h3><ul><li>调用 <code>forwardingTargetForSelector:</code> 方法<ul><li>返回值不为nil -&gt; objc_msgSend(返回值， SEL)</li><li>返回值为nil<ul><li>调用 <code>methodSignatureForSelector:</code> 方法<ul><li>返回值不为nil 调用 <code>forwardInvocation:</code> 方法</li><li>返回值为nil<ul><li>调用<code>doesNotRecognizedSelector:</code>方法（常见的方法找不到错误）</li></ul></li></ul></li></ul></li></ul></li></ul><blockquote><p>示例：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    if (aSelector == @selector(test)) return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];</span><br><span class="line">    return [super methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class="line">    NSLog(&quot;可以作任何处理...&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>开发者可以在<code>forwardInvocation:</code>方法中自定义任何逻辑<br>且：以上方法都有对象方法、类方法2个版本（前面可以是加号+，也可以是减号-）</p></blockquote><blockquote><p>补充：<br><code>@dynamic</code>是告诉编译器不用自动生成getter和setter的实现，等到运行时再添加方法实现</p></blockquote><h2 id="Super的本质"><a href="#Super的本质" class="headerlink" title="Super的本质"></a>Super的本质</h2><ul><li>super调用，底层会转换为objc_msgSendSuper2函数的调用，接收2个参数<ul><li>struct objc_super2</li><li>SEL</li></ul></li></ul><blockquote><p>结构体如下：</p><ul><li>receiver是消息接收者</li><li>current_class是recevier的class对象</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct objc_super2 &#123;</span><br><span class="line">    id receiver;</span><br><span class="line">    Class current_class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LLVM的中间代码（IR）"><a href="#LLVM的中间代码（IR）" class="headerlink" title="LLVM的中间代码（IR）"></a>LLVM的中间代码（IR）</h2><ul><li>Objective-C在变为机器代码之前，会被LLVM编译器转换为中间代码（Intermediate Representation）</li></ul><blockquote><p>可以使用以下命令行指令生成中间代码</p><ul><li>clang -emit-llvm -S main.m</li></ul></blockquote><blockquote><p>语法简介<br>@ - 全局变量<br>% - 局部变量<br>alloca - 在当前执行的函数的堆栈帧中分配内存，当该函数返回到其调用者时，将自动释放内存<br>i32 - 32位4字节的整数<br>align - 对齐<br>load - 读出，store 写入<br>icmp - 两个整数值比较，返回布尔值<br>br - 选择分支，根据条件来转向label，不根据条件跳转的话类似 goto<br>label - 代码标签<br>call - 调用函数</p></blockquote><ul><li>具体可以参考官方文档：<a href="https://llvm.org/docs/LangRef.html">https://llvm.org/docs/LangRef.html</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;objc-msgSend执行流程&quot;&gt;&lt;a href=&quot;#objc-msgSend执行流程&quot; class=&quot;headerlink&quot; title=&quot;objc_msgSend执行流程&quot;&gt;&lt;/a&gt;objc_msgSend执行流程&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;OC中的方法调用</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Objective-C" scheme="http://www.hxtec.top/tags/Objective-C/"/>
    
    <category term="底层原理" scheme="http://www.hxtec.top/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    <category term="Runtime" scheme="http://www.hxtec.top/tags/Runtime/"/>
    
  </entry>
  
  <entry>
    <title>Runtime理解</title>
    <link href="http://www.hxtec.top/2022/09/22/Runtime%E7%90%86%E8%A7%A3/"/>
    <id>http://www.hxtec.top/2022/09/22/Runtime%E7%90%86%E8%A7%A3/</id>
    <published>2022-09-22T09:26:52.000Z</published>
    <updated>2022-09-22T10:39:22.937Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>Object-C是一门动态性比较强的编程语言，跟C，C++等语言有着很大的不同</li><li>Object-C的动态性是由Runtime API来支撑的</li><li>Runtime API提供的接口基本都是C语言的，源码由C&#x2F;C++&#x2F;汇编编写</li></ul><h2 id="isa详解"><a href="#isa详解" class="headerlink" title="isa详解"></a>isa详解</h2><ul><li>学习Runtime，首先了解底层的常用数据结构，比如<code>iso</code>指针</li><li>在arm64架构之前，isa就是一个普通的指针，存储着Class，Meta-Class对象的内存地址</li><li>从arm64架构开始，对isa进行了优化，变成了一个共用体（union）结构，还使用位域来存储更多的信息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">union isa_t &#123;</span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">    struct &#123;</span><br><span class="line">        uintptr_t nonpointer                : 1;</span><br><span class="line">        uintptr_t has_assoc                 : 1;</span><br><span class="line">        uintptr_t has_cxx_dtor              : 1;</span><br><span class="line">        uintptr_t shiftcls                  : 33;</span><br><span class="line">        uintptr_t magic                     : 6;</span><br><span class="line">        uintptr_t weakly_referenced         : 1;</span><br><span class="line">        uintptr_t deallocating              : 1;</span><br><span class="line">        uintptr_t has_sidetable_rc          : 1;</span><br><span class="line">        uintptr_t extra_rc                  : 19;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="isa详解-位域"><a href="#isa详解-位域" class="headerlink" title="isa详解 - 位域"></a>isa详解 - 位域</h3><ul><li>nonpointer<ul><li>0，代表普通的指针，存储着Class、Meta-Class对象的内存地址</li><li>1，代表优化过，使用位域存储更多的信息</li></ul></li><li>has_assoc<ul><li>是否有设置过关联对象，如果没有，释放时会更快</li></ul></li><li>has_cxx_dtor<ul><li>是否有C++的析构函数（.cxx_destruct），如果没有，释放时会更快</li></ul></li><li>shiftcls<ul><li>存储着Class、Meta-Class对象的内存地址信息</li></ul></li><li>magic<ul><li>用于在调试时分辨对象是否未完成初始化</li></ul></li><li>weakly_referenced<ul><li>是否有被弱引用指向过，如果没有，释放时会更快</li></ul></li><li>deallocating<ul><li>对象是否正在释放</li></ul></li><li>extra_rc<ul><li>里面存储的值是引用计数器减1</li></ul></li><li>has_sidetable_rc<ul><li>引用计数器是否过大无法存储在isa中</li><li>如果为1，那么引用计数会存储在一个叫SideTable的类的属性中</li></ul></li></ul><h2 id="Class的结构"><a href="#Class的结构" class="headerlink" title="Class的结构"></a>Class的结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct objc_object &#123;</span><br><span class="line">private:</span><br><span class="line">    isa_t isa;</span><br><span class="line">public:</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">&#125;</span><br><span class="line">struct objc_class : objc_object &#123;</span><br><span class="line">    // Class ISA;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;            // 方法缓存</span><br><span class="line">    class_data_bits_t bits;  // 用于获取具体的类信息  &amp;FAST_DATA_MASK</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>bits &amp;FAST_DATA_MASK，可以得到class_rw_t</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct class_rw_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t version;</span><br><span class="line">    const class_ro_t *ro;</span><br><span class="line">    method_array_t methods;      //方法列表</span><br><span class="line">    property_array_t properties; //属性列表</span><br><span class="line">    protocol_array_t protocols;  //协议列表</span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line">    char *demangledName;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>class_ro_t的内容如下：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct class_ro_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t instanceStart;</span><br><span class="line">    uint32_t instanceSize;  // instance对象占用的内存空间</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    uint32_t reserved;</span><br><span class="line">#endif</span><br><span class="line">    const uint8_t * ivarLayout;</span><br><span class="line">    const char * name;// 类名</span><br><span class="line">    method_list_t * baseMethodList;</span><br><span class="line">    protocol_list_t * baseProtocols;</span><br><span class="line">    const ivar_list_t * ivars;//成员变量列表</span><br><span class="line">    const uint8_t * weakIvarLayout;</span><br><span class="line">    property_list_t *baseProperties;</span><br><span class="line">    method_list_t *baseMethods() const &#123;</span><br><span class="line">        return baseMethodList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="class-rw-t"><a href="#class-rw-t" class="headerlink" title="class_rw_t"></a>class_rw_t</h3><blockquote><p>class_rw_t里面的methos, properties, protocols是二维数组，是可读可写的，包含了类的初始内容、分类的内容</p><ul><li>methods里面包含多个method_list_t</li><li>method_list_t里面包含多个method_t</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method_array_t methods; -&gt; method_list_t -&gt; method_t</span><br></pre></td></tr></table></figure><h3 id="class-ro-t"><a href="#class-ro-t" class="headerlink" title="class_ro_t"></a>class_ro_t</h3><blockquote><p>class_ro_t里面的baseMethodList，baseProtocols，ivars，baseProperties是一维数组，是只读的，包含了类的初始内容</p><ul><li>baseMethodList里面包含多个method_t</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method_list_t * baseMethodList; -&gt; method_t</span><br></pre></td></tr></table></figure><h3 id="method-t"><a href="#method-t" class="headerlink" title="method_t"></a>method_t</h3><blockquote><p>method_t是对方法&#x2F;函数的封装</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct method_t &#123;</span><br><span class="line">    SEL name;   //函数名</span><br><span class="line">    const char *types;  //编码（返回值类型、参数类型）</span><br><span class="line">    IMP imp;    //指向函数的指针（函数地址）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>IMP代表函数的具体表现</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...);</span><br></pre></td></tr></table></figure><blockquote><p>SEL代表方法&#x2F;函数名，一般叫做选择器，底层结构跟char*类似</p><ul><li>可以通过@selector()和sel_registerName()获得</li><li>可以通过sel_getName()和NSStringFromSelector()转成字符串</li><li>不同类中相同名字的方法，所对应的方法选择器是相同的</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_selector *SEL;</span><br></pre></td></tr></table></figure><blockquote><p>types包含了函数返回值、参数编码的字符串</p></blockquote><h3 id="cache-t-方法缓存"><a href="#cache-t-方法缓存" class="headerlink" title="cache_t - 方法缓存"></a>cache_t - 方法缓存</h3><blockquote><p>Class内部结构中有个方法缓存（cache_t），用散列表（哈希表）来缓存曾经调用过的方法，可以提高方法的查找速度</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct cache_t &#123;</span><br><span class="line">    struct bucket_t *_buckets;//散列表</span><br><span class="line">    mask_t _mask;//散列表的长度 -1</span><br><span class="line">    mask_t _occupied;//已经缓存的方法数量</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    struct bucket_t *buckets();</span><br><span class="line">    mask_t mask();</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>_buckets里面存放着许多bucket_t，bucket_t结构如下：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct bucket_t &#123;</span><br><span class="line">private:</span><br><span class="line">    cache_key_t _key;// SEL作为key</span><br><span class="line">    IMP _imp;//函数的内存地址</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    inline cache_key_t key() const &#123; return _key; &#125;</span><br><span class="line">    inline IMP imp() const &#123; return (IMP)_imp; &#125;</span><br><span class="line">    inline void setKey(cache_key_t newKey) &#123; _key = newKey; &#125;</span><br><span class="line">    inline void setImp(IMP newImp) &#123; _imp = newImp; &#125;</span><br><span class="line"></span><br><span class="line">    void set(cache_key_t newKey, IMP newImp);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>缓存查找，利用空间换时间的缓存机制<br>objc-cache.mm文件<br>bucket_t * cache_t::find(cache_key_t k, id receiver)</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">bucket_t * cache_t::find(cache_key_t k, id receiver)</span><br><span class="line">&#123;</span><br><span class="line">    assert(k != 0);</span><br><span class="line"></span><br><span class="line">    bucket_t *b = buckets();</span><br><span class="line">    mask_t m = mask();</span><br><span class="line">    mask_t begin = cache_hash(k, m);</span><br><span class="line">    mask_t i = begin;</span><br><span class="line">    do &#123;</span><br><span class="line">        if (b[i].key() == 0  ||  b[i].key() == k) &#123;</span><br><span class="line">            return &amp;b[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while ((i = cache_next(i, m)) != begin);</span><br><span class="line"></span><br><span class="line">    // hack</span><br><span class="line">    Class cls = (Class)((uintptr_t)this - offsetof(objc_class, cache));</span><br><span class="line">    cache_t::bad_cache(receiver, (SEL)k, cls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Object-C是一门动态性比较强的编程语言，跟C，C++等语言有着很大的不同&lt;/li&gt;
&lt;li&gt;Object-C的动态性是由R</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Objective-C" scheme="http://www.hxtec.top/tags/Objective-C/"/>
    
    <category term="底层原理" scheme="http://www.hxtec.top/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    <category term="Runtime" scheme="http://www.hxtec.top/tags/Runtime/"/>
    
  </entry>
  
  <entry>
    <title>Swift-响应式编程</title>
    <link href="http://www.hxtec.top/2022/09/19/Swift-%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>http://www.hxtec.top/2022/09/19/Swift-%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/</id>
    <published>2022-09-19T03:05:44.000Z</published>
    <updated>2022-09-19T04:09:18.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>响应式编程（Reactive Programming, 简称RP）<ul><li>一种编程范式，于1997年提出，可以简化异步编程，提供更优雅的数据绑定</li><li>一般与函数式融合在一起，所以也会叫做：函数响应式编程（Functional Reactive Programming, 简称FRP）</li></ul></li><li>比较著名的、成熟的响应式编程<ul><li>ReactiveCocoa，简称RAC，有OC，Swift版本<ul><li>官网： <a href="http://reactivecocoa.io/">http://reactivecocoa.io/</a></li><li>github：<a href="https://github.com/ReactiveCocoa">https://github.com/ReactiveCocoa</a></li></ul></li><li>ReactiveX，简称Rx，有众多编程语言版本，比如：RxJava, RxKotlin, RxJS, RxCpp, RxPHP, RxGo, RxSwift等等.<ul><li>官网：<a href="http://reactivex.io/">http://reactivex.io/</a></li><li>github： <a href="https://github.com/ReactiveX">https://github.com/ReactiveX</a></li></ul></li></ul></li></ul><h3 id="RxSwift"><a href="#RxSwift" class="headerlink" title="RxSwift"></a>RxSwift</h3><ul><li>RxSwift(ReactiveX for Swift)，ReactiveX的Swift版本<ul><li>源码：<a href="https://github.com/ReactiveX/RxSwift">https://github.com/ReactiveX/RxSwift</a></li><li>中文文档： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/">https://beeth0ven.github.io/RxSwift-Chinese-Documentation/</a></li></ul></li><li>模块说明<ul><li>RxSwift：Rx标准API的Swift实现，不包括任何iOS相关的内容</li><li>RxCocoa：基于RxSwift，给iOS UI控件扩展了很多Rx特性</li></ul></li></ul><h3 id="RxSwift的核心角色"><a href="#RxSwift的核心角色" class="headerlink" title="RxSwift的核心角色"></a>RxSwift的核心角色</h3><ul><li>Observable：负责发送事件（Event）</li><li>Observer：负责订阅Observable，监听Observable发送的事件（Event）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public enum Event&lt;Element&gt; &#123;</span><br><span class="line">    /// Next element is produced.</span><br><span class="line">    case next(Element)</span><br><span class="line">    </span><br><span class="line">    /// Sequence terminated with an error.</span><br><span class="line">    case error(Swift.Error)</span><br><span class="line">    </span><br><span class="line">    /// Sequence completed successfully.</span><br><span class="line">    case completed</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li>Event有3种 <ul><li>next：携带具体数据</li><li>error：携带错误信息，表明Observable终止，不会再发出事件</li><li>completed：表明Observable终止，不会再发出事件</li></ul></li></ul><blockquote><p>创建、订阅Observable示例1</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">var observable = Observable&lt;Int&gt;.create &#123; observer in</span><br><span class="line">    observer.onNext(1)</span><br><span class="line">    observer.onCompleted()</span><br><span class="line">    return Disposables.create()</span><br><span class="line">&#125;</span><br><span class="line">// 等价于</span><br><span class="line">observable = Observable.just(1)</span><br><span class="line">observable = Observable.of(1)</span><br><span class="line">observable = Observable.from([1])</span><br><span class="line"></span><br><span class="line">var observable = Observable&lt;Int&gt;.create &#123; observer in</span><br><span class="line">    observer.onNext(1)</span><br><span class="line">    observer.onNext(2)</span><br><span class="line">    observer.onNext(3)</span><br><span class="line">    observer.onCompleted()</span><br><span class="line">    return Disposables.create()</span><br><span class="line">&#125;</span><br><span class="line">// 等价于</span><br><span class="line">observable = Observable.of(1, 2, 3)</span><br><span class="line">observable = Observable.from([1, 2, 3])</span><br><span class="line"></span><br><span class="line">observable.subscribe &#123; event in</span><br><span class="line">    print(event)</span><br><span class="line">&#125;.dispose()</span><br><span class="line"></span><br><span class="line">observable.subscribe(onNext: &#123;</span><br><span class="line">    print(&quot;next&quot;, $0)</span><br><span class="line">&#125;, onError: &#123;</span><br><span class="line">    print(&quot;error&quot;, $0)</span><br><span class="line">&#125;, onCompleted: &#123;</span><br><span class="line">    print(&quot;completed&quot;)</span><br><span class="line">&#125;, onDisposed: &#123;</span><br><span class="line">    print(&quot;dispose&quot;)</span><br><span class="line">&#125;).dispose()</span><br></pre></td></tr></table></figure><blockquote><p>创建、订阅Observable示例1</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let observable = Observable&lt;Int&gt;.timer(.seconds(3),</span><br><span class="line">                                       period: .seconds(1),</span><br><span class="line">                                       scheduler: MainScheduler.instance)</span><br><span class="line">                                       </span><br><span class="line">observable.map &#123; &quot;数值是\($0)&quot; &#125; </span><br><span class="line">          .bind(to: label.rx.text) </span><br><span class="line">          .disposed(by: bag)</span><br></pre></td></tr></table></figure><h3 id="创建Observer"><a href="#创建Observer" class="headerlink" title="创建Observer"></a>创建Observer</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let observer = AnyObserver&lt;Int&gt;.init &#123; event in</span><br><span class="line">    switch event &#123;</span><br><span class="line">    case .next(let data):</span><br><span class="line">        print(data)</span><br><span class="line">    case .completed:</span><br><span class="line">        print(&quot;completed&quot;)</span><br><span class="line">    case .error(let error):</span><br><span class="line">        print(&quot;error&quot;, error)</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">Observable.just(1).subscribe(observer).dispose()</span><br><span class="line"></span><br><span class="line">let binder = Binder&lt;String&gt;(label) &#123; label, text in</span><br><span class="line">    label.text = text</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Observable.just(1).map &#123; &quot;数值是\($0)&quot; &#125;.subscribe(binder).dispose()</span><br><span class="line">//Observable.just(1).map &#123; &quot;数值是\($0)&quot; &#125;.bind(to: binder).dispose()</span><br></pre></td></tr></table></figure><h3 id="扩展Binder属性"><a href="#扩展Binder属性" class="headerlink" title="扩展Binder属性"></a>扩展Binder属性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">extension Reactive where Base: UIView &#123;</span><br><span class="line">    var hidden: Binder&lt;Bool&gt; &#123;</span><br><span class="line">        Binder&lt;Bool&gt;(base) &#123; view, value in</span><br><span class="line">        view.isHidden = value</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let observable = Observable&lt;Int&gt;.interval(.seconds(1),</span><br><span class="line">                                          scheduler: MainScheduler.instance)</span><br><span class="line">observable.map &#123; $0 % 2 == 0 &#125;.bind(to: button.rx.hidden).disposed(by: bag)</span><br></pre></td></tr></table></figure><h3 id="传统的状态监听"><a href="#传统的状态监听" class="headerlink" title="传统的状态监听"></a>传统的状态监听</h3><ul><li>在开发中经常要对各种状态进行监听，传统的常见监听方案有：<ul><li>KVO</li><li>Target-Action</li><li>Notification</li><li>Delegate</li><li>Block Callback</li></ul></li><li>传统文字经常会出现错综复杂的依赖关系、耦合性较高，还需要编写重复的非业务代码</li></ul><blockquote><p>RxSwift的状态监听示例1：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//按钮点击</span><br><span class="line">button.rx.tap.subscribe(onNext: &#123;</span><br><span class="line">    print(&quot;按钮被点击了1&quot;)</span><br><span class="line">&#125;).disposed(by: bag)</span><br><span class="line"></span><br><span class="line">//数据绑定到Cell</span><br><span class="line">let data = Observable.just([</span><br><span class="line">    Person(name: &quot;Jack&quot;, age: 10),</span><br><span class="line">    Person(name: &quot;Rose&quot;, age: 20)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">data.bind(to: tableView.rx.items(cellIdentifier: &quot;cell&quot;)) &#123; row, person, cell in</span><br><span class="line">    cell.textLabel?.text = person.name</span><br><span class="line">    cell.detailTextLabel?.text = &quot;\(person.age)&quot;</span><br><span class="line">&#125;.disposed(by: bag)</span><br><span class="line"></span><br><span class="line">tableView.rx.modelSelected(Person.self) .subscribe(onNext: &#123; person in</span><br><span class="line">    print(&quot;点击了&quot;, person.name)</span><br><span class="line">&#125;).disposed(by: bag)</span><br></pre></td></tr></table></figure><blockquote><p>RxSwift的状态监听示例2：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Dog: NSObject &#123;</span><br><span class="line">    @objc dynamic var name: String? </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dog.rx.observe(String.self, &quot;name&quot;) .subscribe(onNext: &#123; name in</span><br><span class="line">    print(&quot;name is&quot;, name ?? &quot;nil&quot;)</span><br><span class="line">&#125;).disposed(by: bag)</span><br><span class="line"></span><br><span class="line">dog.name = &quot;larry&quot;</span><br><span class="line">dog.name = &quot;wangwang&quot;</span><br><span class="line"></span><br><span class="line">NotificationCenter.default.rx.notification(UIApplication.didEnterBackgroundNotification).subscribe(onNext: &#123; notification in</span><br><span class="line">    print(&quot;APP进入后台&quot;, notification)</span><br><span class="line">&#125;).disposed(by: bag)</span><br></pre></td></tr></table></figure><h3 id="既是Observable，又是Observer"><a href="#既是Observable，又是Observer" class="headerlink" title="既是Observable，又是Observer"></a>既是Observable，又是Observer</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(0.8).bind(to: slider.rx.value).dispose()</span><br><span class="line"></span><br><span class="line">slider.rx.value.map &#123; </span><br><span class="line">    &quot;当前数值是：\($0)&quot;</span><br><span class="line">&#125;.bind(to: textField.rx.text).disposed(by: bag)</span><br><span class="line"></span><br><span class="line">textField.rx.text.subscribe(onNext: &#123; text in</span><br><span class="line">    print(&quot;text is&quot;, text ?? &quot;nil&quot;)</span><br><span class="line">&#125;).disposed(by: bag)</span><br></pre></td></tr></table></figure><ul><li>诸如UISlider.rx.value、UTextField.rx.text这类属性值，既是Observable，又是Observer<ul><li>它们是RxCocoa.ControlProperty类型</li></ul></li></ul><h3 id="Disposable"><a href="#Disposable" class="headerlink" title="Disposable"></a>Disposable</h3><ul><li>每当Observable被订阅时，都会返回一个Disposable实例，当调用Disposable的dispose，就相当于取消订阅</li><li>在不需要再接收事件时，建议取消订阅，释放资源。有3种常见方式取消订阅<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 立即取消订阅（一次性订阅）</span><br><span class="line">observable.subscribe &#123; event in</span><br><span class="line">    print(event)</span><br><span class="line">&#125;.dispose()</span><br><span class="line"></span><br><span class="line">// 当bag销毁（deinit）时，会自动调用Disposable实例的dispose</span><br><span class="line">observable.subscribe &#123; event in</span><br><span class="line">    print(event)</span><br><span class="line">&#125;.disposed(by: bag)</span><br><span class="line"></span><br><span class="line">// self销毁时（deinit）时，会自动调用Disposable实例的dispose</span><br><span class="line">let _ = observable.takeUntil(self.rx.deallocated).subscribe &#123; event in</span><br><span class="line">    print(event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;响应式编程（Reactive Programming, 简称RP）&lt;ul&gt;
&lt;li&gt;一种编程范式，于1997年提出，可以简化异步</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Swift" scheme="http://www.hxtec.top/tags/Swift/"/>
    
    <category term="语法" scheme="http://www.hxtec.top/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Swift-面向协议编程</title>
    <link href="http://www.hxtec.top/2022/09/19/Swift-%E9%9D%A2%E5%90%91%E5%8D%8F%E8%AE%AE%E7%BC%96%E7%A8%8B/"/>
    <id>http://www.hxtec.top/2022/09/19/Swift-%E9%9D%A2%E5%90%91%E5%8D%8F%E8%AE%AE%E7%BC%96%E7%A8%8B/</id>
    <published>2022-09-19T03:05:34.000Z</published>
    <updated>2022-09-19T04:10:34.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>面向协议编程（Protocol Oriented Programming, 简称POP）<ul><li>是Swift的一种编程范式，Apple于2015年WWDC提出</li><li>在Swift标准库中，能见到大量POP的影子</li></ul></li><li>同时，Swift也是一门面向对象的编程语言（Object Oriented Programming, 简称OOP）</li><li>在Swift开发中，OOP和POP是相辅相成的，任何一方并不能取代另一方</li><li>POP能弥补OOP一些设计上的不足</li></ul><h3 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h3><ul><li>OOP的三大特性：封装，继承，多态</li><li>继承的经典使用场合：</li><li>当多个类（比如A, B, C类）具有很多共性时，可以将这些共性抽取到一个父类中（比如D类），最后A, B, C类继承D类</li></ul><h3 id="OOP的缺点"><a href="#OOP的缺点" class="headerlink" title="OOP的缺点"></a>OOP的缺点</h3><ul><li>比如，如何将下面BVC, DVC的公共方法run抽取出来？<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class BVC: UIViewController &#123;</span><br><span class="line">    func run() &#123;</span><br><span class="line">        print(&quot;run&quot;) </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DVC: UITableViewController &#123;</span><br><span class="line">    func run() &#123;</span><br><span class="line">        print(&quot;run&quot;) </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>基于OOP想到的一些解决方案：<ol><li>将run方法放到另一个对象A中，然后BVC, DVC拥有对象A的属性，此时，多了一些额外的依赖关系</li><li>将run方法增加到UIViewController分类中，不过UIViewController会越来越臃肿，而且会影响它的其他所有子类</li><li>将run方法抽取到新的父类，采用多继承，会增加程序设计复杂度，产生菱形继承等问题，需要开发者额外解决</li></ol></li></ul><blockquote><p>解决方案：通过协议的方式</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protocol Runnable &#123;</span><br><span class="line">    func run()</span><br><span class="line">&#125;</span><br><span class="line">extension Runnable &#123;</span><br><span class="line">    func run() &#123;</span><br><span class="line">        print(&quot;run&quot;) </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BVC: UIViewController, Runnable &#123;&#125;</span><br><span class="line">class DVC: UITableViewController, Runnable &#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>POP的注意点</p><ul><li>优先考虑创建协议，而不是父类（基类）</li><li>优先考虑值类型（struct, enum），而不是引用类型（class）</li><li>巧用协议的扩展功能</li><li>不要为了面向协议而使用协议</li></ul></blockquote><h3 id="利用协议实现前辍效果"><a href="#利用协议实现前辍效果" class="headerlink" title="利用协议实现前辍效果"></a>利用协议实现前辍效果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">struct HX&lt;Base&gt; &#123;</span><br><span class="line">    let base: Base</span><br><span class="line">    init(_ base: Base) &#123;</span><br><span class="line">        self.base = base</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol HXCompatible &#123;&#125;</span><br><span class="line">extension HXCompatible &#123;</span><br><span class="line">    static var hx: HX&lt;Self&gt;.Type &#123;</span><br><span class="line">        get &#123; HX&lt;Self&gt;.self &#125;</span><br><span class="line">        set &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var hx: HX&lt;Self&gt; &#123;</span><br><span class="line">        get &#123; HX(self) &#125;</span><br><span class="line">        set &#123;&#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//对系统库进行扩展</span><br><span class="line">extension String: HXCompatible &#123;&#125;</span><br><span class="line">extension HX where Base == String &#123;</span><br><span class="line">    func numberCount() -&gt; Int &#123;</span><br><span class="line">        var count = 0</span><br><span class="line">        for c in base where (&quot;0&quot;...&quot;9&quot;).contains(c) &#123;</span><br><span class="line">            count += 1 </span><br><span class="line">        &#125;</span><br><span class="line">    return count</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用</span><br><span class="line">var string = &quot;123fdsf434&quot;</span><br><span class="line">print(string.hx.numberCount())</span><br></pre></td></tr></table></figure><blockquote><p>示例1：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;&#125;</span><br><span class="line">class Student: Person &#123;&#125;</span><br><span class="line"></span><br><span class="line">extension Person: HXCompatible &#123;&#125;</span><br><span class="line">extension HX where Base: Person &#123;</span><br><span class="line">    func run() &#123;&#125;</span><br><span class="line">    static func test() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.hx.test()</span><br><span class="line">Student.hx.test()</span><br><span class="line"></span><br><span class="line">let p = Person()</span><br><span class="line">p.hx.run()</span><br><span class="line"></span><br><span class="line">let s = Student()</span><br><span class="line">s.hx.run()</span><br></pre></td></tr></table></figure><blockquote><p>示例2：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//对Sting, NSString进行扩展</span><br><span class="line">extension String: HXCompatible &#123;&#125;</span><br><span class="line">extension NSString: HXCompatible &#123;&#125;</span><br><span class="line">extension HX where Base: ExpressibleByStringLiteral &#123;</span><br><span class="line">    func numberCount() -&gt; Int &#123;</span><br><span class="line">        let string = base as! String</span><br><span class="line">        var count = 0</span><br><span class="line">        for c in string where (&quot;0&quot;...&quot;9&quot;).contains(c) &#123;</span><br><span class="line">            count += 1 </span><br><span class="line">        &#125;</span><br><span class="line">        return count</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var s1: String = &quot;123fdsf434&quot;</span><br><span class="line">var s2: NSString = &quot;123fdsf434&quot;</span><br><span class="line">var s3: NSMutableString = &quot;123fdsf434&quot;</span><br><span class="line">print(s1.hx.numberCount())</span><br><span class="line">print(s2.hx.numberCount())</span><br><span class="line">print(s3.hx.numberCount())</span><br></pre></td></tr></table></figure><h3 id="利用协议实现类型判断"><a href="#利用协议实现类型判断" class="headerlink" title="利用协议实现类型判断"></a>利用协议实现类型判断</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//普通判断数组方法</span><br><span class="line">func isArray(_ value: Any) -&gt; Bool &#123; value is [Any] &#125;</span><br><span class="line">isArray( [1, 2] )</span><br><span class="line">isArray( [&quot;1&quot;, 2] )</span><br><span class="line">isArray( NSArray() )</span><br><span class="line">isArray( NSMutableArray() )</span><br><span class="line"></span><br><span class="line">//对Array, NSArray进行扩展方法</span><br><span class="line">protocol ArrayType &#123;&#125;</span><br><span class="line">extension Array: ArrayType &#123;&#125;</span><br><span class="line">extension NSArray: ArrayType &#123;&#125;</span><br><span class="line">func isArrayType(_ type: Any.Type) -&gt; Bool &#123; type is ArrayType.Type &#125;</span><br><span class="line"></span><br><span class="line">isArrayType([Int].self)</span><br><span class="line">isArrayType([Any].self)</span><br><span class="line">isArrayType(NSArray.self)</span><br><span class="line">isArrayType(NSMutableArray.self)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;面向协议编程（Protocol Oriented Programming, 简称POP）&lt;ul&gt;
&lt;li&gt;是Swift的一种编程</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Swift" scheme="http://www.hxtec.top/tags/Swift/"/>
    
    <category term="语法" scheme="http://www.hxtec.top/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Swift-函数式编程</title>
    <link href="http://www.hxtec.top/2022/09/19/Swift-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>http://www.hxtec.top/2022/09/19/Swift-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</id>
    <published>2022-09-19T03:05:24.000Z</published>
    <updated>2022-09-19T04:05:53.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>函数式编程（Funtional Programming，简称FP）是一种编程范式，也就是如何编写程序的方法论<ul><li>主要思想：把计算过程尽量分解成一系列可复用函数的调用</li><li>主要特征：函数是“第一等公民”</li><li>函数与其他数据类型一样的地位，可以赋值给其他变量，也可以作为函数参数、函数返回值</li></ul></li><li>函数式编程最早出现在LISP语言，绝大部分的现代编程语言也对函数式编程做了不同程序的支持，比如：<ul><li>Haskkell, JavaScript, Python, Swift, Kotlin, Scale等</li></ul></li><li>函数式编程中几个常用的概念：<ul><li>Higher-Order Function, Function Curring</li><li>Functor, Applicative Functor, Monad</li></ul></li></ul><h3 id="FP实践"><a href="#FP实践" class="headerlink" title="FP实践"></a>FP实践</h3><blockquote><p>传统写法</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 假设要实现以下功能：[(num + 3) * 5 - 1] % 10 / 2</span><br><span class="line">var num = 1</span><br><span class="line"></span><br><span class="line">func add(_ v1: Int, _ v2: Int) -&gt; Int &#123; v1 + v2 &#125;</span><br><span class="line">func sub(_ v1: Int, _ v2: Int) -&gt; Int &#123; v1 - v2 &#125;</span><br><span class="line">func multiple(_ v1: Int, _ v2: Int) -&gt; Int &#123; v1 * v2 &#125;</span><br><span class="line">func divide(_ v1: Int, _ v2: Int) -&gt; Int &#123; v1 / v2 &#125;</span><br><span class="line">func mod(_ v1: Int, _ v2: Int) -&gt; Int &#123; v1 % v2 &#125;</span><br><span class="line"></span><br><span class="line">divide(mod(sub(multiple(add(num, 3), 5), 1), 10), 2)</span><br></pre></td></tr></table></figure><blockquote><p>函数式写法</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 假设要实现以下功能：[(num + 3) * 5 - 1] % 10 / 2</span><br><span class="line"></span><br><span class="line">func add(_ v: Int) -&gt; (Int) -&gt; Int &#123; &#123; $0 + v &#125; &#125;</span><br><span class="line">func sub(_ v: Int) -&gt; (Int) -&gt; Int &#123; &#123; $0 - v &#125; &#125;</span><br><span class="line">func multiple(_ v: Int) -&gt; (Int) -&gt; Int &#123; &#123; $0 * v &#125; &#125;</span><br><span class="line">func divide(_ v: Int) -&gt; (Int) -&gt; Int &#123; &#123; $0 / v &#125; &#125;</span><br><span class="line">func mod(_ v: Int) -&gt; (Int) -&gt; Int &#123; &#123; $0 % v &#125; &#125;</span><br><span class="line"></span><br><span class="line">infix operator &gt;&gt;&gt; : AdditionPrecedence</span><br><span class="line"></span><br><span class="line">func &gt;&gt;&gt;&lt;A, B, C&gt;(_ f1: @escaping (A) -&gt; B, </span><br><span class="line">                  _ f2: @escaping (B) -&gt; C) -&gt; (A) -&gt; C &#123; &#123; f2(f1($0)) &#125; &#125;</span><br><span class="line">                  </span><br><span class="line">var fn = add(3) &gt;&gt;&gt; multiple(5) &gt;&gt;&gt; sub(1) &gt;&gt;&gt; mod(10) &gt;&gt;&gt; divide(2)</span><br><span class="line"></span><br><span class="line">fn(num)</span><br></pre></td></tr></table></figure><h3 id="高阶函数（Higher-Order-Function）"><a href="#高阶函数（Higher-Order-Function）" class="headerlink" title="高阶函数（Higher-Order-Function）"></a>高阶函数（Higher-Order-Function）</h3><ul><li>高阶函数是至少满足下列一个条件的函数：<ul><li>接受一个或多个函数作为输入（map, filter, reduce等）</li><li>返回一个函数</li></ul></li><li>FP中到处都是高阶函数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func add(_ v: Int) -&gt; (Int) -&gt; Int &#123; &#123; $0 + v &#125; &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="柯里化（Curring）"><a href="#柯里化（Curring）" class="headerlink" title="柯里化（Curring）"></a>柯里化（Curring）</h3><ul><li>定义</li><li>将一个接受多个参数的函数变换为一系列只接受单个参数的函数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func add(_ v1: Int, _ v2: Int) -&gt; Int &#123; v1 + v2 &#125;</span><br><span class="line">add(10, 20)</span><br><span class="line"></span><br><span class="line">-&gt; 变换为下面</span><br><span class="line">func add(_ v: Int) -&gt; (Int) -&gt; Int &#123; &#123; $0 + v &#125; &#125;</span><br><span class="line">add(10)(20)</span><br></pre></td></tr></table></figure></li><li>Array, Optional的map方法接收的参数就是一个柯里化函数<blockquote><p>示例1</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func add1(_ v1: Int, _ v2: Int) -&gt; Int &#123; v1 + v2 &#125;</span><br><span class="line">func add2(_ v1: Int, _ v2: Int, _ v3: Int) -&gt; Int &#123; v1 + v2 + v3 &#125;</span><br><span class="line"></span><br><span class="line">func currying&lt;A, B, C&gt;(_ fn: @escaping (A, B) -&gt; C) -&gt; (B) -&gt; (A) -&gt; C &#123;</span><br><span class="line">    &#123; b in &#123; a in fn(a, b) &#125; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func currying&lt;A, B, C, D&gt;(_ fn: @escaping (A, B, C) -&gt; D) -&gt; (C) -&gt; (B) -&gt; (A) -&gt; D &#123;</span><br><span class="line">    &#123; c in &#123; b in &#123; a in fn(a, b, c) &#125; &#125; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let curriedAdd1 = currying(add1)</span><br><span class="line">print(curriedAdd1(10)(20))</span><br><span class="line"></span><br><span class="line">let curriedAdd2 = currying(add2)</span><br><span class="line">print(curriedAdd2(10)(20)(30))</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>示例2</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 假设要实现以下功能：[(num + 3) * 5 - 1] % 10 / 2</span><br><span class="line"></span><br><span class="line">func add(_ v1: Int, _ v2: Int) -&gt; Int &#123; v1 + v2 &#125;</span><br><span class="line">func sub(_ v1: Int, _ v2: Int) -&gt; Int &#123; v1 - v2 &#125;</span><br><span class="line">func multiple(_ v1: Int, _ v2: Int) -&gt; Int &#123; v1 * v2 &#125;</span><br><span class="line">func divide(_ v1: Int, _ v2: Int) -&gt; Int &#123; v1 / v2 &#125;</span><br><span class="line">func mod(_ v1: Int, _ v2: Int) -&gt; Int &#123; v1 % v2 &#125;</span><br><span class="line"></span><br><span class="line">//柯里化函数</span><br><span class="line">prefix func ~&lt;A, B, C&gt;(_ fn: @escaping (A, B) -&gt; C) -&gt; (B) -&gt; (A) -&gt; C &#123; &#123; b in &#123; a in fn(a, b) &#125; &#125; &#125;</span><br><span class="line"></span><br><span class="line">//自定义运算符</span><br><span class="line">infix operator &gt;&gt;&gt; : AdditionPrecedence</span><br><span class="line">func &gt;&gt;&gt;&lt;A, B, C&gt;(_ f1: @escaping (A) -&gt; B,</span><br><span class="line">                  _ f2: @escaping (B) -&gt; C) -&gt; (A) -&gt; C &#123; &#123; f2(f1($0)) &#125; &#125;</span><br><span class="line"></span><br><span class="line">var num = 1</span><br><span class="line">var fn = (~add)(3) &gt;&gt;&gt; (~multiple)(5) &gt;&gt;&gt; (~sub)(1) &gt;&gt;&gt; (~mod)(10) &gt;&gt;&gt; (~divide)(2)</span><br><span class="line">fn(num)</span><br></pre></td></tr></table></figure><h3 id="函子（Functor）"><a href="#函子（Functor）" class="headerlink" title="函子（Functor）"></a>函子（Functor）</h3><ul><li>像Array, Optional这样支持map运算的类型，称为函子（Functor）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Array&lt;Element&gt;</span><br><span class="line">public func map&lt;T&gt;(_ transform: (Element) -&gt; T) -&gt; Array&lt;T&gt;</span><br><span class="line"></span><br><span class="line">// Optional&lt;Wrapped&gt;</span><br><span class="line">public func map&lt;U&gt;(_ transform: (Wrapped) -&gt; U) -&gt; Optional&lt;U&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="适用函子（Applicative-Functor"><a href="#适用函子（Applicative-Functor" class="headerlink" title="适用函子（Applicative Functor"></a>适用函子（Applicative Functor</h3><ul><li><p>对任意一个函子 F，如果能支持以下运算，该函子就是一个适用函子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func pure&lt;A&gt;(_ value: A) -&gt; F&lt;A&gt;</span><br><span class="line">func &lt;*&gt;&lt;A, B&gt;(fn: F&lt;(A) -&gt; B&gt;, value: F&lt;A&gt;) -&gt; F&lt;B&gt;</span><br></pre></td></tr></table></figure></li><li><p>Optional可以成为适用函子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func pure&lt;A&gt;(_ value: A) -&gt; A? &#123; value &#125;</span><br><span class="line">infix operator &lt;*&gt; : AdditionPrecedence</span><br><span class="line">func &lt;*&gt;&lt;A, B&gt;(fn: ((A) -&gt; B)?, value: A?) -&gt; B? &#123;</span><br><span class="line">    guard let f = fn, let v = value else &#123; return nil &#125;</span><br><span class="line">    return f(v)</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">var value: Int? = 10</span><br><span class="line">var fn: ((Int) -&gt; Int)? = &#123; $0 * 2&#125;</span><br><span class="line">// Optional(20)</span><br><span class="line">print(fn &lt;*&gt; value as Any)</span><br></pre></td></tr></table></figure></li><li><p>Array可以成为适用函子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func pure&lt;A&gt;(_ value: A) -&gt; [A] &#123; [value] &#125;</span><br><span class="line">infix operator &lt;*&gt; : AdditionPrecedence</span><br><span class="line">func &lt;*&gt;&lt;A, B&gt;(fn: [(A) -&gt; B], value: [A]) -&gt; [B] &#123;</span><br><span class="line">    var arr: [B] = []</span><br><span class="line">    if fn.count == value.count &#123;</span><br><span class="line">        for i in fn.startIndex..&lt;fn.endIndex &#123;</span><br><span class="line">            arr.append(fn[i](value[i]))</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// [10]</span><br><span class="line">print(pure(10))</span><br><span class="line">var arr = [&#123; $0 * 2&#125;, &#123; $0 + 10 &#125;, &#123; $0 - 5 &#125;] &lt;*&gt; [1, 2, 3]</span><br><span class="line">// [2, 12, -2]</span><br><span class="line">print(arr)</span><br></pre></td></tr></table></figure></li></ul><h3 id="单子（Monad）"><a href="#单子（Monad）" class="headerlink" title="单子（Monad）"></a>单子（Monad）</h3><ul><li>对任意一个类型 F，如果能支持以下运算，那么就可以称为是一个单子（Monad）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func pure&lt;A&gt;(_ value: A) -&gt; F&lt;A&gt;</span><br><span class="line">func flatMap&lt;A, B&gt;(_ value: F&lt;A&gt;, _ fn: (A) -&gt; F&lt;B&gt;) -&gt; F&lt;B&gt;</span><br></pre></td></tr></table></figure></li><li>Array、Optional都是单子</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;函数式编程（Funtional Programming，简称FP）是一种编程范式，也就是如何编写程序的方法论&lt;ul&gt;
&lt;li&gt;主</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Swift" scheme="http://www.hxtec.top/tags/Swift/"/>
    
    <category term="语法" scheme="http://www.hxtec.top/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Swift-从OC到Swift 二</title>
    <link href="http://www.hxtec.top/2022/09/19/Swift-%E4%BB%8EOC%E5%88%B0Swift-%E4%BA%8C/"/>
    <id>http://www.hxtec.top/2022/09/19/Swift-%E4%BB%8EOC%E5%88%B0Swift-%E4%BA%8C/</id>
    <published>2022-09-19T03:05:10.000Z</published>
    <updated>2022-09-19T04:03:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="KVC-x2F-KVO"><a href="#KVC-x2F-KVO" class="headerlink" title="KVC&#x2F;KVO"></a>KVC&#x2F;KVO</h2><ul><li>Swift 支持KVC&#x2F;KVO的条件<ul><li>属性所在的类、监听器最终继承自 NSObject</li><li>用 @objc dynamic 修饰对应的属性</li></ul></li></ul><h3 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 监听器</span><br><span class="line">class Observer: NSObject &#123;</span><br><span class="line">    override func observeValue(forKeyPath keyPath: String?,</span><br><span class="line">                                of object: Any?,</span><br><span class="line">                                change: [NSKeyValueChangeKey : Any]?,</span><br><span class="line">                                context: UnsafeMutableRawPointer?) &#123;</span><br><span class="line">        print(&quot;observeValue&quot;, change?[.newKey] as Any) </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 类</span><br><span class="line">class Person: NSObject &#123;</span><br><span class="line">    @objc dynamic var age: Int = 0</span><br><span class="line">    var observer: Observer = Observer()</span><br><span class="line">    override init() &#123;</span><br><span class="line">        super.init()</span><br><span class="line">        self.addObserver(observer,</span><br><span class="line">                        forKeyPath: &quot;age&quot;,</span><br><span class="line">                        options: .new,</span><br><span class="line">                        context: nil) </span><br><span class="line">    &#125;</span><br><span class="line">    deinit &#123;</span><br><span class="line">        self.removeObserver(observer,</span><br><span class="line">                            forKeyPath: &quot;age&quot;) </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = Person()</span><br><span class="line">// observeValue Optional(20)</span><br><span class="line">p.age = 20</span><br><span class="line">// observeValue Optional(25)</span><br><span class="line">p.setValue(25, forKey: &quot;age&quot;)</span><br></pre></td></tr></table></figure><h3 id="block方式的KVO"><a href="#block方式的KVO" class="headerlink" title="block方式的KVO"></a>block方式的KVO</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Person: NSObject &#123;</span><br><span class="line">    @objc dynamic var age: Int = 0</span><br><span class="line">    var observation: NSKeyValueObservation?</span><br><span class="line">    override init() &#123;</span><br><span class="line">        super.init()</span><br><span class="line">        observation = observe(\Person.age, options: .new) &#123;</span><br><span class="line">            (person, change) in</span><br><span class="line">            print(change.newValue as Any) </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = Person()</span><br><span class="line">// Optional(20)</span><br><span class="line">p.age = 20</span><br><span class="line">// Optional(25)</span><br><span class="line">p.setValue(25, forKey: &quot;age&quot;)</span><br></pre></td></tr></table></figure><h2 id="关联对象（Associated-Object）"><a href="#关联对象（Associated-Object）" class="headerlink" title="关联对象（Associated Object）"></a>关联对象（Associated Object）</h2><ul><li>在Swift中，class依然可以使用关联对象<ul><li>默认情况，extension不可以增加存储属性</li><li>借助关联对象，可以实现类似extension为class增加存储属性的效果</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;&#125;</span><br><span class="line"></span><br><span class="line">extension Person &#123;</span><br><span class="line">    private static var AGE_KEY: Void?</span><br><span class="line">    var age: Int &#123;</span><br><span class="line">        get &#123;(objc_getAssociatedObject(self, &amp;Self.AGE_KEY) as? Int) ?? 0 &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">            objc_setAssociatedObject(self, </span><br><span class="line">                                    &amp;Self.AGE_KEY,</span><br><span class="line">                                    newValue,</span><br><span class="line">                                    .OBJC_ASSOCIATION_ASSIGN) </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = Person()</span><br><span class="line">print(p.age) // 0</span><br><span class="line">p.age = 10</span><br><span class="line">print(p.age) // 10</span><br></pre></td></tr></table></figure><h2 id="资源名管理"><a href="#资源名管理" class="headerlink" title="资源名管理"></a>资源名管理</h2><ul><li>参考Android的资源名管理方式</li></ul><blockquote><p>改善前</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let img = UIImage(named: &quot;logo&quot;)</span><br><span class="line"></span><br><span class="line">let btn = UIButton(type: .custom)</span><br><span class="line">btn.setTitle(&quot;添加&quot;, for: .normal)</span><br><span class="line"></span><br><span class="line">performSegue(withIdentifier: &quot;login_main&quot;, sender: self)</span><br></pre></td></tr></table></figure><blockquote><p>改善后</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//枚举封装</span><br><span class="line">enum R &#123;</span><br><span class="line">    enum string: String &#123;</span><br><span class="line">        case add = &quot;添加&quot; </span><br><span class="line">    &#125;</span><br><span class="line">    enum image: String &#123;</span><br><span class="line">        case logo</span><br><span class="line">    &#125;</span><br><span class="line">    enum segue: String &#123;</span><br><span class="line">        case login_main</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 扩展</span><br><span class="line">extension UIImage &#123;</span><br><span class="line">    convenience init?(_ name: R.image) &#123;</span><br><span class="line">        self.init(named: name.rawValue) </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension UIButton &#123;</span><br><span class="line">    func setTitle(_ title: R.string, for state: UIControl.State) &#123;</span><br><span class="line">        setTitle(title.rawValue, for: state)</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension UIViewController &#123;</span><br><span class="line">    func performSegue(withIdentifier identifier: R.segue, sender: Any?) &#123;</span><br><span class="line">        performSegue(withIdentifier: identifier.rawValue, sender: sender)</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用</span><br><span class="line">let img = UIImage(R.image.logo)</span><br><span class="line"></span><br><span class="line">let btn = UIButton(type: .custom)</span><br><span class="line">btn.setTitle(R.string.add, for: .normal)</span><br><span class="line"></span><br><span class="line">performSegue(withIdentifier: R.segue.login_main, sender: self)</span><br></pre></td></tr></table></figure><h3 id="资源名管理的其他思路"><a href="#资源名管理的其他思路" class="headerlink" title="资源名管理的其他思路"></a>资源名管理的其他思路</h3><blockquote><p>优化前</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let img = UIImage(named: &quot;logo&quot;)</span><br><span class="line"></span><br><span class="line">let font = UIFont(name: &quot;Arial&quot;, size: 14)</span><br></pre></td></tr></table></figure><blockquote><p>优化后</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//枚举进行封装</span><br><span class="line">enum R &#123;</span><br><span class="line">    enum image &#123;</span><br><span class="line">        static var logo = UIImage(named: &quot;logo&quot;) </span><br><span class="line">    &#125;</span><br><span class="line">    enum font &#123;</span><br><span class="line">        static func arial(_ size: CGFloat) -&gt; UIFont? &#123;</span><br><span class="line">            UIFont(name: &quot;Arial&quot;, size: size)</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let img = R.image.logo</span><br><span class="line"></span><br><span class="line">let font = R.font.arial(14)</span><br></pre></td></tr></table></figure><ul><li>更多优秀的思路参考<ul><li><a href="https://github.com/mac-cain13/R.swift">https://github.com/mac-cain13/R.swift</a></li><li><a href="https://github.com/SwiftGen/SwiftGen">https://github.com/SwiftGen/SwiftGen</a></li></ul></li></ul><h2 id="多线程开发-异步"><a href="#多线程开发-异步" class="headerlink" title="多线程开发 - 异步"></a>多线程开发 - 异步</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public typealias Task = () -&gt; Void</span><br><span class="line"></span><br><span class="line">struct Async &#123;</span><br><span class="line">    //子线程开辟任务</span><br><span class="line">     public static func async(_ task: @escaping Task) &#123;</span><br><span class="line">        _async(task)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //子线程任务完成之后，回到主线程执行任务</span><br><span class="line">    public static func async(_ task: @escaping Task, _ mainTask: @escaping Task) &#123;</span><br><span class="line">        _async(task, mainTask)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private static func _async(_ task: @escaping Task, </span><br><span class="line">                                _ mainTask: Task? = nil) &#123;</span><br><span class="line">        let item = DispatchWorkItem(block: task)</span><br><span class="line">        DispatchQueue.global().async(execute: item)</span><br><span class="line">        if let main = mainTask &#123;</span><br><span class="line">            item.notify(queue: DispatchQueue.main, execute: main)</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多线程开发-异步延迟"><a href="#多线程开发-异步延迟" class="headerlink" title="多线程开发 - 异步延迟"></a>多线程开发 - 异步延迟</h3><blockquote><p>一般用法</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@discardableResult //忽略返回值</span><br><span class="line">public static func delay(_ seconds: Double, _ block: @escaping Task) -&gt; DispatchWorkItem &#123;</span><br><span class="line">    let item = DispatchWorkItem(block: block)</span><br><span class="line">    DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + seconds,</span><br><span class="line">                                execute: item)</span><br><span class="line">    return item</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>封装使用</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@discardableResult</span><br><span class="line">public static func asyncDelay(_ seconds: Double, _ task: @escaping Task) -&gt; DispatchWorkItem &#123;</span><br><span class="line">    return _asyncDelay(seconds, task)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@discardableResult</span><br><span class="line">public static func asyncDelay(_ seconds: Double, _ task: @escaping Task, _ mainTask: @escaping Task) -&gt; DispatchWorkItem &#123;</span><br><span class="line">    return _asyncDelay(seconds, task, mainTask)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static func _asyncDelay(_ seconds: Double,  </span><br><span class="line">                                _ task: @escaping Task, </span><br><span class="line">                                _ mainTask: Task? = nil) -&gt; DispatchWorkItem &#123;</span><br><span class="line">    let item = DispatchWorkItem(block: task)</span><br><span class="line">    DispatchQueue.global().asyncAfter(deadline: DispatchTime.now() + seconds,</span><br><span class="line">                                    execute: item)</span><br><span class="line">    if let main = mainTask &#123;</span><br><span class="line">        item.notify(queue: DispatchQueue.main, execute: main)</span><br><span class="line">    &#125;</span><br><span class="line">    return item</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多线程开发-once"><a href="#多线程开发-once" class="headerlink" title="多线程开发 - once"></a>多线程开发 - once</h3><ul><li>dispatch_once在Swift中已被废弃，取而代之 <ul><li>以用类型属性或者全局变量\常量</li><li>默认自带 lazy + dispatch_once 效果<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fileprivate let initTask2: Void = &#123;</span><br><span class="line">    print(&quot;initTask2---------&quot;)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">class ViewController: UIViewController &#123;</span><br><span class="line">    static let initTask1: Void = &#123;</span><br><span class="line">        print(&quot;initTask1---------&quot;)</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        let _ = Self.initTask1</span><br><span class="line">        </span><br><span class="line">        let _ = initTask2</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="多线程开发-加锁"><a href="#多线程开发-加锁" class="headerlink" title="多线程开发 - 加锁"></a>多线程开发 - 加锁</h3><ul><li>gcd信号量<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Cache &#123;</span><br><span class="line">    private static var data = [String: Any]()</span><br><span class="line">    private static var lock = DispatchSemaphore(value: 1)</span><br><span class="line">    static func set(_ key: String, _ value: Any) &#123;</span><br><span class="line">        lock.wait()</span><br><span class="line">        defer &#123; lock.signal() &#125;</span><br><span class="line">        data[key] = value</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Foundation<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//正常加锁</span><br><span class="line">private static var lock = NSLock()</span><br><span class="line">    static func set(_ key: String, _ value: Any) &#123;</span><br><span class="line">        lock.lock()</span><br><span class="line">        defer &#123; lock.unlock() &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 递归锁</span><br><span class="line">private static var lock = NSRecursiveLock()</span><br><span class="line">    static func set(_ key: String, _ value: Any) &#123;</span><br><span class="line">        lock.lock()</span><br><span class="line">        defer &#123; lock.unlock() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;KVC-x2F-KVO&quot;&gt;&lt;a href=&quot;#KVC-x2F-KVO&quot; class=&quot;headerlink&quot; title=&quot;KVC&amp;#x2F;KVO&quot;&gt;&lt;/a&gt;KVC&amp;#x2F;KVO&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Swift 支持KVC&amp;#x2F;KVO的条件&lt;ul</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Swift" scheme="http://www.hxtec.top/tags/Swift/"/>
    
    <category term="语法" scheme="http://www.hxtec.top/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Swift-从OC到Swift 一</title>
    <link href="http://www.hxtec.top/2022/09/19/Swift-%E4%BB%8EOC%E5%88%B0Swift-%E4%B8%80/"/>
    <id>http://www.hxtec.top/2022/09/19/Swift-%E4%BB%8EOC%E5%88%B0Swift-%E4%B8%80/</id>
    <published>2022-09-19T03:04:58.000Z</published>
    <updated>2022-09-19T03:58:03.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="MARK-TODO-FIXME"><a href="#MARK-TODO-FIXME" class="headerlink" title="MARK, TODO, FIXME"></a>MARK, TODO, FIXME</h4><ul><li>&#x2F;&#x2F;MARK: 类似于OC中的 #pragma mark</li><li>&#x2F;&#x2F;MARK: - 类似于OC中的 #pragma mark - </li><li>&#x2F;&#x2F;TODO:用于标记未完成的任务</li><li>&#x2F;&#x2F;FIXME:用于标记待修复的问题</li></ul><h4 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 操作系统：macOS\iOS\tvOS\watchOS\Linux\Android\Windows\FreeBSD</span><br><span class="line">#if os(macOS) || os(iOS)</span><br><span class="line">// CPU架构：i386\x86_64\arm\arm64</span><br><span class="line">#elseif arch(x86_64) || arch(arm64)</span><br><span class="line">// swift版本</span><br><span class="line">#elseif swift(&lt;5) &amp;&amp; swift(&gt;=3)</span><br><span class="line">// 模拟器</span><br><span class="line">#elseif targetEnvironment(simulator)</span><br><span class="line">// 可以导入某模块</span><br><span class="line">#elseif canImport(Foundation)</span><br><span class="line">#else</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">// debug模式</span><br><span class="line">#if DEBUG</span><br><span class="line"></span><br><span class="line">// release模式</span><br><span class="line">#else</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">// 自定义</span><br><span class="line">#if TEST</span><br><span class="line">print(&quot;test&quot;)</span><br><span class="line">#endif</span><br><span class="line">#if OTHER</span><br><span class="line">print(&quot;other&quot;)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h4 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//自定义Log输出格式</span><br><span class="line">func log&lt;T&gt;(_ msg: T,</span><br><span class="line">    file: NSString = #file,</span><br><span class="line">    line: Int = #line,</span><br><span class="line">    fn: String = #function) &#123;</span><br><span class="line">        #if DEBUG</span><br><span class="line">        let prefix = &quot;\(file.lastPathComponent)_\(line)_\(fn):&quot;</span><br><span class="line">        print(prefix, msg)</span><br><span class="line">        #endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="系统版本检测"><a href="#系统版本检测" class="headerlink" title="系统版本检测"></a>系统版本检测</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 对于iOS平台，只在iOS10及以上版本执行</span><br><span class="line">// 对于macOS平台，只在macOS 10.12及以上版本执行</span><br><span class="line">// 最后的*表示在其他所有平台都执行</span><br><span class="line">if #available(iOS 10, macOS 10.12, *) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="API可用性说明"><a href="#API可用性说明" class="headerlink" title="API可用性说明"></a>API可用性说明</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@available(iOS 10, macOS 10.15, *)</span><br><span class="line">class Person &#123;&#125;</span><br><span class="line"></span><br><span class="line">struct Student &#123;</span><br><span class="line">    @available(*, unavailable, renamed: &quot;study&quot;)</span><br><span class="line">    func study_() &#123;&#125;</span><br><span class="line">    func study() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    @available(iOS, deprecated: 11)</span><br><span class="line">    @available(macOS, deprecated: 10.12)</span><br><span class="line">    func run() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="iOS程序的入口"><a href="#iOS程序的入口" class="headerlink" title="iOS程序的入口"></a>iOS程序的入口</h4><ul><li>在AppDelegate上面默认有个@UIApplicationMain标记，这表示<ul><li>编译器自动生成入口代码（main函数代码），自动设置AppDelegate为APP的代理</li></ul></li><li>也可以删掉@UIApplicationMain，自定义入口代码：新建一个main.swift文件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line"></span><br><span class="line">class MyApplication: UIApplication &#123; &#125;</span><br><span class="line"></span><br><span class="line">UIApplicationMain(CommandLine.argc,</span><br><span class="line">                  CommandLine.unsafeArgv,</span><br><span class="line">                  NSStringFromClass(MyApplication.self),</span><br><span class="line">                  NSStringFromClass(AppDelegate.self))</span><br></pre></td></tr></table></figure></li></ul><h4 id="Swift调用OC"><a href="#Swift调用OC" class="headerlink" title="Swift调用OC"></a>Swift调用OC</h4><ul><li>新建1个桥接头文件，文件名格式默认为：**{targetName}-Bridging-Header.h**</li><li>在  <code>&#123;targetName&#125;-Bridging-Header.h </code> 文件中 #import OC需要暴露给Swift的内容<ul><li>TARGETS -&gt; Build Settings -&gt; briding<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;***.h&quot;</span><br><span class="line">#import &quot;***.h&quot;</span><br><span class="line">#import &quot;***.h&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p>示例</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">//Person.h文件</span><br><span class="line">int sum(int a, int b);</span><br><span class="line"></span><br><span class="line">@interface Person : NSObject</span><br><span class="line">@property (nonatomic, assign) NSInteger age;</span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithAge:(NSInteger)age name:(NSString *)name;</span><br><span class="line">+ (instancetype)personWithAge:(NSInteger)age name:(NSString *)name;</span><br><span class="line"></span><br><span class="line">- (void)run;</span><br><span class="line">+ (void)run;</span><br><span class="line"></span><br><span class="line">- (void)eat:(NSString *)food other:(NSString *)other;</span><br><span class="line">+ (void)eat:(NSString *)food other:(NSString *)other;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//Person.m文件</span><br><span class="line">#import Person.h</span><br><span class="line">@end</span><br><span class="line">@implementation Person</span><br><span class="line">- (instancetype)initWithAge:(NSInteger)age name:(NSString *)name &#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        self.age = age;</span><br><span class="line">        self.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    return self; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (instancetype)personWithAge:(NSInteger)age name:(NSString *)name &#123;</span><br><span class="line">    return [[self alloc] initWithAge:age name:name];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)run &#123; NSLog(@&quot;Person +run&quot;); &#125; </span><br><span class="line">- (void)run &#123; NSLog(@&quot;%zd %@ -run&quot;, _age, _name); &#125;</span><br><span class="line"></span><br><span class="line">+ (void)eat:(NSString *)food other:(NSString *)other &#123; NSLog(@&quot;Person +eat %@ %@&quot;, food, other); &#125; </span><br><span class="line">- (void)eat:(NSString *)food other:(NSString *)other &#123; NSLog(@&quot;%zd %@ -eat %@ %@&quot;, _age, _name, food, other); &#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">int sum(int a, int b) &#123; return a + b; &#125;</span><br><span class="line"></span><br><span class="line">//Swift文件中使用Person类</span><br><span class="line">var p = Person(age: 10, name: &quot;Jack&quot;) p.age = 18</span><br><span class="line">p.name = &quot;Rose&quot;</span><br><span class="line">p.run() // 18 Rose -run</span><br><span class="line">p.eat(&quot;Apple&quot;, other: &quot;Water&quot;) // 18 Rose -eat Apple Water</span><br><span class="line"></span><br><span class="line">Person.run() // Person +run</span><br><span class="line">Person.eat(&quot;Pizza&quot;, other: &quot;Banana&quot;) // Person +eat Pizza Banana</span><br><span class="line"></span><br><span class="line">print(sum(10, 20)) // 30</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="Swift调用OC-–-silgen-name"><a href="#Swift调用OC-–-silgen-name" class="headerlink" title="Swift调用OC – @_silgen_name"></a>Swift调用OC – @_silgen_name</h4><ul><li>如果C语言暴露给Swift的函数名跟Swift中的其他函数名冲突了<ul><li>可以在Swift中使用 @_silgen_name 修改C函数名<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// C语言</span><br><span class="line">int sum(int a, int b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Swift</span><br><span class="line">@_silgen_name(&quot;sum&quot;) func swift_sum(_ v1: Int32, _ v2: Int32) -&gt; Int32</span><br><span class="line">print(swift_sum(10, 20)) // 30</span><br><span class="line"></span><br><span class="line">print(sum(10, 20)) // 30</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="OC调用Swift"><a href="#OC调用Swift" class="headerlink" title="OC调用Swift"></a>OC调用Swift</h4><ul><li><p>Xcode已经默认生成一个用于OC调用Swift的头文件，文件名格式是：   <code>&#123;targetName&#125;-Swift.h </code></p><ul><li>TARGETS -&gt; Build Settings -&gt; generated interface</li></ul></li><li><p>Swift暴露给OC的类最终继承自NSObject</p></li><li><p>使用  <code>@objc </code> 修饰需要暴露给OC的成员</p></li><li><p>使用  <code>@objcMembers </code> 修饰类</p><ul><li>代表默认所有成员都会暴露给OC（包括扩展中定义的成员）</li><li>最终是否成功暴露，还需要考虑成员自身的访问级别<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import Foundation</span><br><span class="line"></span><br><span class="line">@objcMembers class Car: NSObject &#123;</span><br><span class="line">    var price: Double</span><br><span class="line">    var band: String</span><br><span class="line">    init(price: Double, band: String) &#123;</span><br><span class="line">        self.price = price</span><br><span class="line">        self.band = band</span><br><span class="line">    &#125;</span><br><span class="line">    func run() &#123; print(price, band, &quot;run&quot;) &#125;</span><br><span class="line">    static func run() &#123; print(&quot;Car run&quot;) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension Car &#123;</span><br><span class="line">    func test() &#123; print(price, band, &quot;test&quot;) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//对应转化生成的OC代码如下：</span><br><span class="line">@interface Car : NSObject</span><br><span class="line">@property (nonatomic) double price;</span><br><span class="line">@property (nonatomic, copy) NSString * _Nonnull band;</span><br><span class="line">- (nonnull instancetype)initWithPrice:(double)price band:(NSString * _Nonnull)band OBJC_DESIGNATED_INITIALIZER; - (void)run;</span><br><span class="line">+ (void)run;</span><br><span class="line">- (nonnull instancetype)init SWIFT_UNAVAILABLE;</span><br><span class="line">+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG(&quot;-init is unavailable&quot;);</span><br><span class="line">@end</span><br><span class="line">//扩展</span><br><span class="line">@interface Car (SWIFT_EXTENSION(_Swift))</span><br><span class="line">- (void)test;</span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>OC调用Swift，OC文件中的代码示例：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;_Swift-Swift.h&quot;</span><br><span class="line">int sum(int a, int b) &#123;</span><br><span class="line">    Car *c = [[Car alloc] initWithPrice:10.5 band:@&quot;BMW&quot;];</span><br><span class="line">    c.band = @&quot;Bently&quot;;</span><br><span class="line">    c.price = 108.5;</span><br><span class="line">    [c run]; // 108.5 Bently run</span><br><span class="line">    [c test]; // 108.5 Bently test</span><br><span class="line">    [Car run]; // Car run</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="OC调用Swift-–-objc"><a href="#OC调用Swift-–-objc" class="headerlink" title="OC调用Swift –  @objc "></a>OC调用Swift –  <code>@objc </code></h4><ul><li>可以通过  <code>@objc </code> 重命名Swift暴露给OC的符号名（类名、属性名、函数名等）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@objc(MyCar)</span><br><span class="line">@objcMembers class Car: NSObject &#123;</span><br><span class="line">    var price: Double</span><br><span class="line">    @objc(name)</span><br><span class="line">    var band: String</span><br><span class="line">    init(price: Double, band: String) &#123;</span><br><span class="line">        self.price = price</span><br><span class="line">        self.band = band</span><br><span class="line">    &#125;</span><br><span class="line">    @objc(drive)</span><br><span class="line">    func run() &#123; print(price, band, &quot;run&quot;) &#125;</span><br><span class="line">    static func run() &#123; print(&quot;Car run&quot;) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension Car &#123;</span><br><span class="line">    @objc(exec:v2:)</span><br><span class="line">    func test() &#123; print(price, band, &quot;test&quot;) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyCar *c = [[MyCar alloc] initWithPrice:10.5 band:@&quot;BMW&quot;];</span><br><span class="line">c.name = @&quot;Bently&quot;;</span><br><span class="line">c.price = 108.5;</span><br><span class="line">[c drive]; // 108.5 Bently run</span><br><span class="line">[c exec:10 v2:20]; // 108.5 Bently test</span><br><span class="line">[MyCar run]; // Car run</span><br></pre></td></tr></table></figure></li></ul><h4 id="选择器（Selector）"><a href="#选择器（Selector）" class="headerlink" title="选择器（Selector）"></a>选择器（Selector）</h4><ul><li>Swift中依然可以使用选择器，使用  <code>#selector(name) </code> 定义一个选择器</li><li>必须是被  <code>@objcMembers </code> 或  <code>@objc </code> 修饰的方法才可以定义选择器<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@objcMembers class Person: NSObject &#123;</span><br><span class="line">    func test1(v1: Int) &#123; print(&quot;test1&quot;) &#125;</span><br><span class="line">    func test2(v1: Int, v2: Int) &#123; print(&quot;test2(v1:v2:)&quot;) &#125;</span><br><span class="line">    func test2(_ v1: Double, _ v2: Double) &#123; print(&quot;test2(_:_:)&quot;) &#125;</span><br><span class="line">    func run() &#123;</span><br><span class="line">        perform(#selector(test1))</span><br><span class="line">        perform(#selector(test1(v1:)))</span><br><span class="line">        perform(#selector(test2(v1:v2:)))</span><br><span class="line">        perform(#selector(test2(_:_:)))</span><br><span class="line">        perform(#selector(test2 as (Double, Double) -&gt; Void))</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="只能被Class继承的协议"><a href="#只能被Class继承的协议" class="headerlink" title="只能被Class继承的协议"></a>只能被Class继承的协议</h4><ul><li>@objc 修饰的协议，还可以暴露给OC去遵守实现<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protocol Runnable1: AnyObject &#123;&#125;</span><br><span class="line"></span><br><span class="line">protocol Runnable2: class &#123;&#125;</span><br><span class="line"></span><br><span class="line">@objc protocol Runnable3 &#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="可选协议"><a href="#可选协议" class="headerlink" title="可选协议"></a>可选协议</h4><ul><li>可以通过 @objc 定义可选协议，这种协议只能被 class 遵守<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@objc protocol Runnable &#123;</span><br><span class="line">    func run1()</span><br><span class="line">    @objc optional func run2()</span><br><span class="line">    func run3()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog: Runnable &#123;</span><br><span class="line">    func run3() &#123; print(&quot;Dog run3&quot;) &#125;</span><br><span class="line">    func run1() &#123; print(&quot;Dog run1&quot;) &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var d = Dog()</span><br><span class="line">d.run1() // Dog run1</span><br><span class="line">d.run3() // Dog run3</span><br></pre></td></tr></table></figure></li></ul><h4 id="dynamic"><a href="#dynamic" class="headerlink" title="dynamic"></a>dynamic</h4><ul><li>被 @objc dynamic 修饰的内容会具有动态性，比如调用方法会走 runtime 那一套流程<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Dog: NSObject &#123;</span><br><span class="line">@objc dynamic func test1() &#123;&#125;</span><br><span class="line">func test2() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">var d = Dog()</span><br><span class="line">d.test1()</span><br><span class="line">d.test2()</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;MARK-TODO-FIXME&quot;&gt;&lt;a href=&quot;#MARK-TODO-FIXME&quot; class=&quot;headerlink&quot; title=&quot;MARK, TODO, FIXME&quot;&gt;&lt;/a&gt;MARK, TODO, FIXME&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&amp;#x2F;&amp;#</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Swift" scheme="http://www.hxtec.top/tags/Swift/"/>
    
    <category term="语法" scheme="http://www.hxtec.top/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Swift-Array的常见操作</title>
    <link href="http://www.hxtec.top/2022/09/19/Swift-Array%E7%9A%84%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/"/>
    <id>http://www.hxtec.top/2022/09/19/Swift-Array%E7%9A%84%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/</id>
    <published>2022-09-19T03:04:36.000Z</published>
    <updated>2022-09-19T03:55:19.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="map-filter-reduce-flatMap-compactMap"><a href="#map-filter-reduce-flatMap-compactMap" class="headerlink" title="map, filter, reduce, flatMap, compactMap"></a>map, filter, reduce, flatMap, compactMap</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4]</span><br><span class="line">// [2, 4, 6, 8]</span><br><span class="line">var arr2 = arr.map &#123; $0 * 2 &#125;</span><br><span class="line"></span><br><span class="line">// [2, 4]</span><br><span class="line">var arr3 = arr.filter &#123; $0 % 2 == 0 &#125;</span><br><span class="line"></span><br><span class="line">// 10</span><br><span class="line">var arr4 = arr.reduce(0) &#123; $0 + $1 &#125;</span><br><span class="line">// 10</span><br><span class="line">var arr5 = arr.reduce(0, +)</span><br><span class="line"></span><br><span class="line">func double(_ i: Int) -&gt; Int &#123; i * 2 &#125;</span><br><span class="line">var arr = [1, 2, 3, 4]</span><br><span class="line">// [2, 4, 6, 8]</span><br><span class="line">print(arr.map(double))</span><br><span class="line"></span><br><span class="line">var arr = [1, 2, 3]</span><br><span class="line">// [[1], [2, 2], [3, 3, 3]]</span><br><span class="line">var arr2 = arr.map &#123; Array.init(repeating: $0, count: $0) &#125;</span><br><span class="line"></span><br><span class="line">// [1, 2, 2, 3, 3, 3]</span><br><span class="line">var arr3 = arr.flatMap &#123; Array.init(repeating: $0, count: $0) &#125;</span><br><span class="line"></span><br><span class="line">var arr = [&quot;123&quot;, &quot;test&quot;, &quot;jack&quot;, &quot;-30&quot;]</span><br><span class="line">// [Optional(123), nil, nil, Optional(-30)]</span><br><span class="line">var arr2 = arr.map &#123; Int($0) &#125;</span><br><span class="line">// [123, -30]</span><br><span class="line">var arr3 = arr.compactMap &#123; Int($0) &#125;</span><br><span class="line"></span><br><span class="line">// 使用reduce实现map、filter的功能</span><br><span class="line">var arr = [1, 2, 3, 4]</span><br><span class="line">// [2, 4, 6, 8]</span><br><span class="line">print(arr.map &#123; $0 * 2 &#125;)</span><br><span class="line">print(arr.reduce([]) &#123; $0 + [$1 * 2] &#125;)</span><br><span class="line"></span><br><span class="line">// [2, 4]</span><br><span class="line">print(arr.filter &#123; $0 % 2 == 0 &#125;)</span><br><span class="line">print(arr.reduce([]) &#123; $1 % 2 == 0 ? $0 + [$1] : $0 &#125;)</span><br></pre></td></tr></table></figure><h3 id="lazy的优化"><a href="#lazy的优化" class="headerlink" title="lazy的优化"></a>lazy的优化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, 3]</span><br><span class="line">let result = arr.lazy.map &#123;</span><br><span class="line">    (i: Int) -&gt; Int in</span><br><span class="line">    print(&quot;mapping \(i)&quot;)</span><br><span class="line">    return i * 2 </span><br><span class="line">&#125;</span><br><span class="line">print(&quot;begin-----&quot;)</span><br><span class="line">print(&quot;mapped&quot;, result[0])</span><br><span class="line">print(&quot;mapped&quot;, result[1])</span><br><span class="line">print(&quot;mapped&quot;, result[2])</span><br><span class="line">print(&quot;end----&quot;)</span><br><span class="line"></span><br><span class="line">begin-----</span><br><span class="line">mapping 1</span><br><span class="line">mapped 2</span><br><span class="line">mapping 2</span><br><span class="line">mapped 4</span><br><span class="line">mapping 3</span><br><span class="line">mapped 6</span><br><span class="line">end----</span><br></pre></td></tr></table></figure><h3 id="Optional的map和flatMap"><a href="#Optional的map和flatMap" class="headerlink" title="Optional的map和flatMap"></a>Optional的map和flatMap</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">var num1: Int? = 10</span><br><span class="line">// Optional(20)</span><br><span class="line">var num2 = num1.map &#123; $0 * 2 &#125;</span><br><span class="line">var num3: Int? = nil</span><br><span class="line">// nil</span><br><span class="line">var num4 = num3.map &#123; $0 * 2 &#125;</span><br><span class="line"></span><br><span class="line">var num1: Int? = 10</span><br><span class="line">// Optional(Optional(20))</span><br><span class="line">var num2 = num1.map &#123; Optional.some($0 * 2) &#125;</span><br><span class="line">// Optional(20)</span><br><span class="line">var num3 = num1.flatMap &#123; Optional.some($0 * 2) &#125;</span><br><span class="line"></span><br><span class="line">var num1: Int? = 10</span><br><span class="line">// num2、num3是等价的</span><br><span class="line">var num2 = (num1 != nil) ? (num1! + 10) : nil</span><br><span class="line">var num3 = num1.map &#123; $0 + 10 &#125;</span><br><span class="line"></span><br><span class="line">var fmt = DateFormatter()</span><br><span class="line">fmt.dateFormat = &quot;yyyy-MM-dd&quot;</span><br><span class="line">var str: String? = &quot;2011-09-10&quot;</span><br><span class="line">// old</span><br><span class="line">var date1 = str != nil ? fmt.date(from: str!) : nil</span><br><span class="line">// new</span><br><span class="line">var date2 = str.flatMap(fmt.date)</span><br><span class="line"></span><br><span class="line">var score: Int? = 98</span><br><span class="line">// old</span><br><span class="line">var str1 = score != nil ? &quot;socre is \(score!)&quot; : &quot;No score&quot;</span><br><span class="line">// new</span><br><span class="line">var str2 = score.map &#123; &quot;score is \($0)&quot; &#125; ?? &quot;No score&quot;</span><br></pre></td></tr></table></figure><blockquote><p>示例1</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct Person &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    var age: Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var items = [</span><br><span class="line">    Person(name: &quot;jack&quot;, age: 20),</span><br><span class="line">    Person(name: &quot;rose&quot;, age: 21),</span><br><span class="line">    Person(name: &quot;kate&quot;, age: 22) </span><br><span class="line">]</span><br><span class="line">// old</span><br><span class="line">func getPerson1(_ name: String) -&gt; Person? &#123;</span><br><span class="line">    let index = items.firstIndex &#123; $0.name == name &#125;</span><br><span class="line">    return index != nil ? items[index!] : nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// new</span><br><span class="line">func getPerson2(_ name: String) -&gt; Person? &#123;</span><br><span class="line">    return items.firstIndex &#123; $0.name == name &#125;.map &#123; items[$0] &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>示例2</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">struct Person &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    var age: Int</span><br><span class="line">    init?(_ json: [String : Any]) &#123;</span><br><span class="line">        guard let name = json[&quot;name&quot;] as? String,</span><br><span class="line">        let age = json[&quot;age&quot;] as? Int else &#123;</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">    self.name = name</span><br><span class="line">    self.age = age</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var json: Dictionary? = [&quot;name&quot; : &quot;Jack&quot;, &quot;age&quot; : 10]</span><br><span class="line">// old</span><br><span class="line">var p1 = json != nil ? Person(json!) : nil</span><br><span class="line"></span><br><span class="line">// new</span><br><span class="line">var p2 = json.flatMap(Person.init)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;map-filter-reduce-flatMap-compactMap&quot;&gt;&lt;a href=&quot;#map-filter-reduce-flatMap-compactMap&quot; class=&quot;headerlink&quot; title=&quot;map, filter, reduce,</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Swift" scheme="http://www.hxtec.top/tags/Swift/"/>
    
    <category term="语法" scheme="http://www.hxtec.top/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Swift-String</title>
    <link href="http://www.hxtec.top/2022/09/19/Swift-String/"/>
    <id>http://www.hxtec.top/2022/09/19/Swift-String/</id>
    <published>2022-09-19T03:04:08.000Z</published>
    <updated>2022-09-19T03:53:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于String的思考"><a href="#关于String的思考" class="headerlink" title="关于String的思考"></a>关于String的思考</h2><ul><li>一个String变量战胜多少内存？</li><li>下面两个String变量，底层存储有什么不同？<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str1 = &quot;0123456789&quot;</span><br><span class="line">var str2 = &quot;0123456789ABCDEF&quot;</span><br></pre></td></tr></table></figure></li><li>如果对String进行拼接操作，String变量的存储会发生什么变化？<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str1.append(&quot;ABCDE&quot;)</span><br><span class="line"></span><br><span class="line">str1.append(&quot;F&quot;)</span><br><span class="line"></span><br><span class="line">str1.append(&quot;G&quot;)</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>分析</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 字符串长度 &lt;= 0xF(16位)，字符串内容直接存放在str1变量的内存中</span><br><span class="line"> var str1 = &quot;0123456789&quot;</span><br><span class="line"> </span><br><span class="line"> // 字符串长度 &gt; 0xF，字符串内容存放在__TEXT.cstring中（常量区）</span><br><span class="line"> // 字符串的地址值信息存放在str2变量的后8个字节中</span><br><span class="line"> var str2 = &quot;0123456789ABCDEF&quot;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> // 由于字符串长度 &lt;= 0xF，所以字符串内容依然存放在str1变量的内存中</span><br><span class="line"> str1.append(&quot;ABCDE&quot;)</span><br><span class="line"> // 开辟堆空间</span><br><span class="line"> str1.append(&quot;F&quot;)</span><br><span class="line"> </span><br><span class="line"> // 开辟堆空间</span><br><span class="line"> str2.append(&quot;G&quot;)</span><br></pre></td></tr></table></figure><h2 id="常规定义"><a href="#常规定义" class="headerlink" title="常规定义"></a>常规定义</h2><ul><li>Swift的字符串类型String，跟OC的NSString，在API设计上还是有较大差异<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 空字符串</span><br><span class="line">var emptyStr1 = &quot;&quot;</span><br><span class="line">var emptyStr2 = String()</span><br><span class="line"></span><br><span class="line">var str: String = &quot;1&quot;</span><br><span class="line">// 拼接，jack_rose</span><br><span class="line">str.append(&quot;_2&quot;)</span><br><span class="line">// 重载运算符 +</span><br><span class="line">str = str + &quot;_3&quot;</span><br><span class="line">// 重载运算符 +=</span><br><span class="line">str += &quot;_4&quot;</span><br><span class="line">// \()插值</span><br><span class="line">str = &quot;\(str)_5&quot;</span><br><span class="line">// 长度，9，1_2_3_4_5</span><br><span class="line">print(str.count)</span><br><span class="line"></span><br><span class="line">var str = &quot;123456&quot;</span><br><span class="line">print(str.hasPrefix(&quot;123&quot;)) // true</span><br><span class="line">print(str.hasSuffix(&quot;456&quot;)) // true</span><br></pre></td></tr></table></figure></li></ul><h3 id="String的插入和删除"><a href="#String的插入和删除" class="headerlink" title="String的插入和删除"></a>String的插入和删除</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;1_2&quot;</span><br><span class="line">// 1_2_</span><br><span class="line">str.insert(&quot;_&quot;, at: str.endIndex)</span><br><span class="line">// 1_2_3_4</span><br><span class="line">str.insert(contentsOf: &quot;3_4&quot;, at: str.endIndex)</span><br><span class="line">// 1666_2_3_4</span><br><span class="line">str.insert(contentsOf: &quot;666&quot;, at: str.index(after: str.startIndex))</span><br><span class="line">// 1666_2_3_8884</span><br><span class="line">str.insert(contentsOf: &quot;888&quot;, at: str.index(before: str.endIndex))</span><br><span class="line">// 1666hello_2_3_8884</span><br><span class="line">str.insert(contentsOf: &quot;hello&quot;, at: str.index(str.startIndex, offsetBy: 4))</span><br><span class="line"></span><br><span class="line">// 666hello_2_3_8884</span><br><span class="line">str.remove(at: str.firstIndex(of: &quot;1&quot;)!)</span><br><span class="line">// hello_2_3_8884</span><br><span class="line">str.removeAll &#123; $0 == &quot;6&quot; &#125;</span><br><span class="line">var range = str.index(str.endIndex, offsetBy: -4)..&lt;str.index(before: str.endIndex)</span><br><span class="line">// hello_2_3_4</span><br><span class="line">str.removeSubrange(range)</span><br></pre></td></tr></table></figure><h3 id="SubSting"><a href="#SubSting" class="headerlink" title="SubSting"></a>SubSting</h3><ul><li>String可以通过下标、prefix、suffix等截取子串，子串类型不是String，而是Substring<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;1_2_3_4_5&quot;</span><br><span class="line">// 1_2</span><br><span class="line">var substr1 = str.prefix(3)</span><br><span class="line">// 4_5</span><br><span class="line">var substr2 = str.suffix(3)</span><br><span class="line">// 1_2</span><br><span class="line">var range = str.startIndex..&lt;str.index(str.startIndex, offsetBy: 3)</span><br><span class="line">var substr3 = str[range]</span><br><span class="line">// 最初的String，1_2_3_4_5</span><br><span class="line">print(substr3.base)</span><br><span class="line">// Substring -&gt; String</span><br><span class="line">var str2 = String(substr3)</span><br></pre></td></tr></table></figure></li><li>Substring和它的base，共享字符串数据</li><li>Substring发生修改 或者 转为String时，会分配新的内存存储字符串数据</li></ul><h3 id="String与Character"><a href="#String与Character" class="headerlink" title="String与Character"></a>String与Character</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for c in &quot;jack&quot; &#123; // c是Character类型</span><br><span class="line">print(c)</span><br><span class="line">&#125;</span><br><span class="line">var str = &quot;jack&quot;</span><br><span class="line">// c是Character类型</span><br><span class="line">var c = str[str.startIndex]</span><br></pre></td></tr></table></figure><h3 id="String相关的协议"><a href="#String相关的协议" class="headerlink" title="String相关的协议"></a>String相关的协议</h3><ul><li>BidirectionalCollection 协议包含的部分内容<ul><li>startIndex、endIndex 属性、index 方法</li><li>String、Array 都遵守了这个协议</li></ul></li><li>RangeReplaceableCollection 协议包含的部分内容<ul><li>append、insert、remove 方法</li><li>String、Array 都遵守了这个协议</li></ul></li><li>Dictionary、Set 也有实现上述协议中声明的一些方法，只是并没有遵守上述协议</li></ul><h3 id="多行String"><a href="#多行String" class="headerlink" title="多行String"></a>多行String</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;&quot;&quot;</span><br><span class="line">1</span><br><span class="line">    &quot;2&quot;</span><br><span class="line">3</span><br><span class="line">    &#x27;4&#x27;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">//输出格式</span><br><span class="line">1</span><br><span class="line">    &quot;2&quot;</span><br><span class="line">3</span><br><span class="line">    &#x27;4&#x27;</span><br><span class="line"></span><br><span class="line">// 如果要显示3引号，至少转义1个引号</span><br><span class="line">let str = &quot;&quot;&quot;</span><br><span class="line">Escaping the first quote \&quot;&quot;&quot;</span><br><span class="line">Escaping two quotes \&quot;\&quot;&quot;</span><br><span class="line">Escaping all three quotes \&quot;\&quot;\&quot;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">Escaping the first quote &quot;&quot;&quot;</span><br><span class="line">Escaping two quotes &quot;&quot;&quot;</span><br><span class="line">Escaping all three quotes &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">// 缩进以结尾的3引号为对齐线</span><br><span class="line">let str = &quot;&quot;&quot;</span><br><span class="line">        1 </span><br><span class="line">            2 </span><br><span class="line">    3</span><br><span class="line">        4</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">//输出格式</span><br><span class="line">        1 </span><br><span class="line">            2</span><br><span class="line">    3 </span><br><span class="line">        4</span><br><span class="line"></span><br><span class="line">// 以下2个字符串是等价的</span><br><span class="line">let str1 = &quot;These are the same.&quot;</span><br><span class="line">let str2 = &quot;&quot;&quot;</span><br><span class="line">These are the same.</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><h3 id="String-与-NSString"><a href="#String-与-NSString" class="headerlink" title="String 与 NSString"></a>String 与 NSString</h3><ul><li>String 与 NSString 之间可以随时随地桥接转换</li><li>如果觉得String的API过于复杂难用，可以考虑将String转为NSString<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var str1: String = &quot;jack&quot;</span><br><span class="line">var str2: NSString = &quot;rose&quot;</span><br><span class="line"></span><br><span class="line">var str3 = str1 as NSString</span><br><span class="line">var str4 = str2 as String</span><br><span class="line"></span><br><span class="line">// ja</span><br><span class="line">var str5 = str3.substring(with: NSRange(location: 0, length: 2))</span><br><span class="line">print(str5) </span><br></pre></td></tr></table></figure></li><li>比较字符串内容是否等价 <ul><li>String使用 &#x3D;&#x3D; 运算符 </li><li>NSString使用isEqual方法，也可以使用 &#x3D;&#x3D; 运算符（本质还是调用了isEqual方法）</li></ul></li></ul><h2 id="Swift、OC桥接转换表"><a href="#Swift、OC桥接转换表" class="headerlink" title="Swift、OC桥接转换表"></a>Swift、OC桥接转换表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String ⇌ NSString</span><br><span class="line">String ← NSMutableString</span><br><span class="line">Array ⇌ NSArray</span><br><span class="line">Array ← NSMutableArray</span><br><span class="line">Dictionary ⇌ NSDictionary</span><br><span class="line">Dictionary ← NSMutableDictionary</span><br><span class="line">Set ⇌ NSSet</span><br><span class="line">Set ← NSMutableSet</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;关于String的思考&quot;&gt;&lt;a href=&quot;#关于String的思考&quot; class=&quot;headerlink&quot; title=&quot;关于String的思考&quot;&gt;&lt;/a&gt;关于String的思考&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;一个String变量战胜多少内存？&lt;/li&gt;
&lt;li&gt;下</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Swift" scheme="http://www.hxtec.top/tags/Swift/"/>
    
    <category term="语法" scheme="http://www.hxtec.top/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Swift-内存管理</title>
    <link href="http://www.hxtec.top/2022/09/19/Swift-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://www.hxtec.top/2022/09/19/Swift-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2022-09-19T03:03:56.000Z</published>
    <updated>2022-09-19T03:50:37.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>跟OC一样，Swift也是采取基于引用计数的ARC内存管理方案（针对堆空间）</li><li>Swfit的ARC中有3各引用<ul><li>强引用（Strong reference）：默认情况下，引用都是强引用</li><li>弱引用（weak reference）：通过weak定义弱引用<ul><li>必须是可选类型的var，因为实例销毁后，ARC会自动将弱引用设置为Nil</li><li>ARC自动给弱引用设置nil时，不会触发属性观察器</li></ul></li><li>无主引用（unowned reference）：通过unowned定义无主引用<ul><li>不会产生强引用，实例销毁后仍然存储着实例的内存地址（类似于OC中的unsafe_unretained）</li><li>试图在实例销毁后访问无主引用，会产生运行时错误（野指针）</li><li><strong>Fatal error: Attempted to read an unowned reference but object 0x0 was already deallocated</strong></li></ul></li></ul></li></ul><h3 id="weak、unowned的使用限制"><a href="#weak、unowned的使用限制" class="headerlink" title="weak、unowned的使用限制"></a>weak、unowned的使用限制</h3><ul><li>weak、owned只能用在类实例上面<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protocol Livable : AnyObject &#123;&#125;</span><br><span class="line">class Person &#123;&#125;</span><br><span class="line"></span><br><span class="line">weak var p0: Person?</span><br><span class="line">weak var p1: AnyObject?</span><br><span class="line">weak var p2: Livable?</span><br><span class="line"></span><br><span class="line">unowned var p10: Person?</span><br><span class="line">unowned var p11: AnyObject?</span><br><span class="line">unowned var p12: Livable?</span><br></pre></td></tr></table></figure></li></ul><h3 id="Autoreleasepool"><a href="#Autoreleasepool" class="headerlink" title="Autoreleasepool"></a>Autoreleasepool</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public func autoreleasepool&lt;Result&gt;(invoking body: () throws -&gt; Result) rethrows -&gt; Result</span><br><span class="line"></span><br><span class="line">autoreleasepool &#123;</span><br><span class="line">    let p = MJPerson(age: 20, name: &quot;Jack&quot;)</span><br><span class="line">    p.run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环引用（Reference-Cycle）"><a href="#循环引用（Reference-Cycle）" class="headerlink" title="循环引用（Reference Cycle）"></a>循环引用（Reference Cycle）</h3><ul><li>weak、unowned 都能解决循环引用的问题， <code>unowned </code> 要比  <code>weak </code> 少一些性能消耗</li><li>在生命周期中可能会变为 nil 的使用 weak</li><li>初始化赋值后再也不会变为 nil 的使用 unowned</li></ul><h3 id="闭包的循环引用"><a href="#闭包的循环引用" class="headerlink" title="闭包的循环引用"></a>闭包的循环引用</h3><ul><li><p>闭包表达式默认会用到的外层对象产生额外的强引用（对外层对象进行了retain操作）</p></li><li><p>正面代码会产生循环引用，导致Person对象无法释放（看不到Persion的deinit被调用）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    var fn: (() -&gt; ())?</span><br><span class="line">    func run() &#123; print(&quot;run&quot;) &#125;</span><br><span class="line">    deinit &#123; print(&quot;deinit&quot;) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func test() &#123;</span><br><span class="line">    let p = Person()</span><br><span class="line">    p.fn = &#123; p.run() &#125;</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br></pre></td></tr></table></figure></li><li><p>在闭包表达式的捕获列表声明weak或unowned引用，解决循环引用问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">p.fn = &#123;</span><br><span class="line">    [weak p] in</span><br><span class="line">    p?.run()//用weak修饰时，要用p?，可选</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p.fn = &#123;</span><br><span class="line">    [unowned p] in</span><br><span class="line">    p.run()//用unowned修饰是，用p， 非可选</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p.fn = &#123;</span><br><span class="line">    [weak wp = p, unowned up = p, a = 10 + 20] in</span><br><span class="line">    wp?.run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果想在定义闭包属性的同时引用self，这个闭包必须是lazy的（因为在实例初始化完毕之后才能引用self）</p></li><li><p>下面闭包fn内部如果用到了实例成员（属性、方法），<strong>编译器会强制要求明确写出 <code>self </code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    lazy var fn: (() -&gt; ()) = &#123;</span><br><span class="line">        [weak self] in</span><br><span class="line">        self?.run()</span><br><span class="line">    &#125;</span><br><span class="line">    func run() &#123; print(&quot;run&quot;) &#125;</span><br><span class="line">    deinit &#123; print(&quot;deinit&quot;) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果lazy属性是闭包调用的结果，那么不用考虑循环引用的问题（因为闭包调用后，闭包的生命周期就结束了）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    var age: Int = 0</span><br><span class="line">    </span><br><span class="line">    lazy var getAge: Int = &#123;</span><br><span class="line">        self.age</span><br><span class="line">    &#125;()//这个属性带有()执行方法</span><br><span class="line">    </span><br><span class="line">    deinit &#123; print(&quot;deinit&quot;) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="escaping"><a href="#escaping" class="headerlink" title="@escaping"></a>@escaping</h3><ul><li>非逃逸闭包、逃逸闭包，一般都是当做参数传递给函数</li><li><strong>非逃逸闭包</strong>：闭包调用发生在函数结束前，闭包调用在函数作用域内 </li><li><strong>逃逸闭包</strong>：闭包有可能在函数结束后调用，闭包调用逃离了函数的作用域，需要通过 <code>@escaping </code>声明<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import Dispatch</span><br><span class="line">typealias Fn = () -&gt; ()</span><br><span class="line"></span><br><span class="line">// fn是非逃逸闭包</span><br><span class="line">func test1(_ fn: Fn) &#123; fn() &#125;</span><br><span class="line"></span><br><span class="line">// fn是逃逸闭包</span><br><span class="line">var gFn: Fn?</span><br><span class="line">func test2(_ fn: @escaping Fn) &#123; gFn = fn &#125;</span><br><span class="line"></span><br><span class="line">// fn是逃逸闭包</span><br><span class="line">func test3(_ fn: @escaping Fn) &#123;</span><br><span class="line">    DispatchQueue.global().async &#123;</span><br><span class="line">        fn()</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">    var fn: Fn</span><br><span class="line">    // fn是逃逸闭包</span><br><span class="line">    init(fn: @escaping Fn) &#123;</span><br><span class="line">        self.fn = fn</span><br><span class="line">    &#125;</span><br><span class="line">    func run() &#123;</span><br><span class="line">        // DispatchQueue.global().async也是一个逃逸闭包</span><br><span class="line">        // 它用到了实例成员（属性、方法），编译器会强制要求明确写出self</span><br><span class="line">        DispatchQueue.global().async &#123;</span><br><span class="line">            self.fn()</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>逃逸闭包的注意点：<br>逃逸闭包不可以捕获inout参数</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typealias Fn = () -&gt; ()</span><br><span class="line">func other1(_ fn: Fn) &#123; fn() &#125;</span><br><span class="line">func other2(_ fn: @escaping Fn) &#123; fn() &#125;</span><br><span class="line"></span><br><span class="line">func test(value: inout Int) -&gt; Fn &#123;</span><br><span class="line">    other1 &#123; value += 1 &#125;</span><br><span class="line">    </span><br><span class="line">    // error: 逃逸闭包不能捕获inout参数</span><br><span class="line">    //other2 &#123; value += 1 &#125;</span><br><span class="line">    </span><br><span class="line">    func plus() &#123; value += 1 &#125;</span><br><span class="line">    // error: 逃逸闭包不能捕获inout参数</span><br><span class="line">    return plus</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;跟OC一样，Swift也是采取基于引用计数的ARC内存管理方案（针对堆空间）&lt;/li&gt;
&lt;li&gt;Swfit的ARC中有3各引用&lt;</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Swift" scheme="http://www.hxtec.top/tags/Swift/"/>
    
    <category term="语法" scheme="http://www.hxtec.top/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Swift-访问控制</title>
    <link href="http://www.hxtec.top/2022/09/19/Swift-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/"/>
    <id>http://www.hxtec.top/2022/09/19/Swift-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</id>
    <published>2022-09-19T03:03:43.000Z</published>
    <updated>2022-09-19T03:48:01.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定义解释"><a href="#定义解释" class="headerlink" title="定义解释"></a>定义解释</h3><ul><li>在访问权限控制这块，Swift提供了5个不同的访问级别（以下是从高到低排列， 实体指被访问级别修饰的内容）<ul><li><code>open </code>：允许在定义实体的模块、其他模块中访问，允许其他模块进行继承、重写（open只能用在类、类成员上）</li><li><code>public </code>：允许在定义实体的模块、其他模块中访问，不允许其他模块进行继承、重写</li><li><code>internal </code>：只允许在定义实体的模块中访问，不允许在其他模块中访问</li><li><code>fileprivate </code>：只允许在定义实体的源文件中访问</li><li><code>private </code>：只允许在定义实体的封闭声明中访问</li></ul></li><li>绝大部分实体默认都是 internal 级别</li></ul><h3 id="访问级别的使用准则"><a href="#访问级别的使用准则" class="headerlink" title="访问级别的使用准则"></a>访问级别的使用准则</h3><ul><li>一个实体不可以被理低访问级别的实体定义，比如：<ul><li>变量\常量类型 ≥ 变量\常量</li><li>参数类型、返回值类型 ≥ 函数</li><li>父类 ≥ 子类</li><li>父协议 ≥ 子协议</li><li>原类型 ≥ typealias</li><li>原始值类型、关联值类型 ≥ 枚举类型</li><li>定义类型A时用到的其他类型 ≥ 类型A </li><li>……</li></ul></li></ul><h3 id="元组类型"><a href="#元组类型" class="headerlink" title="元组类型"></a>元组类型</h3><ul><li>元组类型的访问级别是所有成员类型最低的那个<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">internal struct Dog &#123;&#125;</span><br><span class="line">fileprivate class Person &#123;&#125;</span><br><span class="line"></span><br><span class="line">// (Dog, Person)的访问级别是fileprivate</span><br><span class="line">fileprivate var data1: (Dog, Person)</span><br><span class="line">private var data2: (Dog, Person)</span><br></pre></td></tr></table></figure></li></ul><h3 id="泛型类型"><a href="#泛型类型" class="headerlink" title="泛型类型"></a>泛型类型</h3><ul><li>泛型类型的访问级别是  <code>类型的访问级别 </code> 以及  <code>所有泛型类型参数 </code>  的访问级别中最低的那个<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">internal class Car &#123;&#125;</span><br><span class="line">fileprivate class Dog &#123;&#125;</span><br><span class="line">public class Person&lt;T1, T2&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">// Person&lt;Car, Dog&gt;的访问级别是fileprivate</span><br><span class="line">fileprivate var p = Person&lt;Car, Dog&gt;()</span><br></pre></td></tr></table></figure></li></ul><h3 id="成员、嵌套类型"><a href="#成员、嵌套类型" class="headerlink" title="成员、嵌套类型"></a>成员、嵌套类型</h3><ul><li>类型的访问级别会影响成员（属性、方法、初始化器、下标）、嵌套类型的默认访问级别<ul><li>一般情况下，类型为private或fileprivate，那么成员\嵌套类型默认也是private或fileprivate</li><li>一般情况下，类型为internal或public，那么成员\嵌套类型默认是internal<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class PublicClass &#123;</span><br><span class="line">    public var p1 = 0 // public</span><br><span class="line">    var p2 = 0 // internal</span><br><span class="line">    fileprivate func f1() &#123;&#125; // fileprivate</span><br><span class="line">    private func f2() &#123;&#125; // private</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class InternalClass &#123; // internal</span><br><span class="line">    var p = 0 // internal</span><br><span class="line">    fileprivate func f1() &#123;&#125; // fileprivate</span><br><span class="line">    private func f2() &#123;&#125; // private</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fileprivate class FilePrivateClass &#123; // fileprivate</span><br><span class="line">    func f1() &#123;&#125; // fileprivate</span><br><span class="line">    private func f2() &#123;&#125; // private</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private class PrivateClass &#123; // private</span><br><span class="line">    func f() &#123;&#125; // private</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="成员的重写"><a href="#成员的重写" class="headerlink" title="成员的重写"></a>成员的重写</h3><ul><li>子类重写成员的访问级别必须 &gt;&#x3D; 子类的访问级别，或者 &gt;&#x3D; 父类被重写成员的访问级别</li><li>父类的成员不能被成员作用域外定义的子类重写<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private var age: Int = 0</span><br><span class="line">    </span><br><span class="line">    public class Student : Person &#123;</span><br><span class="line">        override var age: Int &#123;</span><br><span class="line">            set &#123;&#125;</span><br><span class="line">            get &#123;10&#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>####### 示例</p><ul><li>直接在全局作用域下定义的private等价于fileprivate<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private class Person &#123;&#125;</span><br><span class="line"></span><br><span class="line">fileprivate class Student : Person &#123;&#125;</span><br></pre></td></tr></table></figure></li><li>如果上面两句代码放在一个方法体中，就会报错<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func test &#123;</span><br><span class="line">    private class Person &#123;&#125;</span><br><span class="line"></span><br><span class="line">    fileprivate class Student : Person &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="getter-setter"><a href="#getter-setter" class="headerlink" title="getter, setter"></a>getter, setter</h3><ul><li>getter, setter默认自动接收它们所属环境的访问级别</li><li>可以给setter单独设置一个比getter更低的访问级别，用以限制写的权限<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fileprivate(set) public var num = 10</span><br><span class="line">class Person &#123;</span><br><span class="line">    private(set) var age = 0</span><br><span class="line">    fileprivate(set) public var weight: Int &#123;</span><br><span class="line">        set &#123;&#125;</span><br><span class="line">        get &#123; 10 &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    internal(set) public subscript(index: Int) -&gt; Int &#123;</span><br><span class="line">        set &#123;&#125;</span><br><span class="line">        get &#123; index &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="初始化器"><a href="#初始化器" class="headerlink" title="初始化器"></a>初始化器</h3><ul><li>如果一个 <code>public </code>类想在另一个模块调用编译生成的默认无参初始化器，必须显示提供 <code>public </code>的无参初始化器，因为 <code>public </code>类的默认初始化器是 <code>internal </code>级别</li><li>required初始化器 &gt;&#x3D; 它的默认访问级别</li><li>如果结构体有private\fileprivate的存储实例属性，那么它的成员初始化器也是private\fileprivate，否则默认就是Internal</li></ul><h3 id="枚举类型的case"><a href="#枚举类型的case" class="headerlink" title="枚举类型的case"></a>枚举类型的case</h3><ul><li><code>不能给枚举enum的每个case单独设置访问级别 </code></li><li>每个case自动接收enum的访问级别</li><li><code>public </code> enum定义的case 也是  <code>public </code></li></ul><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><ul><li>协议中定义的要求自动接收协议的访问级别，不能单独设置访问级别</li><li>public协议定义的要求也是public</li><li>协议实现的访问级别必须 &gt;&#x3D; 类型的访问级别，或者 &gt;&#x3D; 协议的访问级别</li></ul><blockquote><p>示例：</p></blockquote><ul><li>下面代码能编译通过么？<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public protocol Runnable &#123;</span><br><span class="line">    func run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Person : Runnable &#123;</span><br><span class="line">    func run() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>不能编译通过，由于类定义的public，public下默认为Internal，权限小于public。</li></ul><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><ul><li>如果有显式设置扩展的访问级别，扩展添加的成员自动接收扩展的访问级别</li><li>如果没有显式设置扩展的访问级别，扩展添加的成员的默认访问级别，跟直接在类型中定义的成员一样</li><li>可以单独给扩展添加的成员设置访问级别</li><li>不能给用于遵守协议的扩展显式设置扩展的访问级别</li><li>在同一文件中的扩展，可以写成类似多个部分的类型声明<ul><li>在原本的声明中声明一个私有成员，可以在同一文件的扩展中访问它</li><li>在扩展中声明一个私有成员，可以在同一文件的其他扩展中、原本声明中访问它</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private func run0() &#123;&#125;</span><br><span class="line">    private func eat0() &#123;</span><br><span class="line">        run1()</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension Person &#123;</span><br><span class="line">    private func run1() &#123;&#125;</span><br><span class="line">    private func eat1() &#123;</span><br><span class="line">        run0()</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension Person &#123;</span><br><span class="line">    private func eat2() &#123;</span><br><span class="line">        run1()</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将方法赋值给var-let"><a href="#将方法赋值给var-let" class="headerlink" title="将方法赋值给var\let"></a>将方法赋值给var\let</h3><ul><li>方法也可以像函数那样，赋值给一个let或者var<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct Person &#123;</span><br><span class="line">    var age: Int</span><br><span class="line">    func run(_ v: Int) &#123; print(&quot;func run&quot;, age, v) &#125;</span><br><span class="line">    static func run(_ v: Int) &#123; print(&quot;static func run&quot;, v) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let fn1 = Person.run</span><br><span class="line">fn1(10) // static func run 10</span><br><span class="line"></span><br><span class="line">let fn2: (Int) -&gt; () = Person.run</span><br><span class="line">fn2(20) // static func run 20</span><br><span class="line"></span><br><span class="line">let fn3: (Person) -&gt; ((Int) -&gt; ()) = Person.run</span><br><span class="line">fn3(Person(age: 18))(30) // func run 18 30</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;定义解释&quot;&gt;&lt;a href=&quot;#定义解释&quot; class=&quot;headerlink&quot; title=&quot;定义解释&quot;&gt;&lt;/a&gt;定义解释&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;在访问权限控制这块，Swift提供了5个不同的访问级别（以下是从高到低排列， 实体指被访问级别修饰的内容）&lt;ul</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Swift" scheme="http://www.hxtec.top/tags/Swift/"/>
    
    <category term="语法" scheme="http://www.hxtec.top/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Swift-扩展（Extension）</title>
    <link href="http://www.hxtec.top/2022/09/19/Swift-%E6%89%A9%E5%B1%95%EF%BC%88Extension%EF%BC%89/"/>
    <id>http://www.hxtec.top/2022/09/19/Swift-%E6%89%A9%E5%B1%95%EF%BC%88Extension%EF%BC%89/</id>
    <published>2022-09-19T03:03:24.000Z</published>
    <updated>2022-09-19T03:45:30.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>Swift中的扩展，有点类似于OC中的分类（Category）</li><li>扩展可以为枚举、结构体、类、协议添加新功能<ul><li>可以添加方法、计算属性、下标、（便捷）初始化器、嵌套类型、协议等等</li></ul></li><li>扩展不能办到的事情：<ul><li>不能覆盖原有的功能</li><li>不能添加存储属性，不能向已有的属性添加属性观察器</li><li>不能添加父类</li><li>不能添加指定初始化器，不能添加反初始化器</li><li>…</li></ul></li></ul><h4 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">extension Double &#123;</span><br><span class="line">    var km: Double &#123; self * 1_000.0 &#125;</span><br><span class="line">    var m: Double &#123; self &#125;</span><br><span class="line">    var dm: Double &#123; self / 10.0 &#125;</span><br><span class="line">    var cm: Double &#123; self / 100.0 &#125;</span><br><span class="line">    var mm: Double &#123; self / 1_000.0 &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">extension Array &#123;</span><br><span class="line">    subscript(nullable idx: Int) -&gt; Element? &#123;</span><br><span class="line">    if (startIndex..&lt;endIndex).contains(idx) &#123;</span><br><span class="line">        return self[idx]</span><br><span class="line">    &#125;</span><br><span class="line">    return nil</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法、嵌套类型"><a href="#方法、嵌套类型" class="headerlink" title="方法、嵌套类型"></a>方法、嵌套类型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">extension Int &#123;</span><br><span class="line">    func repetitions(task: () -&gt; Void) &#123;</span><br><span class="line">        for _ in 0..&lt;self &#123; task() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mutating func square() -&gt; Int &#123;</span><br><span class="line">        self = self * self</span><br><span class="line">        return self</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    enum Kind &#123; case negative, zero, positive &#125;</span><br><span class="line">    </span><br><span class="line">    var kind: Kind &#123;</span><br><span class="line">        switch self &#123;</span><br><span class="line">        case 0: return .zero</span><br><span class="line">        case let x where x &gt; 0: return .positive</span><br><span class="line">        default: return .negative</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    subscript(digitIndex: Int) -&gt; Int &#123;</span><br><span class="line">        var decimalBase = 1</span><br><span class="line">        for _ in 0..&lt;digitIndex &#123; decimalBase *= 10 &#125;</span><br><span class="line">        return (self / decimalBase) % 10</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="协议、初始化器"><a href="#协议、初始化器" class="headerlink" title="协议、初始化器"></a>协议、初始化器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    var age: Int</span><br><span class="line">    var name: String</span><br><span class="line">    init(age: Int, name: String) &#123;</span><br><span class="line">        self.age = age</span><br><span class="line">        self.name = name</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension Person : Equatable &#123;</span><br><span class="line">    static func == (left: Person, right: Person) -&gt; Bool &#123;</span><br><span class="line">        left.age == right.age &amp;&amp; left.name == right.name</span><br><span class="line">    &#125;</span><br><span class="line">    convenience init() &#123;</span><br><span class="line">        self.init(age: 0, name: &quot;&quot;) </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果希望自定义初始化器的同时，编译器也能够生成默认初始化器<ul><li>可以在扩展中编写自定义初始化器</li><li><code>required </code>初始化器也不能写在扩展中<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct Point &#123;</span><br><span class="line">    var x: Int = 0</span><br><span class="line">    var y: Int = 0 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension Point &#123;</span><br><span class="line">    init(_ point: Point) &#123;</span><br><span class="line">        self.init(x: point.x, y: point.y) </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p1 = Point()</span><br><span class="line">var p2 = Point(x: 10)</span><br><span class="line">var p3 = Point(y: 20)</span><br><span class="line">var p4 = Point(x: 10, y: 20)</span><br><span class="line">var p5 = Point(p4)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><ul><li>如果一个类型已经实现了协议的所有要求，但是还没有声明它遵守了这个协议， <code>可以通过扩展来让它遵守这个协议 </code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protocol TestProtocol &#123;</span><br><span class="line">    func test()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TestClass &#123;</span><br><span class="line">    func test() &#123;</span><br><span class="line">        print(&quot;test&quot;) </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension TestClass : TestProtocol &#123;&#125;</span><br></pre></td></tr></table></figure></li><li>编写一个函数，判断一个整数是否为奇数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 方法</span><br><span class="line">func isOdd&lt;T: BinaryInteger&gt;(_ i: T) -&gt; Bool &#123;</span><br><span class="line">    i % 2 != 0 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//给UInt, Int添加扩展</span><br><span class="line">extension BinaryInteger &#123;</span><br><span class="line">    func isOdd() -&gt; Bool &#123; self % 2 != 0 &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>扩展可以给协议提供默认实现，也间接实现【可选协议】的效果</li><li>扩展可以给协议扩充【协议中从未声明过的方法】<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">protocol TestProtocol &#123;</span><br><span class="line">    func test1()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 给协议添加扩展方法，以下为可选协议</span><br><span class="line">extension TestProtocol &#123;</span><br><span class="line">    func test1() &#123;</span><br><span class="line">        print(&quot;TestProtocol test1&quot;) </span><br><span class="line">    &#125;</span><br><span class="line">    func test2() &#123;</span><br><span class="line">        print(&quot;TestProtocol test2&quot;) </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 类</span><br><span class="line">class TestClass : TestProtocol &#123;&#125;</span><br><span class="line"></span><br><span class="line">var cls = TestClass()</span><br><span class="line">cls.test1() // TestProtocol test1</span><br><span class="line">cls.test2() // TestProtocol test2</span><br><span class="line"></span><br><span class="line">var cls2: TestProtocol = TestClass()</span><br><span class="line">cls2.test1() // TestProtocol test1</span><br><span class="line">cls2.test2() // TestProtocol test2</span><br><span class="line"></span><br><span class="line">class TestClass : TestProtocol &#123;</span><br><span class="line">    func test1() &#123; print(&quot;TestClass test1&quot;) &#125;</span><br><span class="line">    func test2() &#123; print(&quot;TestClass test2&quot;) &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var cls = TestClass()</span><br><span class="line">cls.test1() // TestClass test1</span><br><span class="line">cls.test2() // TestClass test2</span><br><span class="line"></span><br><span class="line">var cls2: TestProtocol = TestClass()</span><br><span class="line">cls2.test1() // TestClass test1</span><br><span class="line">cls2.test2() // TestProtocol test2，优先调用协议里的test2方法，由于cls2类遵守协议的方法。</span><br></pre></td></tr></table></figure></li></ul><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Stack&lt;E&gt; &#123;</span><br><span class="line">    var elements = [E]()</span><br><span class="line">    func push(_ element: E) &#123;</span><br><span class="line">        elements.append(element)</span><br><span class="line">    &#125;</span><br><span class="line">    func pop() -&gt; E &#123; elements.removeLast() &#125;</span><br><span class="line">    func size() -&gt; Int &#123; elements.count &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 扩展中依然可以使用原类型中的泛型类型</span><br><span class="line">extension Stack &#123;</span><br><span class="line">    func top() -&gt; E &#123; elements.last! &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 符合条件才扩展</span><br><span class="line">extension Stack : Equatable where E : Equatable &#123;</span><br><span class="line">    static func == (left: Stack, right: Stack) -&gt; Bool &#123;</span><br><span class="line">    left.elements == right.elements</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Swift中的扩展，有点类似于OC中的分类（Category）&lt;/li&gt;
&lt;li&gt;扩展可以为枚举、结构体、类、协议添加新功能&lt;u</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Swift" scheme="http://www.hxtec.top/tags/Swift/"/>
    
    <category term="语法" scheme="http://www.hxtec.top/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Swift-高级运算符</title>
    <link href="http://www.hxtec.top/2022/09/19/Swift-%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>http://www.hxtec.top/2022/09/19/Swift-%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6/</id>
    <published>2022-09-19T03:03:13.000Z</published>
    <updated>2022-09-19T03:43:04.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="举出运算符（Overflow-Operator）"><a href="#举出运算符（Overflow-Operator）" class="headerlink" title="举出运算符（Overflow Operator）"></a>举出运算符（Overflow Operator）</h3><ul><li>Swift的算数运算符出现溢出时会抛出运行时错误</li><li>Swift有溢出运算符（&amp;+，&amp;-，&amp;*），用来支持溢出运算<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var min = UInt8.min</span><br><span class="line">print(min &amp;- 1)//255，Int8.max</span><br><span class="line"></span><br><span class="line">var max = UInt8.max</span><br><span class="line">print(max &amp;+ 1) // 0, Int8.min</span><br><span class="line">print(max &amp;* 2) // 254, 等价于 max &amp;+ max</span><br></pre></td></tr></table></figure></li></ul><h3 id="运算符重载（Operator-Overload）"><a href="#运算符重载（Operator-Overload）" class="headerlink" title="运算符重载（Operator Overload）"></a>运算符重载（Operator Overload）</h3><ul><li>类、结构体、枚举可以为现有的运算符提供自定义的实现，这个操作叫做：运算符重载<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">struct Point &#123;</span><br><span class="line">    var x: Int, y: Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// + 的重载</span><br><span class="line">func + (p1: Point, p2: Point) -&gt; Point &#123;</span><br><span class="line">    Point(x: p1.x + p2.x, y: p1.y + p2.y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let p = Point(x: 10, y: 20) + Point(x: 11, y: 22)</span><br><span class="line">print(p)// Point(x: 21, y: 42)</span><br><span class="line"></span><br><span class="line">//静态方法，重载运算符</span><br><span class="line">struct Point &#123;</span><br><span class="line">    var x: Int, y: Int</span><br><span class="line">    // + 的重载</span><br><span class="line">    static func + (p1: Point, p2: Point) -&gt; Point &#123;</span><br><span class="line">        Point(x: p1.x + p2.x, y: p1.y + p2.y)</span><br><span class="line">    &#125;</span><br><span class="line">    // - 的重载</span><br><span class="line">    static func - (p1: Point, p2: Point) -&gt; Point &#123;</span><br><span class="line">        Point(x: p1.x - p2.x, y: p1.y - p2.y)</span><br><span class="line">    &#125;</span><br><span class="line">    // 前置- 的重载</span><br><span class="line">    static prefix func - (p: Point) -&gt; Point &#123;</span><br><span class="line">        Point(x: -p.x, y: -p.y) </span><br><span class="line">    &#125;</span><br><span class="line">    // += 的重载</span><br><span class="line">    static func += (p1: inout Point, p2: Point) &#123;</span><br><span class="line">        p1 = p1 + p2</span><br><span class="line">    &#125;</span><br><span class="line">    static prefix func ++ (p: inout Point) -&gt; Point &#123;</span><br><span class="line">        p += Point(x: 1, y: 1)</span><br><span class="line">        return p</span><br><span class="line">    &#125;</span><br><span class="line">    static postfix func ++ (p: inout Point) -&gt; Point &#123;</span><br><span class="line">        let tmp = p</span><br><span class="line">        p += Point(x: 1, y: 1)</span><br><span class="line">        return tmp</span><br><span class="line">    &#125;</span><br><span class="line">    static func  ` (p1: Point, p2: Point) -&gt; Bool &#123;</span><br><span class="line">        (p1.x  ` p2.x) &amp;&amp; (p1.y  ` p2.y) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Equatable"><a href="#Equatable" class="headerlink" title="Equatable"></a>Equatable</h3><ul><li>要想得知2个实例是否等价，一般做法是遵守Equatable协议，重载 &#96;运算符<ul><li>与此同时，等价于重载了 ! &#96; 运算符<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct Point : Equatable &#123;</span><br><span class="line">    var x: Int, y: Int</span><br><span class="line">&#125;</span><br><span class="line">var p1 = Point(x: 10, y: 20)</span><br><span class="line">var p2 = Point(x: 11, y: 22)</span><br><span class="line">print(p1  ` p2) // false</span><br><span class="line">print(p1 != p2) // true</span><br></pre></td></tr></table></figure></li></ul></li><li>Swift为以下类型提供默认的Equatable实现<ul><li>没有关联类型的枚举</li><li>只拥有遵守Equatable协议关联类型的枚举</li><li>只拥有遵守Equatable协议存储属性的结构体</li></ul></li><li>引用类型比较存储的地址值是否相等（是否引用着同一个对象），使用恒等运算符  <code>= 、! </code></li></ul><h3 id="Comparable"><a href="#Comparable" class="headerlink" title="Comparable"></a>Comparable</h3><ul><li>要想比较2个实例的大小，一般做法是：<ul><li>遵守Comparable协议</li><li>重载相应的运算符<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// score大的比较大，若score相等，age小的比较大</span><br><span class="line">struct Student : Comparable &#123;</span><br><span class="line">    var age: Int</span><br><span class="line">    var score: Int</span><br><span class="line">    init(score: Int, age: Int) &#123;</span><br><span class="line">    self.score = score</span><br><span class="line">    self.age = age</span><br><span class="line">    &#125;</span><br><span class="line">    static func &lt; (lhs: Student, rhs: Student) -&gt; Bool &#123;</span><br><span class="line">        (lhs.score &lt; rhs.score)</span><br><span class="line">            || (lhs.score  ` rhs.score &amp;&amp; lhs.age &gt; rhs.age)</span><br><span class="line">    &#125;</span><br><span class="line">    static func &gt; (lhs: Student, rhs: Student) -&gt; Bool &#123;</span><br><span class="line">        (lhs.score &gt; rhs.score)</span><br><span class="line">            || (lhs.score  ` rhs.score &amp;&amp; lhs.age &lt; rhs.age)    </span><br><span class="line">    &#125;</span><br><span class="line">    static func &lt;= (lhs: Student, rhs: Student) -&gt; Bool &#123;</span><br><span class="line">        !(lhs &gt; rhs)</span><br><span class="line">    &#125;</span><br><span class="line">    static func &gt;= (lhs: Student, rhs: Student) -&gt; Bool &#123;</span><br><span class="line">        !(lhs &lt; rhs)</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var stu1 = Student(score: 100, age: 20)</span><br><span class="line">var stu2 = Student(score: 98, age: 18)</span><br><span class="line">var stu3 = Student(score: 100, age: 20)</span><br><span class="line">print(stu1 &gt; stu2) // true</span><br><span class="line">print(stu1 &gt;= stu2) // true</span><br><span class="line">print(stu1 &gt;= stu3) // true</span><br><span class="line">print(stu1 &lt;= stu3) // true</span><br><span class="line">print(stu2 &lt; stu1) // true</span><br><span class="line">print(stu2 &lt;= stu1) // true</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="自定义运算符（Custom-Operator）"><a href="#自定义运算符（Custom-Operator）" class="headerlink" title="自定义运算符（Custom Operator）"></a>自定义运算符（Custom Operator）</h3><ul><li>可以自定义新的运算符：在全局作用域使用operator进行声明<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">prefix operator 前缀运算符</span><br><span class="line">postfix operator 后缀运算符</span><br><span class="line">infix operator 中缀运算符 : 优先级组</span><br><span class="line"></span><br><span class="line">precedencegroup 优先级组 &#123;</span><br><span class="line">    associativity: 结合性(left\right\none)</span><br><span class="line">    higherThan: 比谁的优先级高</span><br><span class="line">    lowerThan: 比谁的优先级低</span><br><span class="line">    assignment: true代表在可选链操作中拥有跟赋值运算符一样的优先级</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">prefix operator +++</span><br><span class="line">infix operator +- : PlusMinusPrecedence</span><br><span class="line">precedencegroup PlusMinusPrecedence &#123;</span><br><span class="line">    associativity: none</span><br><span class="line">    higherThan: AdditionPrecedence</span><br><span class="line">    lowerThan: MultiplicationPrecedence</span><br><span class="line">    assignment: true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Point &#123;</span><br><span class="line">    var x: Int, y: Int</span><br><span class="line">    static prefix func +++ (point: inout Point) -&gt; Point &#123;</span><br><span class="line">        point = Point(x: point.x + point.x, y: point.y + point.y)</span><br><span class="line">        return point</span><br><span class="line">    &#125;</span><br><span class="line">    static func +- (left: Point, right: Point) -&gt; Point &#123;</span><br><span class="line">        return Point(x: left.x + right.x, y: left.y - right.y)</span><br><span class="line">    &#125;</span><br><span class="line">    static func +- (left: Point?, right: Point) -&gt; Point &#123;</span><br><span class="line">        print(&quot;+-&quot;)</span><br><span class="line">        return Point(x: left?.x ?? 0 + right.x, y: left?.y ?? 0 - right.y) </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Person &#123;</span><br><span class="line">    var point: Point</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">var person: Person? = nil</span><br><span class="line">person?.point +- Point(x: 10, y: 20)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;举出运算符（Overflow-Operator）&quot;&gt;&lt;a href=&quot;#举出运算符（Overflow-Operator）&quot; class=&quot;headerlink&quot; title=&quot;举出运算符（Overflow Operator）&quot;&gt;&lt;/a&gt;举出运算符（Overflow</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Swift" scheme="http://www.hxtec.top/tags/Swift/"/>
    
    <category term="语法" scheme="http://www.hxtec.top/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Swift-泛型</title>
    <link href="http://www.hxtec.top/2022/09/19/Swift-%E6%B3%9B%E5%9E%8B/"/>
    <id>http://www.hxtec.top/2022/09/19/Swift-%E6%B3%9B%E5%9E%8B/</id>
    <published>2022-09-19T03:02:59.000Z</published>
    <updated>2022-09-19T03:41:34.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>-泛型可以将类型参数化，提高代码复用率，减少代码量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func swapValues&lt;T&gt;(_ a: inout T, _ b: inout T) &#123;</span><br><span class="line">    (a, b) = (b, a)</span><br><span class="line">&#125;</span><br><span class="line">var i1 = 10</span><br><span class="line">var i2 = 20</span><br><span class="line">swapValues(&amp;i1, &amp;i2)</span><br><span class="line">var d1 = 10.0</span><br><span class="line">var d2 = 20.0</span><br><span class="line">swapValues(&amp;d1, &amp;d2)</span><br><span class="line"></span><br><span class="line">struct Date &#123;</span><br><span class="line">    var year = 0, month = 0, day = 0 </span><br><span class="line">&#125;</span><br><span class="line">var dd1 = Date(year: 2011, month: 9, day: 10)</span><br><span class="line">var dd2 = Date(year: 2012, month: 10, day: 11)</span><br><span class="line">swapValues(&amp;dd1, &amp;dd2)</span><br></pre></td></tr></table></figure><ul><li>泛型函数赋值给变量<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func test&lt;T1, T2&gt;(_ t1: T1, _ t2: T2) &#123;&#125;</span><br><span class="line">var fn: (Int, Double) -&gt; () = test</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>代码示例</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Stack&lt;E&gt; &#123;</span><br><span class="line">    var elements = [E]()</span><br><span class="line">    func push(_ element: E) &#123; elements.append(element) &#125;</span><br><span class="line">    func pop() -&gt; E &#123; elements.removeLast() &#125;</span><br><span class="line">    func top() -&gt; E &#123; elements.last! &#125;</span><br><span class="line">    func size() -&gt; Int &#123; elements.count &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SubStack&lt;E&gt; : Stack&lt;E&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">var stack = Stack&lt;Int&gt;()</span><br><span class="line">stack.push(11)</span><br><span class="line">stack.push(22)</span><br><span class="line">stack.push(33)</span><br><span class="line">print(stack.top()) // 33</span><br><span class="line">print(stack.pop()) // 33</span><br><span class="line">print(stack.pop()) // 22</span><br><span class="line">print(stack.pop()) // 11</span><br><span class="line">print(stack.size()) // 0</span><br><span class="line"></span><br><span class="line">struct Stack&lt;E&gt; &#123;</span><br><span class="line">    var elements = [E]()</span><br><span class="line">    mutating func push(_ element: E) &#123; elements.append(element) &#125;</span><br><span class="line">    mutating func pop() -&gt; E &#123; elements.removeLast() &#125;</span><br><span class="line">    func top() -&gt; E &#123; elements.last! &#125;</span><br><span class="line">    func size() -&gt; Int &#123; elements.count &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum Score&lt;T&gt; &#123;</span><br><span class="line">    case point(T)</span><br><span class="line">    case grade(String) </span><br><span class="line">&#125;</span><br><span class="line">let score0 = Score&lt;Int&gt;.point(100)</span><br><span class="line">let score1 = Score.point(99)</span><br><span class="line">let score2 = Score.point(99.5)</span><br><span class="line">let score3 = Score&lt;Int&gt;.grade(&quot;A&quot;)</span><br></pre></td></tr></table></figure><h3 id="关联类型（Associated-Type）"><a href="#关联类型（Associated-Type）" class="headerlink" title="关联类型（Associated Type）"></a>关联类型（Associated Type）</h3><ul><li>关联类型的作用：给协议中用到的类型定义一个占位名称</li><li>协议中可以拥有多个关联类型<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">protocol Stackable &#123;</span><br><span class="line">    associatedtype Element // 关联类型</span><br><span class="line">    mutating func push(_ element: Element)</span><br><span class="line">    mutating func pop() -&gt; Element</span><br><span class="line">    func top() -&gt; Element</span><br><span class="line">    func size() -&gt; Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Stack&lt;E&gt; : Stackable &#123;</span><br><span class="line">    // typealias Element = E</span><br><span class="line">    var elements = [E]()</span><br><span class="line">    func push(_ element: E) &#123; </span><br><span class="line">        elements.append(element) </span><br><span class="line">    &#125;</span><br><span class="line">    func pop() -&gt; E &#123; elements.removeLast() &#125;</span><br><span class="line">    func top() -&gt; E &#123; elements.last! &#125;</span><br><span class="line">    func size() -&gt; Int &#123; elements.count &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class StringStack : Stackable &#123;</span><br><span class="line">    // 给关联类型设定真实类型</span><br><span class="line">    // typealias Element = String</span><br><span class="line">    var elements = [String]()</span><br><span class="line">    func push(_ element: String) &#123; elements.append(element) &#125;</span><br><span class="line">    func pop() -&gt; String &#123; elements.removeLast() &#125;</span><br><span class="line">    func top() -&gt; String &#123; elements.last! &#125;</span><br><span class="line">    func size() -&gt; Int &#123; elements.count &#125; </span><br><span class="line">&#125;</span><br><span class="line">var ss = StringStack()</span><br><span class="line">ss.push(&quot;Jack&quot;)</span><br><span class="line">ss.push(&quot;Rose&quot;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="类型约束"><a href="#类型约束" class="headerlink" title="类型约束"></a>类型约束</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">protocol Runnable &#123; &#125;</span><br><span class="line">class Person &#123; &#125;</span><br><span class="line">func swapValues&lt;T : Person &amp; Runnable&gt;(_ a: inout T, _ b: inout T) &#123;</span><br><span class="line">    (a, b) = (b, a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol Stackable &#123;</span><br><span class="line">    associatedtype Element: Equatable</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Stack&lt;E : Equatable&gt; : Stackable &#123; typealias Element = E &#125;</span><br><span class="line"></span><br><span class="line">func equal&lt;S1: Stackable, S2: Stackable&gt;(_ s1: S1, _ s2: S2) -&gt; Bool</span><br><span class="line">    where S1.Element  ` S2.Element, S1.Element : Hashable &#123;</span><br><span class="line">    return false</span><br><span class="line">&#125;</span><br><span class="line">var stack1 = Stack&lt;Int&gt;()</span><br><span class="line">var stack2 = Stack&lt;String&gt;()</span><br><span class="line">// error: requires the types &#x27;Int&#x27; and &#x27;String&#x27; be equivalent</span><br><span class="line">equal(stack1, stack2)</span><br></pre></td></tr></table></figure><h3 id="协议类型的注意点"><a href="#协议类型的注意点" class="headerlink" title="协议类型的注意点"></a>协议类型的注意点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protocol Runnable &#123;&#125;</span><br><span class="line">class Person : Runnable &#123;&#125;</span><br><span class="line">class Car : Runnable &#123;&#125;</span><br><span class="line">func get(_ type: Int) -&gt; Runnable &#123;</span><br><span class="line">    if type  ` 0 &#123;</span><br><span class="line">        return Person()</span><br><span class="line">    &#125;</span><br><span class="line">    return Car()</span><br><span class="line">&#125;</span><br><span class="line">var r1 = get(0)</span><br><span class="line">var r2 = get(1) </span><br></pre></td></tr></table></figure><ul><li>如果协议中有 <code>associatedtype </code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protocol Runnable &#123;</span><br><span class="line">    associatedtype Speed</span><br><span class="line">    var speed: Speed &#123; get &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person : Runnable &#123;</span><br><span class="line">    var speed: Double &#123; 0.0 &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Car : Runnable &#123;</span><br><span class="line">    var speed: Int &#123; 0 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="泛型解决"><a href="#泛型解决" class="headerlink" title="泛型解决"></a>泛型解决</h4><ul><li>解决方案①：使用泛型<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func get&lt;T : Runnable&gt;(_ type: Int) -&gt; T &#123;</span><br><span class="line">    if type  ` 0 &#123;</span><br><span class="line">        return Person() as! T </span><br><span class="line">    &#125;</span><br><span class="line">    return Car() as! T </span><br><span class="line">&#125;</span><br><span class="line">var r1: Person = get(0)</span><br><span class="line">var r2: Car = get(1)</span><br></pre></td></tr></table></figure></li></ul><h3 id="不透明类型（Opaque-Type）"><a href="#不透明类型（Opaque-Type）" class="headerlink" title="不透明类型（Opaque Type）"></a>不透明类型（Opaque Type）</h3><ul><li>解决方案②：使用some关键字声明一个不透明类型<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func get(_ type: Int) -&gt; some Runnable &#123; Car() &#125;</span><br><span class="line">var r1 = get(0)</span><br><span class="line">var r2 = get(1)</span><br></pre></td></tr></table></figure></li><li>some限制只能返回一种类型</li></ul><h4 id="some"><a href="#some" class="headerlink" title="some"></a>some</h4><ul><li>some除了用在返回值类型上，一般还可以用在属性类型上<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protocol Runnable &#123; associatedtype Speed &#125;</span><br><span class="line">class Dog : Runnable &#123; typealias Speed = Double &#125;</span><br><span class="line">class Person &#123;</span><br><span class="line">    var pet: some Runnable &#123;</span><br><span class="line">        return Dog()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="可选项的本质"><a href="#可选项的本质" class="headerlink" title="可选项的本质"></a>可选项的本质</h3><ul><li>可选项的本质是enum类型<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public enum Optional&lt;Wrapped&gt; : ExpressibleByNilLiteral &#123;</span><br><span class="line">    case none</span><br><span class="line">    case some(Wrapped)</span><br><span class="line">    public init(_ some: Wrapped)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var age: Int? = 10</span><br><span class="line">var age0: Optional&lt;Int&gt; = Optional&lt;Int&gt;.some(10)</span><br><span class="line">var age1: Optional = .some(10)</span><br><span class="line">var age2 = Optional.some(10)</span><br><span class="line">var age3 = Optional(10)</span><br><span class="line">age = nil</span><br><span class="line">age3 = .none</span><br><span class="line"></span><br><span class="line">var age: Int? = nil</span><br><span class="line">var age0 = Optional&lt;Int&gt;.none</span><br><span class="line">var age1: Optional&lt;Int&gt; = .none</span><br><span class="line"></span><br><span class="line">var age: Int? = .none</span><br><span class="line">age = 10</span><br><span class="line">age = .some(20)</span><br><span class="line">age = nil</span><br><span class="line"></span><br><span class="line">switch age &#123;</span><br><span class="line">    case let v?:</span><br><span class="line">        print(&quot;some&quot;, v)</span><br><span class="line">    case nil:</span><br><span class="line">        print(&quot;none&quot;) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">switch age &#123;</span><br><span class="line">    case let .some(v):</span><br><span class="line">        print(&quot;some&quot;, v)</span><br><span class="line">    case .none:</span><br><span class="line">        print(&quot;none&quot;) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 另一示例</span><br><span class="line">var age_: Int? = 10</span><br><span class="line">var age: Int?? = age_</span><br><span class="line">age = nil</span><br><span class="line"></span><br><span class="line">var age0 = Optional.some(Optional.some(10))</span><br><span class="line">age0 = .none</span><br><span class="line">var age1: Optional&lt;Optional&gt; = .some(.some(10))</span><br><span class="line">age1 = .none</span><br><span class="line"></span><br><span class="line">var age: Int?? = 10</span><br><span class="line">var age0: Optional&lt;Optional&gt; = 10</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;p&gt;-泛型可以将类型参数化，提高代码复用率，减少代码量&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;tab</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Swift" scheme="http://www.hxtec.top/tags/Swift/"/>
    
    <category term="语法" scheme="http://www.hxtec.top/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Swift-错误处理</title>
    <link href="http://www.hxtec.top/2022/09/19/Swift-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"/>
    <id>http://www.hxtec.top/2022/09/19/Swift-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</id>
    <published>2022-09-19T03:02:46.000Z</published>
    <updated>2022-09-19T03:39:18.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h3><ul><li>开发过程常见的错误<ul><li>语法错误（编译错误）</li><li>逻辑错误</li><li>运行时错误（可能会导致闪退，一般也叫做异常）</li><li>…</li></ul></li></ul><h3 id="自定义错误"><a href="#自定义错误" class="headerlink" title="自定义错误"></a>自定义错误</h3><ul><li><p>Swift中可以通过Error协议自定义运行时的错误信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum SomeError : Error &#123;</span><br><span class="line">    case illegalArg(String)</span><br><span class="line">    case outOfBounds(Int, Int)</span><br><span class="line">    case outOfMemory</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数内部通过throw抛出自定义Error，可能会抛出Error的函数必须加上 <code>throws </code>声明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func divide(_ num1: Int, _ num2: Int) throws -&gt; Int &#123;</span><br><span class="line">    if num2  ` 0 &#123;</span><br><span class="line">        throw SomeError.illegalArg(&quot;0不能作为除数&quot;) </span><br><span class="line">    &#125;</span><br><span class="line">    return num1 / num2</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p>需要使用 <code>try </code>调用可能会抛出Error的函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var result = try divide(20, 10)</span><br></pre></td></tr></table></figure></li></ul><h3 id="do-catch"><a href="#do-catch" class="headerlink" title="do-catch"></a>do-catch</h3><ul><li>可以使用do-catch捕捉Error<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">func test() &#123;</span><br><span class="line">    print(&quot;1&quot;)</span><br><span class="line">    do &#123;</span><br><span class="line">        print(&quot;2&quot;)</span><br><span class="line">        print(try divide(20, 0))</span><br><span class="line">        print(&quot;3&quot;)</span><br><span class="line">    &#125; catch let SomeError.illegalArg(msg) &#123;</span><br><span class="line">        print(&quot;参数异常:&quot;, msg)</span><br><span class="line">    &#125; catch let SomeError.outOfBounds(size, index) &#123;</span><br><span class="line">        print(&quot;下标越界:&quot;, &quot;size=\(size)&quot;, &quot;index=\(index)&quot;)</span><br><span class="line">    &#125; catch SomeError.outOfMemory &#123;</span><br><span class="line">        print(&quot;内存溢出&quot;)</span><br><span class="line">    &#125; catch &#123;</span><br><span class="line">        print(&quot;其他错误&quot;) &#125;</span><br><span class="line">        print(&quot;4&quot;) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test()</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// 参数异常: 0不能作为除数</span><br><span class="line">// 4</span><br><span class="line"></span><br><span class="line">do &#123;</span><br><span class="line">    try divide(20, 0)</span><br><span class="line">&#125; catch let error &#123;</span><br><span class="line">    switch error &#123;</span><br><span class="line">    case let SomeError.illegalArg(msg):</span><br><span class="line">        print(&quot;参数错误：&quot;, msg)</span><br><span class="line">    default:</span><br><span class="line">        print(&quot;其他错误&quot;) </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>抛出Error后，try下一句直到作用域结束的代码都将停止运行</li></ul><h3 id="处理Error"><a href="#处理Error" class="headerlink" title="处理Error"></a>处理Error</h3><ul><li>处理Error的2种方式</li><li>① 通过 <code>do-catch </code>捕捉Error</li><li>② 不捕捉Error，在当前函数增加 <code>throws </code>声明，Error将自动抛给上层函数</li><li>如果最顶层函数（main函数）依然没有捕捉Error，那么程序将终止<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">func test() throws &#123;</span><br><span class="line">    print(&quot;1&quot;)</span><br><span class="line">    print(try divide(20, 0))</span><br><span class="line">    print(&quot;2&quot;) </span><br><span class="line">&#125;</span><br><span class="line">try test()</span><br><span class="line">// 1</span><br><span class="line">// Fatal error: Error raised at top level</span><br><span class="line"></span><br><span class="line">do &#123;</span><br><span class="line">    print(try divide(20, 0))</span><br><span class="line">&#125; catch is SomeError &#123;</span><br><span class="line">    print(&quot;SomeError&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func test() throws &#123;</span><br><span class="line">    print(&quot;1&quot;)</span><br><span class="line">    do &#123;</span><br><span class="line">    print(&quot;2&quot;)</span><br><span class="line">    print(try divide(20, 0))</span><br><span class="line">    print(&quot;3&quot;)</span><br><span class="line">    &#125; catch let error as SomeError &#123;</span><br><span class="line">        print(error)</span><br><span class="line">    &#125;</span><br><span class="line">    print(&quot;4&quot;) </span><br><span class="line">&#125;</span><br><span class="line">try test()</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// illegalArg(&quot;0不能作为除数&quot;)</span><br><span class="line">// 4</span><br></pre></td></tr></table></figure></li></ul><h3 id="try-、try"><a href="#try-、try" class="headerlink" title="try?、try!"></a>try?、try!</h3><ul><li>可以使用try?、try!调用可能会抛出Error的函数，这样就不用去处理Error<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func test() &#123;</span><br><span class="line">    print(&quot;1&quot;)</span><br><span class="line">    var result1 = try? divide(20, 10) // Optional(2), Int?</span><br><span class="line">    var result2 = try? divide(20, 0) // nil</span><br><span class="line">    var result3 = try! divide(20, 10) // 2, Int</span><br><span class="line">    print(&quot;2&quot;)</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br></pre></td></tr></table></figure></li><li>a、b是等价的<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = try? divide(20, 0)</span><br><span class="line">var b: Int?</span><br><span class="line">do &#123;</span><br><span class="line">    b = try divide(20, 0)</span><br><span class="line">&#125; catch &#123; b = nil &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="rethrows"><a href="#rethrows" class="headerlink" title="rethrows"></a>rethrows</h3><ul><li>rethrows表明：函数本身不会抛出错误，但调用闭包参数抛出错误，那么它会将错误向上抛<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func exec(_ fn: (Int, Int) throws -&gt; Int, _ num1: Int, _ num2: Int) rethrows &#123;</span><br><span class="line">    print(try fn(num1, num2))</span><br><span class="line">&#125;</span><br><span class="line">// Fatal error: Error raised at top level</span><br><span class="line">try exec(divide, 20, 0)</span><br></pre></td></tr></table></figure></li></ul><h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><ul><li>defer语句：用来定义以任何方式（抛错误、return等）离开代码块前必须要执行的代码</li><li>defer语句将延迟至当前作用域结束之前执行<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">func open(_ filename: String) -&gt; Int &#123;</span><br><span class="line">    print(&quot;open&quot;)</span><br><span class="line">    return 0 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func close(_ file: Int) &#123;</span><br><span class="line">    print(&quot;close&quot;) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func processFile(_ filename: String) throws &#123;</span><br><span class="line">    let file = open(filename)</span><br><span class="line">    defer &#123;</span><br><span class="line">        close(file)</span><br><span class="line">    &#125;</span><br><span class="line">    // 使用file</span><br><span class="line">    // ....</span><br><span class="line">    try divide(20, 0)</span><br><span class="line">    // close将会在这里调用</span><br><span class="line">&#125;</span><br><span class="line">try processFile(&quot;test.txt&quot;)</span><br><span class="line">// open</span><br><span class="line">// close</span><br><span class="line">// Fatal error: Error raised at top level</span><br></pre></td></tr></table></figure></li><li>defer语句的执行顺序与定义顺序相反<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func fn1() &#123; print(&quot;fn1&quot;) &#125;</span><br><span class="line">func fn2() &#123; print(&quot;fn2&quot;) &#125;</span><br><span class="line">func test() &#123;</span><br><span class="line">    defer &#123; fn1() &#125;</span><br><span class="line">    defer &#123; fn2() &#125;</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br><span class="line">// fn2</span><br><span class="line">// fn1</span><br></pre></td></tr></table></figure></li></ul><h3 id="assert（断言）"><a href="#assert（断言）" class="headerlink" title="assert（断言）"></a>assert（断言）</h3><ul><li>很多编程语言都有断言机制：不符合指定条件就抛出运行时错误，常用于调试（Debug）阶段的条件判断</li><li>默认情况下，Swift的断言只会在Debug模式下生效，Release模式下会忽略<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func divide(_ v1: Int, _ v2: Int) -&gt; Int &#123;</span><br><span class="line">assert(v2 != 0, &quot;除数不能为0&quot;)</span><br><span class="line">return v1 / v2</span><br><span class="line">&#125;</span><br><span class="line">print(divide(20, 0))</span><br></pre></td></tr></table></figure></li><li>增加Swift Flags修改断言的默认行为</li><li><code>-assert-config Release </code>：强制关闭断言</li><li><code>-assert-config Debug </code>：强制开启断言</li></ul><h3 id="fatalError"><a href="#fatalError" class="headerlink" title="fatalError"></a>fatalError</h3><ul><li><p>如果遇到严重问题，希望结束程序运行时，可以直接使用fatalError函数抛出错误（这是无法通过do-catch捕捉的错误）</p></li><li><p>使用了fatalError函数，就不需要再写return</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func test(_ num: Int) -&gt; Int &#123;</span><br><span class="line">    if num &gt;= 0 &#123;</span><br><span class="line">        return 1 </span><br><span class="line">    &#125;</span><br><span class="line">    fatalError(&quot;num不能小于0&quot;) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在某些不得不实现、但不希望别人调用的方法，可以考虑内部使用fatalError函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123; required init() &#123;&#125; &#125;</span><br><span class="line">class Student : Person &#123;</span><br><span class="line">    required init() &#123; fatalError(&quot;don&#x27;t call Student.init&quot;) &#125;</span><br><span class="line">    init(score: Int) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">var stu1 = Student(score: 98)</span><br><span class="line">var stu2 = Student()</span><br></pre></td></tr></table></figure></li></ul><h3 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h3><ul><li>可以使用 do 实现局部作用域<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">    let dog1 = Dog()</span><br><span class="line">    dog1.age = 10</span><br><span class="line">    dog1.run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">do &#123;</span><br><span class="line">    let dog2 = Dog()</span><br><span class="line">    dog2.age = 10</span><br><span class="line">    dog2.run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;错误类型&quot;&gt;&lt;a href=&quot;#错误类型&quot; class=&quot;headerlink&quot; title=&quot;错误类型&quot;&gt;&lt;/a&gt;错误类型&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;开发过程常见的错误&lt;ul&gt;
&lt;li&gt;语法错误（编译错误）&lt;/li&gt;
&lt;li&gt;逻辑错误&lt;/li&gt;
&lt;li&gt;运行时错</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Swift" scheme="http://www.hxtec.top/tags/Swift/"/>
    
    <category term="语法" scheme="http://www.hxtec.top/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Swift-协议（Protocol）</title>
    <link href="http://www.hxtec.top/2022/09/19/Swift-%E5%8D%8F%E8%AE%AE%EF%BC%88Protocol%EF%BC%89/"/>
    <id>http://www.hxtec.top/2022/09/19/Swift-%E5%8D%8F%E8%AE%AE%EF%BC%88Protocol%EF%BC%89/</id>
    <published>2022-09-19T03:02:32.000Z</published>
    <updated>2022-09-19T03:33:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>协议可以用来定义方法、属性、下标的声明，协议可以被枚举、结构体、类遵守（多个协议之间用逗号隔开）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protocol Drawable &#123;</span><br><span class="line">    func draw()</span><br><span class="line">    var x: Int &#123; get set &#125;</span><br><span class="line">    var y: Int &#123; get &#125;</span><br><span class="line">    subscript(index: Int) -&gt; Int &#123; get set &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">protocol Test1 &#123;&#125;</span><br><span class="line">protocol Test2 &#123;&#125;</span><br><span class="line">protocol Test3 &#123;&#125;</span><br><span class="line">class TestClass : Test1, Test2, Test3 &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>协议中定义方法时不能有默认参数值</li><li>默认情况下，协议中定义的内容必须全部都实现</li><li>也有办法办到只实现部分内容，后面会体现</li></ul><h3 id="协议中的属性"><a href="#协议中的属性" class="headerlink" title="协议中的属性"></a>协议中的属性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">protocol Drawable &#123;</span><br><span class="line">    func draw()</span><br><span class="line">    var x: Int &#123; get set &#125;</span><br><span class="line">    var y: Int &#123; get &#125;</span><br><span class="line">    subscript(index: Int) -&gt; Int &#123; get set &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//第一种方式</span><br><span class="line">class Person : Drawable &#123;</span><br><span class="line">    var x: Int = 0</span><br><span class="line">    let y: Int = 0</span><br><span class="line">    func draw() &#123;</span><br><span class="line">        print(&quot;Person draw&quot;) </span><br><span class="line">    &#125;</span><br><span class="line">    subscript(index: Int) -&gt; Int &#123;</span><br><span class="line">        set &#123;&#125;</span><br><span class="line">        get &#123; index &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//第2种方式</span><br><span class="line">class Person : Drawable &#123;</span><br><span class="line">    var x: Int &#123;</span><br><span class="line">        get &#123; 0 &#125;</span><br><span class="line">        set &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var y: Int &#123; 0 &#125;</span><br><span class="line">    func draw() &#123; print(&quot;Person draw&quot;) &#125;</span><br><span class="line">    subscript(index: Int) -&gt; Int &#123;</span><br><span class="line">        set &#123;&#125;</span><br><span class="line">        get &#123; index &#125;   </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="static-class"><a href="#static-class" class="headerlink" title="static, class"></a>static, class</h3><ul><li>为了保证通用，协议中必须用static定义类型方法、类型属性、类型下标</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">protocol Drawable &#123;</span><br><span class="line">    static func draw()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person1 : Drawable &#123;</span><br><span class="line">    class func draw() &#123;</span><br><span class="line">        print(&quot;Person1 draw&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person2 : Drawable &#123;</span><br><span class="line">    static func draw() &#123;</span><br><span class="line">    print(&quot;Person2 draw&quot;) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mutating"><a href="#mutating" class="headerlink" title="mutating"></a>mutating</h3><ul><li>只有将协议中的实例方法标记为 <code>mutating </code><ul><li>才允许结构体、枚举的具体实现修改自身内存</li><li>类在实现方法时不用加 <code>mutating </code>，枚举、结构体才需要添加 <code>mutating </code></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">protocol Drawable &#123;</span><br><span class="line">    mutating func draw()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//类在实现方法时不用加mutating</span><br><span class="line">class Size : Drawable &#123;</span><br><span class="line">    var width: Int = 0</span><br><span class="line">    func draw() &#123;</span><br><span class="line">        width = 10</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//枚举、结构体才需要添加mutating</span><br><span class="line">struct Point : Drawable &#123;</span><br><span class="line">    var x: Int = 0</span><br><span class="line">    mutating func draw() &#123;</span><br><span class="line">        x = 10</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><ul><li>协议中还可以定义初始化器init</li><li>非final类实现时必须加上required</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protocol Drawable &#123;</span><br><span class="line">    init(x: Int, y: Int)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Point : Drawable &#123;</span><br><span class="line">    required init(x: Int, y: Int) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final class Size : Drawable &#123;</span><br><span class="line">    init(x: Int, y: Int) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果从协议实现的初始化器，刚好是重写了父类的指定初始化器</li><li>那么这个初始化必须同时加上required, override</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">protocol Livable &#123;</span><br><span class="line">    init(age: Int)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">    init(age: Int) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student : Person, Livable &#123;</span><br><span class="line">    required override init(age: Int) &#123;</span><br><span class="line">        super.init(age: age)</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="init、init-、init"><a href="#init、init-、init" class="headerlink" title="init、init?、init!"></a>init、init?、init!</h3><ul><li>协议中定义的init?、init!，可以用init、init?、init!去实现</li><li>协议中定义的init，可以用init、init!去实现</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">protocol Livable &#123;</span><br><span class="line">    init()</span><br><span class="line">    init?(age: Int)</span><br><span class="line">    init!(no: Int)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person : Livable &#123;</span><br><span class="line">    required init() &#123;&#125;</span><br><span class="line">    // required init!() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    required init?(age: Int) &#123;&#125;</span><br><span class="line">    // required init!(age: Int) &#123;&#125;</span><br><span class="line">    // required init(age: Int) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    required init!(no: Int) &#123;&#125;</span><br><span class="line">    // required init?(no: Int) &#123;&#125;</span><br><span class="line">    // required init(no: Int) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="协议的继承"><a href="#协议的继承" class="headerlink" title="协议的继承"></a>协议的继承</h3><ul><li>一个协议可以继承其他协议</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protocol Runnable &#123;</span><br><span class="line">    func run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol Livable : Runnable &#123;</span><br><span class="line">    func breath()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person : Livable &#123;</span><br><span class="line">    func breath() &#123;&#125;</span><br><span class="line">    func run() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="协议组合"><a href="#协议组合" class="headerlink" title="协议组合"></a>协议组合</h3><ul><li>协议组合，可以包含1个类类型（最多1个）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">protocol Livable &#123;&#125;</span><br><span class="line">protocol Runnable &#123;&#125;</span><br><span class="line">class Person &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 接收Person或者其子类的实例</span><br><span class="line">func fn0(obj: Person) &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 接收遵守Livable协议的实例</span><br><span class="line">func fn1(obj: Livable) &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 接收同时遵守Livable、Runnable协议的实例</span><br><span class="line">func fn2(obj: Livable &amp; Runnable) &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 接收同时遵守Livable、Runnable协议、并且是Person或者其子类的实例</span><br><span class="line">func fn3(obj: Person &amp; Livable &amp; Runnable) &#123;&#125;</span><br><span class="line"></span><br><span class="line">typealias RealPerson = Person &amp; Livable &amp; Runnable</span><br><span class="line">// 接收同时遵守Livable、Runnable协议、并且是Person或者其子类的实例</span><br><span class="line">func fn4(obj: RealPerson) &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="CaseIterable"><a href="#CaseIterable" class="headerlink" title="CaseIterable"></a>CaseIterable</h3><ul><li>让枚举遵守CaseIterable协议，可以实现遍历枚举值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">enum Season : CaseIterable &#123;</span><br><span class="line">    case spring, summer, autumn, winter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let seasons = Season.allCases</span><br><span class="line">print(seasons.count) // 4</span><br><span class="line"></span><br><span class="line">for season in seasons &#123;</span><br><span class="line">    print(season)</span><br><span class="line">&#125; // spring summer autumn winter</span><br></pre></td></tr></table></figure><h3 id="CustomStringConvertible"><a href="#CustomStringConvertible" class="headerlink" title="CustomStringConvertible"></a>CustomStringConvertible</h3><ul><li>遵守 <code>CustomStringConvertible </code>、 <code>CustomDebugStringConvertible </code>协议，都可以自定义实例的打印字符串</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Person : CustomStringConvertible, CustomDebugStringConvertible &#123;</span><br><span class="line">    var age = 0</span><br><span class="line">    var description: String &#123; &quot;person_\(age)&quot; &#125;</span><br><span class="line">    var debugDescription: String &#123; &quot;debug_person_\(age)&quot; &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = Person()</span><br><span class="line">print(person) // person_0</span><br><span class="line">debugPrint(person) // debug_person_0</span><br></pre></td></tr></table></figure><ul><li>print调用的是CustomStringConvertible协议的description</li><li>debugPrint、po调用的是CustomDebugStringConvertible协议的debugDescription</li></ul><h3 id="Any、AnyObject"><a href="#Any、AnyObject" class="headerlink" title="Any、AnyObject"></a>Any、AnyObject</h3><ul><li>Swift提供了2种特殊的类型：Any、AnyObject</li><li>Any：可以代表任意类型（枚举、结构体、类，也包括函数类型）</li><li>AnyObject：可以代表任意类类型（在协议后面写上:AnyObject代表只有类能遵守这个协议）</li><li>在协议后面写上: class也代表只有类能遵守这个协议</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var stu: Any = 10</span><br><span class="line">stu = &quot;Jack&quot;</span><br><span class="line">stu = Student()</span><br><span class="line"></span><br><span class="line">// 创建1个能存放任意类型的数组</span><br><span class="line">// var data = Array&lt;Any&gt;()</span><br><span class="line">var data = [Any]()</span><br><span class="line">data.append(1)</span><br><span class="line">data.append(3.14)</span><br><span class="line">data.append(Student())</span><br><span class="line">data.append(&quot;Jack&quot;)</span><br><span class="line">data.append(&#123; 10 &#125;)</span><br></pre></td></tr></table></figure><h3 id="is、as-、as-、as"><a href="#is、as-、as-、as" class="headerlink" title="is、as?、as!、as"></a>is、as?、as!、as</h3><ul><li>is用来判断是否为某种类型，as用来做强制类型转换</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">protocol Runnable &#123; func run() &#125;</span><br><span class="line"></span><br><span class="line">class Person &#123;&#125;</span><br><span class="line"></span><br><span class="line">class Student : Person, Runnable &#123;</span><br><span class="line">    func run() &#123;</span><br><span class="line">        print(&quot;Student run&quot;) </span><br><span class="line">    &#125;</span><br><span class="line">    func study() &#123;</span><br><span class="line">        print(&quot;Student study&quot;) </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var stu: Any = 10</span><br><span class="line">print(stu is Int) // true</span><br><span class="line">stu = &quot;Jack&quot;</span><br><span class="line">print(stu is String) // true</span><br><span class="line">stu = Student()</span><br><span class="line">print(stu is Person) // true</span><br><span class="line">print(stu is Student) // true</span><br><span class="line">print(stu is Runnable) // true</span><br><span class="line"></span><br><span class="line">var stu: Any = 10</span><br><span class="line">(stu as? Student)?.study() // 没有调用study</span><br><span class="line">stu = Student()</span><br><span class="line">(stu as? Student)?.study() // Student study</span><br><span class="line">(stu as! Student).study() // Student study</span><br><span class="line">(stu as? Runnable)?.run() // Student run</span><br><span class="line"></span><br><span class="line">var data = [Any]()</span><br><span class="line">data.append(Int(&quot;123&quot;) as Any)</span><br><span class="line"></span><br><span class="line">var d = 10 as Double</span><br><span class="line">print(d) // 10.0</span><br></pre></td></tr></table></figure><h3 id="X-self、X-Type、AnyClass"><a href="#X-self、X-Type、AnyClass" class="headerlink" title="X.self、X.Type、AnyClass"></a>X.self、X.Type、AnyClass</h3><ul><li>X.self是一个元类型（metadata）的指针，metadata存放着类型相关信息</li><li>X.self属于X.Type类型</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;&#125;</span><br><span class="line">class Student : Person &#123;&#125;</span><br><span class="line"></span><br><span class="line">var perType: Person.Type = Person.self</span><br><span class="line">var stuType: Student.Type = Student.self</span><br><span class="line">perType = Student.self</span><br><span class="line"></span><br><span class="line">var anyType: AnyObject.Type = Person.self</span><br><span class="line">anyType = Student.self</span><br><span class="line"></span><br><span class="line">public typealias AnyClass = AnyObject.Type</span><br><span class="line">var anyType2: AnyClass = Person.self</span><br><span class="line">anyType2 = Student.self</span><br><span class="line"></span><br><span class="line">var per = Person()</span><br><span class="line">var perType = type(of: per) // Person.self</span><br><span class="line">print(Person.self  ` type(of: per)) // true</span><br></pre></td></tr></table></figure><h3 id="元类型的应用"><a href="#元类型的应用" class="headerlink" title="元类型的应用"></a>元类型的应用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123; required init() &#123;&#125; &#125;</span><br><span class="line">class Cat : Animal &#123;&#125;</span><br><span class="line">class Dog : Animal &#123;&#125;</span><br><span class="line">class Pig : Animal &#123;&#125;</span><br><span class="line"></span><br><span class="line">func create(_ clses: [Animal.Type]) -&gt; [Animal] &#123;</span><br><span class="line">    var arr = [Animal]()</span><br><span class="line">    for cls in clses &#123;</span><br><span class="line">    arr.append(cls.init())</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(create([Cat.self, Dog.self, Pig.self]))</span><br></pre></td></tr></table></figure><ul><li>从以下结果可以看得出来，Swift还有个隐藏的基类：Swift._SwiftObject</li><li>可以参考Swift源码：<a href="https://github.com/apple/swift/blob/master/stdlib/public/runtime/SwiftObject.h">https://github.com/apple/swift/blob/master/stdlib/public/runtime/SwiftObject.h</a></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import Foundation</span><br><span class="line">class Person &#123;</span><br><span class="line">var age: Int = 0 &#125;</span><br><span class="line">class Student : Person &#123;</span><br><span class="line">var no: Int = 0 &#125;</span><br><span class="line">print(class_getInstanceSize(Student.self)) // 32</span><br><span class="line">print(class_getSuperclass(Student.self)!) // Person</span><br><span class="line">print(class_getSuperclass(Person.self)!) // Swift._SwiftObject</span><br></pre></td></tr></table></figure><h3 id="Self"><a href="#Self" class="headerlink" title="Self"></a>Self</h3><ul><li><code>Self </code>一般用作返回值类型，限定返回值跟方法调用者必须是同一类型（也可以作为参数类型）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">protocol Runnable &#123;</span><br><span class="line">    func test() -&gt; Self</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person : Runnable &#123;</span><br><span class="line">    required init() &#123;&#125;</span><br><span class="line">    func test() -&gt; Self &#123; type(of: self).init() &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student : Person &#123;&#125;</span><br><span class="line"></span><br><span class="line">var p = Person()</span><br><span class="line">// Person</span><br><span class="line">print(p.test())</span><br><span class="line">var stu = Student()</span><br><span class="line">// Student</span><br><span class="line">print(stu.test())</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;协议可以用来定义方法、属性、下标的声明，协议可以被枚举、结构体、类遵守（多个协议之间用逗号隔开）&lt;/li&gt;
&lt;/ul&gt;
&lt;fig</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Swift" scheme="http://www.hxtec.top/tags/Swift/"/>
    
    <category term="语法" scheme="http://www.hxtec.top/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Swift-初始化，可选链</title>
    <link href="http://www.hxtec.top/2022/09/19/Swift-%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%8C%E5%8F%AF%E9%80%89%E9%93%BE/"/>
    <id>http://www.hxtec.top/2022/09/19/Swift-%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%8C%E5%8F%AF%E9%80%89%E9%93%BE/</id>
    <published>2022-09-19T03:02:20.000Z</published>
    <updated>2022-09-19T03:31:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="初始化器"><a href="#初始化器" class="headerlink" title="初始化器"></a>初始化器</h2><ul><li>类、结构体、枚举都可以定义初始化器</li><li>类有2种初始化器：指定初始化器（designated initializer）、便捷初始化器（convenience initializer）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 指定初始化器</span><br><span class="line">init(parameters) &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br><span class="line">// 便捷初始化器</span><br><span class="line">    convenience init(parameters) &#123;</span><br><span class="line">statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>每个类至少有一个指定初始化器，指定初始化器是类的主要初始化器<ul><li>默认初始化器总是类的指定初始化器</li><li>类偏向于少量指定初始化器，一个类通常只有一个指定初始化器</li></ul></li><li>初始化器的相互调用规则<ul><li>指定初始化器必须从它的直系父类调用指定初始化器</li><li>便捷初始化器必须从相同的类里调用另一个初始化器</li><li>便捷初始化器最终必须调用一个指定初始化器</li></ul></li></ul><h3 id="初始化器的相互调用"><a href="#初始化器的相互调用" class="headerlink" title="初始化器的相互调用"></a>初始化器的相互调用</h3><ul><li>这一套规则保证了，使用任意初始化器，都可以完整地初始化实例</li></ul><h3 id="两段式初始化"><a href="#两段式初始化" class="headerlink" title="两段式初始化"></a>两段式初始化</h3><ul><li>Swift在编码安全方面是煞费苦心，为了保证初始化过程的安全，设定了两段式初始化、安全检查</li><li>两段式初始化<ol><li>第1阶段：初始化所有存储属性<ol><li>外层调用指定&#x2F;便捷初始化器</li><li>分配内存给实例，但未初始化</li><li>指定初始化器确保当前类定义的存储属性都初始化</li><li>指定初始化器调用父类的初始化器，不断向上调用，形成初始化器链</li></ol></li><li>第2阶段：设置新的存储属性值<ol><li>从顶部初始化器往下，链中的每一个指定初始化器都有机会进一步定制实例</li><li>初始化器现在能够使用self（访问、修改它的属性，调用它的实例方法等等）</li><li>最终，链中任何便捷初始化器都有机会定制实例以及使用self</li></ol></li></ol></li></ul><h3 id="安全检查"><a href="#安全检查" class="headerlink" title="安全检查"></a>安全检查</h3><ul><li>指定初始化器必须保证在调用父类初始化器之前，其所在类定义的所有存储属性都要初始化完成</li><li>指定初始化器必须先调用父类初始化器，然后才能为继承的属性设置新值 </li><li>便捷初始化器必须先调用同类中其它初始化，然后再为任意属性设置新值</li><li>初始化器在第1阶段初始化完成之前，不能调用任何实例方法，不能读取任何实例属性的值，也不能引用self</li><li>直到第1阶段结束，实例才算完全合法</li></ul><h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><ul><li>当重写父类的指定初始化器时，必须加上override(即使子类的实现是便捷初始化器)</li><li>如果子类写了一个匹配父类便捷初始化器的初始化器，不用加上override，因为父类的便捷初始化器永远不会通过子类直接调用，因此，严格来说，子类无法重写父类的便捷初始化器</li></ul><h3 id="自动继承"><a href="#自动继承" class="headerlink" title="自动继承"></a>自动继承</h3><ul><li>1.如果子类没有自定义任何初始化器，它会自动继承父类所有的初始化器</li><li>2.如何子类提供了父类所有指定初始化器的实现（要么通过1方式继承，要么重写），那么子类自动继承所有的父类的便捷初始化器</li><li>3.就算子类添加了更多的便捷初始化器，这些规则仍然适用</li><li>4.子类以便捷初始化器的形式重写父类的指定初始化器，也可作为满足规则2的一部分</li></ul><h3 id="required"><a href="#required" class="headerlink" title="required"></a>required</h3><ul><li>用required修饰指定初始化器，表明其所有子类都必须实现该初始化器（通过继承或者重写实现）</li><li>如果子类重写了required初始化器，也必须加上required，不用加override</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    required init() &#123; &#125;</span><br><span class="line">        init(age: Int) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Student : Person &#123;</span><br><span class="line">    required init() &#123;</span><br><span class="line">        super.init()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="属性观察器"><a href="#属性观察器" class="headerlink" title="属性观察器"></a>属性观察器</h3><ul><li>父类的属性在它自己的初始化器中赋值不会触发属性观察器，但在子类的初始化器中赋值会触发属性观察器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    var age: Int &#123;</span><br><span class="line">        willSet &#123;</span><br><span class="line">            print(&quot;willSet&quot;, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            print(&quot;didSet&quot;, oldValue, age)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    init() &#123;</span><br><span class="line">        self.age = 0</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student : Person &#123;</span><br><span class="line">    override init() &#123;</span><br><span class="line">        super.init()</span><br><span class="line">        self.age = 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// willSet 1，触发父类的属性观察器</span><br><span class="line">// didSet 0 1</span><br><span class="line">var stu = Student()</span><br></pre></td></tr></table></figure><h3 id="可失败初始化器"><a href="#可失败初始化器" class="headerlink" title="可失败初始化器"></a>可失败初始化器</h3><ul><li>类、结构体、枚举都可以使用init?定义可失败初始化器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123; </span><br><span class="line">    var name: String </span><br><span class="line">    init?(name: String) &#123; </span><br><span class="line">        if name.isEmpty &#123; </span><br><span class="line">            return nil </span><br><span class="line">        &#125; </span><br><span class="line">        self.name = name </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>之前接触过的可失败初始化器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var num = Int(&quot;123&quot;)</span><br><span class="line">public init?(_ description: String)</span><br><span class="line"></span><br><span class="line">enum Answer : Int &#123;</span><br><span class="line">    case wrong, right</span><br><span class="line">&#125;</span><br><span class="line">var an = Answer(rawValue: 1)</span><br></pre></td></tr></table></figure><ul><li>不允许同时定义参数标签、参数个数、参数类型相同的可失败初始化器和非可失败初始化器</li><li>可以用init!定义隐式解包的可失败初始化器</li><li>可失败初始化器可以调用非可失败初始化器，非可失败初始化器调用可失败初始化器需要进行解包</li><li>如果初始化器调用一个可失败初始化器导致初始化失败，那么整个初始化过程都失败，并且之后的代码都停止执行</li><li>可以用一个非可失败初始化器重写一个可失败初始化器，但反过来是不行的</li></ul><h3 id="反初始化器（deinit）"><a href="#反初始化器（deinit）" class="headerlink" title="反初始化器（deinit）"></a>反初始化器（deinit）</h3><ul><li>deinit叫做反初始化器，类似于C++的析构函数，OC中的dealloc方法</li><li>当类的实例对象被释放内存时，就会调用实例对象的deinit方法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    deinit &#123;</span><br><span class="line">        print(&quot;Person对象销毁了&quot;) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>deinit不接受任何参数，不能写小括号，不能自行调用</li><li>父类的deinit能被子类继承</li><li>子类的deinit实现执行完毕后会调用父类的deinit</li></ul><h3 id="可选链（Optional-Chaining）"><a href="#可选链（Optional-Chaining）" class="headerlink" title="可选链（Optional Chaining）"></a>可选链（Optional Chaining）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Car &#123; var price = 0 &#125;</span><br><span class="line">class Dog &#123; var weight = 0 &#125;</span><br><span class="line">class Person &#123;</span><br><span class="line">    var name: String = &quot;&quot;</span><br><span class="line">    var dog: Dog = Dog()</span><br><span class="line">    var car: Car? = Car()</span><br><span class="line">    func age() -&gt; Int &#123; 18 &#125;</span><br><span class="line">    func eat() &#123; print(&quot;Person eat&quot;) &#125;</span><br><span class="line">    subscript(index: Int) -&gt; Int &#123; index &#125;</span><br><span class="line">&#125;</span><br><span class="line">var person: Person? = Person()</span><br><span class="line">var age1 = person!.age() // Int</span><br><span class="line">var age2 = person?.age() // Int?</span><br><span class="line">var name = person?.name // String?</span><br><span class="line">var index = person?[6] // Int?</span><br><span class="line"></span><br><span class="line">func getName() -&gt; String &#123; &quot;jack&quot; &#125;</span><br><span class="line"></span><br><span class="line">// 如果person是nil，不会调用getName()</span><br><span class="line">person?.name = getName()</span><br></pre></td></tr></table></figure><ul><li>如果可选项为&#x3D;&#x3D;nil&#x3D;&#x3D;，调用方法、下标、属性失败，结果为&#x3D;&#x3D;nil&#x3D;&#x3D;</li><li>如果可选项不为&#x3D;&#x3D;nil&#x3D;&#x3D;，调用方法、下标、属性成功，结果会被包装成可选项</li><li>如果结果本来就是可选项，不会进行再次包装</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if let _ = person?.eat() &#123; // ()?</span><br><span class="line">    print(&quot;eat调用成功&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    print(&quot;eat调用失败&quot;) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var dog = person?.dog // Dog?</span><br><span class="line">var weight = person?.dog.weight // Int?</span><br><span class="line">var price = person?.car?.price // Int?</span><br></pre></td></tr></table></figure><ul><li>多个?可以链接在一起</li><li>如果链中任何一个节点是&#x3D;&#x3D;nil&#x3D;&#x3D;，那么整个链就会调用失败</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;初始化器&quot;&gt;&lt;a href=&quot;#初始化器&quot; class=&quot;headerlink&quot; title=&quot;初始化器&quot;&gt;&lt;/a&gt;初始化器&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;类、结构体、枚举都可以定义初始化器&lt;/li&gt;
&lt;li&gt;类有2种初始化器：指定初始化器（designated in</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Swift" scheme="http://www.hxtec.top/tags/Swift/"/>
    
    <category term="语法" scheme="http://www.hxtec.top/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Swift-继承</title>
    <link href="http://www.hxtec.top/2022/09/19/Swift-%E7%BB%A7%E6%89%BF/"/>
    <id>http://www.hxtec.top/2022/09/19/Swift-%E7%BB%A7%E6%89%BF/</id>
    <published>2022-09-19T03:01:48.000Z</published>
    <updated>2022-09-19T03:15:25.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="继承-Inheritance"><a href="#继承-Inheritance" class="headerlink" title="继承(Inheritance)"></a>继承(Inheritance)</h2><ul><li>值类型（枚举、结构体）不支持继承，只有类支持继承</li><li>没有父类的类，称为：基类<ul><li>Swift并没有像OC、Java那样的规定，任何类最终都要继承自某个基类</li></ul></li><li>子类可以重写父类的 <code>下标、方法、属性 </code>，重写必须加上 <code>override </code>关键字</li></ul><h3 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    var age = 0 </span><br><span class="line">&#125;</span><br><span class="line">class Dog : Animal &#123;</span><br><span class="line">    var weight = 0 </span><br><span class="line">&#125;</span><br><span class="line">class ErHa : Dog &#123;</span><br><span class="line">    var iq = 0</span><br><span class="line">&#125;</span><br><span class="line">let a = Animal()</span><br><span class="line">a.age = 10</span><br><span class="line">// 32</span><br><span class="line">print(Mems.size(ofRef: a))</span><br><span class="line">/*</span><br><span class="line">0x00000001000073e0  //类型信息</span><br><span class="line">0x0000000000000002  //引用计数 </span><br><span class="line">0x000000000000000a</span><br><span class="line">0x0000000000000000</span><br><span class="line">*/</span><br><span class="line">print(Mems.memStr(ofRef: a))</span><br><span class="line"></span><br><span class="line">let d = Dog()</span><br><span class="line">d.age = 10</span><br><span class="line">d.weight = 20</span><br><span class="line">// 32</span><br><span class="line">print(Mems.size(ofRef: d))</span><br><span class="line">/*</span><br><span class="line">0x0000000100007490</span><br><span class="line">0x0000000000000002</span><br><span class="line">0x000000000000000a</span><br><span class="line">0x0000000000000014</span><br><span class="line">*/</span><br><span class="line">print(Mems.memStr(ofRef: d))</span><br><span class="line"></span><br><span class="line">let e = ErHa()</span><br><span class="line">e.age = 10</span><br><span class="line">e.weight = 20</span><br><span class="line">e.iq = 30</span><br><span class="line">// 48</span><br><span class="line">print(Mems.size(ofRef: e))</span><br><span class="line">/*</span><br><span class="line">0x0000000100007560</span><br><span class="line">0x0000000000000002</span><br><span class="line">0x000000000000000a</span><br><span class="line">0x0000000000000014</span><br><span class="line">0x000000000000001e</span><br><span class="line">0x0000000000000000</span><br><span class="line">*/</span><br><span class="line">print(Mems.memStr(ofRef: e))</span><br></pre></td></tr></table></figure><h2 id="重写实例方法、下标"><a href="#重写实例方法、下标" class="headerlink" title="重写实例方法、下标"></a>重写实例方法、下标</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    func speak() &#123;</span><br><span class="line">        print(&quot;Animal speak&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    subscript(index: Int) -&gt; Int &#123;</span><br><span class="line">        return index</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat : Animal &#123;</span><br><span class="line">    override func speak() &#123;</span><br><span class="line">        super.speak()</span><br><span class="line">        print(&quot;Cat speak&quot;) </span><br><span class="line">    &#125;</span><br><span class="line">    override subscript(index: Int) -&gt; Int &#123;</span><br><span class="line">        return super[index] + 1 </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">var anim: Animal</span><br><span class="line">anim = Animal()</span><br><span class="line">// Animal speak</span><br><span class="line">anim.speak()</span><br><span class="line">// 6</span><br><span class="line">print(anim[6])</span><br><span class="line"></span><br><span class="line">anim = Cat()</span><br><span class="line">// Animal speak</span><br><span class="line">// Cat speak</span><br><span class="line">anim.speak()</span><br><span class="line">// 7</span><br><span class="line">print(anim[6])</span><br></pre></td></tr></table></figure><ul><li>被 <code>class </code>修饰的类型方法、下标，允许被子类重写</li><li>被static修饰的类型方法、下标，不允许被子类重写</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    class func speak() &#123;</span><br><span class="line">        print(&quot;Animal speak&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    class subscript(index: Int) -&gt; Int &#123;</span><br><span class="line">        return index    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// Animal speak</span><br><span class="line">Animal.speak()</span><br><span class="line">// 6</span><br><span class="line">print(Animal[6])</span><br><span class="line"></span><br><span class="line">class Cat : Animal &#123;</span><br><span class="line">    override class func speak() &#123;</span><br><span class="line">        super.speak()</span><br><span class="line">        print(&quot;Cat speak&quot;) </span><br><span class="line">    &#125;</span><br><span class="line">    override class subscript(index: Int) -&gt; Int &#123;</span><br><span class="line">        return super[index] + 1 </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">// Animal speak</span><br><span class="line">// Cat speak</span><br><span class="line">Cat.speak()</span><br><span class="line">// 7</span><br><span class="line">print(Cat[6])</span><br></pre></td></tr></table></figure><h2 id="重写属性"><a href="#重写属性" class="headerlink" title="重写属性"></a>重写属性</h2><ul><li>子类可以将父类的属性（存储、计算）重写为 <code>计算属性 </code></li><li>子类 <code>不可以 </code>将父类属性重写为 <code>存储属性 </code></li><li>只能重写 <code>var </code>属性，不能重写 <code>let </code>属性</li><li>重写时，属性名、类型要一致</li><li>子类重写后的属性权限 不能小于 父类属性的权限<ul><li>如果父类属性是只读的，那么子类重写后的属性可以是只读的、也可以是可读写的</li><li>如果父类属性是可读写的，那么子类重写后的属性也必须是可读写的</li></ul></li></ul><h3 id="重写实例属性"><a href="#重写实例属性" class="headerlink" title="重写实例属性"></a>重写实例属性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">// 父类</span><br><span class="line">class Circle &#123;</span><br><span class="line">    var radius: Int = 0</span><br><span class="line">    var diameter: Int &#123;</span><br><span class="line">        set &#123;</span><br><span class="line">            print(&quot;Circle setDiameter&quot;)</span><br><span class="line">            radius = newValue / 2   </span><br><span class="line">        &#125;</span><br><span class="line">        get &#123;</span><br><span class="line">            print(&quot;Circle getDiameter&quot;)</span><br><span class="line">            return radius * 2 </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">var circle: Circle</span><br><span class="line">circle = Circle()</span><br><span class="line">circle.radius = 6</span><br><span class="line">// Circle getDiameter</span><br><span class="line">// 12</span><br><span class="line">print(circle.diameter)</span><br><span class="line">// Circle setDiameter</span><br><span class="line">circle.diameter = 20</span><br><span class="line">// 10</span><br><span class="line">print(circle.radius)</span><br><span class="line"></span><br><span class="line">// 子类</span><br><span class="line">class SubCircle : Circle &#123;</span><br><span class="line">    override var radius: Int &#123;</span><br><span class="line">        set &#123;</span><br><span class="line">            print(&quot;SubCircle setRadius&quot;)</span><br><span class="line">            super.radius = newValue &gt; 0 ? newValue : 0 &#125;</span><br><span class="line">        get &#123;</span><br><span class="line">            print(&quot;SubCircle getRadius&quot;)</span><br><span class="line">            return super.radius</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    override var diameter: Int &#123;</span><br><span class="line">        set &#123;</span><br><span class="line">            print(&quot;SubCircle setDiameter&quot;)</span><br><span class="line">            super.diameter = newValue &gt; 0 ? newValue : 0 </span><br><span class="line">        &#125;</span><br><span class="line">        get &#123;</span><br><span class="line">            print(&quot;SubCircle getDiameter&quot;)</span><br><span class="line">            return super.diameter</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">circle = SubCircle()</span><br><span class="line"></span><br><span class="line">// SubCircle setRadius</span><br><span class="line">circle.radius = 6</span><br><span class="line"></span><br><span class="line">// SubCircle getDiameter</span><br><span class="line">// Circle getDiameter</span><br><span class="line">// SubCircle getRadius</span><br><span class="line">// 12</span><br><span class="line">print(circle.diameter)</span><br><span class="line"></span><br><span class="line">// SubCircle setDiameter</span><br><span class="line">// Circle setDiameter</span><br><span class="line">// SubCircle setRadius</span><br><span class="line">circle.diameter = 20</span><br><span class="line"></span><br><span class="line">// SubCircle getRadius</span><br><span class="line">// 10</span><br><span class="line">print(circle.radius)</span><br></pre></td></tr></table></figure><h3 id="重写类型属性"><a href="#重写类型属性" class="headerlink" title="重写类型属性"></a>重写类型属性</h3><ul><li>被class修饰的计算类型属性，可以被子类重写</li><li>被static修饰的类型属性（存储，计算），不可以被子类重写</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class Circle &#123;</span><br><span class="line">    static var radius: Int = 0</span><br><span class="line">    class var diameter: Int &#123;</span><br><span class="line">        set &#123;</span><br><span class="line">            print(&quot;Circle setDiameter&quot;)</span><br><span class="line">            radius = newValue / 2 </span><br><span class="line">        &#125;</span><br><span class="line">        get &#123;</span><br><span class="line">            print(&quot;Circle getDiameter&quot;)</span><br><span class="line">            return radius * 2 </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SubCircle : Circle &#123;</span><br><span class="line">    override static var diameter: Int &#123;</span><br><span class="line">        set &#123;</span><br><span class="line">            print(&quot;SubCircle setDiameter&quot;)</span><br><span class="line">            super.diameter = newValue &gt; 0 ? newValue : 0 </span><br><span class="line">        &#125;</span><br><span class="line">        get &#123;</span><br><span class="line">            print(&quot;SubCircle getDiameter&quot;)</span><br><span class="line">            return super.diameter</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Circle.radius = 6</span><br><span class="line">// Circle getDiameter</span><br><span class="line">// 12</span><br><span class="line">print(Circle.diameter)</span><br><span class="line"></span><br><span class="line">// Circle setDiameter</span><br><span class="line">Circle.diameter = 20</span><br><span class="line"></span><br><span class="line">// 10</span><br><span class="line">print(Circle.radius)</span><br><span class="line">SubCircle.radius = 6</span><br><span class="line"></span><br><span class="line">// SubCircle getDiameter</span><br><span class="line">// Circle getDiameter</span><br><span class="line">// 12</span><br><span class="line">print(SubCircle.diameter)</span><br><span class="line"></span><br><span class="line">// SubCircle setDiameter</span><br><span class="line">// Circle setDiameter</span><br><span class="line">SubCircle.diameter = 20</span><br><span class="line"></span><br><span class="line">// 10</span><br><span class="line">print(SubCircle.radius)</span><br></pre></td></tr></table></figure><h2 id="属性观察器"><a href="#属性观察器" class="headerlink" title="属性观察器"></a>属性观察器</h2><ul><li>可以在子类中为父类属性（除了只读计算属性、let属性）增加属性观察器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">class Circle &#123;</span><br><span class="line">    var radius: Int = 1 </span><br><span class="line">&#125;</span><br><span class="line">class SubCircle : Circle &#123;</span><br><span class="line">    override var radius: Int &#123;</span><br><span class="line">        willSet &#123;</span><br><span class="line">            print(&quot;SubCircle willSetRadius&quot;, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            print(&quot;SubCircle didSetRadius&quot;, oldValue, radius)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var circle = SubCircle()</span><br><span class="line">// SubCircle willSetRadius 10</span><br><span class="line">// SubCircle didSetRadius 1 10</span><br><span class="line">circle.radius = 10</span><br><span class="line"></span><br><span class="line">//重写父类属性观察器</span><br><span class="line">class Circle &#123;</span><br><span class="line">    var radius: Int = 1 &#123;</span><br><span class="line">        willSet &#123;</span><br><span class="line">            print(&quot;Circle willSetRadius&quot;, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            print(&quot;Circle didSetRadius&quot;, oldValue, radius)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class SubCircle : Circle &#123;</span><br><span class="line">    override var radius: Int &#123;</span><br><span class="line">        willSet &#123;</span><br><span class="line">            print(&quot;SubCircle willSetRadius&quot;, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            print(&quot;SubCircle didSetRadius&quot;, oldValue, radius) </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">var circle = SubCircle()</span><br><span class="line">// SubCircle willSetRadius 10</span><br><span class="line">// Circle willSetRadius 10</span><br><span class="line">// Circle didSetRadius 1 10</span><br><span class="line">// SubCircle didSetRadius 1 10</span><br><span class="line">circle.radius = 10</span><br><span class="line"></span><br><span class="line">// 重写父类计算属性</span><br><span class="line">class Circle &#123;</span><br><span class="line">    var radius: Int &#123;</span><br><span class="line">        set &#123;</span><br><span class="line">            print(&quot;Circle setRadius&quot;, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        get &#123;</span><br><span class="line">            print(&quot;Circle getRadius&quot;)</span><br><span class="line">            return 20</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">class SubCircle : Circle &#123;</span><br><span class="line">    override var radius: Int &#123;</span><br><span class="line">        willSet &#123;</span><br><span class="line">            print(&quot;SubCircle willSetRadius&quot;, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            print(&quot;SubCircle didSetRadius&quot;, oldValue, radius) </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">var circle = SubCircle()</span><br><span class="line">// Circle getRadius</span><br><span class="line">// SubCircle willSetRadius 10</span><br><span class="line">// Circle setRadius 10</span><br><span class="line">// Circle getRadius</span><br><span class="line">// SubCircle didSetRadius 20 20</span><br><span class="line">circle.radius = 10</span><br><span class="line"></span><br><span class="line">// 重写父类类型属性</span><br><span class="line">class Circle &#123;</span><br><span class="line">    class var radius: Int &#123;</span><br><span class="line">        set &#123;</span><br><span class="line">            print(&quot;Circle setRadius&quot;, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        get &#123;</span><br><span class="line">            print(&quot;Circle getRadius&quot;)</span><br><span class="line">            return 20</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">class SubCircle : Circle &#123;</span><br><span class="line">    override static var radius: Int &#123;</span><br><span class="line">        willSet &#123;</span><br><span class="line">            print(&quot;SubCircle willSetRadius&quot;, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            print(&quot;SubCircle didSetRadius&quot;, oldValue, radius)</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// Circle getRadius</span><br><span class="line">// SubCircle willSetRadius 10</span><br><span class="line">// Circle setRadius 10</span><br><span class="line">// Circle getRadius</span><br><span class="line">// SubCircle didSetRadius 20 20</span><br><span class="line">SubCircle.radius = 10</span><br></pre></td></tr></table></figure><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><ul><li>被 <code>final </code>修饰的方法、下标、属性，禁止被重写</li><li>被 <code>final </code>修饰的类，禁止被继承</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;继承-Inheritance&quot;&gt;&lt;a href=&quot;#继承-Inheritance&quot; class=&quot;headerlink&quot; title=&quot;继承(Inheritance)&quot;&gt;&lt;/a&gt;继承(Inheritance)&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;值类型（枚举、结构体）不支持</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Swift" scheme="http://www.hxtec.top/tags/Swift/"/>
    
    <category term="语法" scheme="http://www.hxtec.top/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Swift-闭包，闭包表达式</title>
    <link href="http://www.hxtec.top/2022/09/19/Swift-%E9%97%AD%E5%8C%85%EF%BC%8C%E9%97%AD%E5%8C%85%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://www.hxtec.top/2022/09/19/Swift-%E9%97%AD%E5%8C%85%EF%BC%8C%E9%97%AD%E5%8C%85%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2022-09-19T01:51:58.000Z</published>
    <updated>2022-09-19T03:06:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闭包表达式"><a href="#闭包表达式" class="headerlink" title="闭包表达式"></a>闭包表达式</h2><blockquote><p>在Swift中，可以通过func定义一个函数，也可以通过 <code>闭包表达式 </code>定义一个函数</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 函数</span><br><span class="line">func sum(_ v1: Int, _ v2: Int) -&gt; Int &#123; v1 + v2 &#125;</span><br><span class="line"></span><br><span class="line">//闭包表达式</span><br><span class="line">var fn = &#123;</span><br><span class="line">    (v1: Int, v2: Int) -&gt; Int in</span><br><span class="line">    return v1 + v2</span><br><span class="line">&#125;</span><br><span class="line">fn(10, 20)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    (v1: Int, v2: Int) -&gt; Int in</span><br><span class="line">    return v1 + v2</span><br><span class="line">&#125;(10, 20) //直接调用</span><br><span class="line"></span><br><span class="line">// 格式</span><br><span class="line">&#123; (参数列表) -&gt; 返回值类型 in</span><br><span class="line">    函数体代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="闭包表达式的简写"><a href="#闭包表达式的简写" class="headerlink" title="闭包表达式的简写"></a>闭包表达式的简写</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func exec(v1: Int, v2: Int, fn: (Int, Int) -&gt; Int) &#123;</span><br><span class="line">    print(fn(v1, v2))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exec(v1: 10, v2: 20, fn: &#123;</span><br><span class="line">    (v1: Int, v2: Int) -&gt; Int in</span><br><span class="line">    return v1 + v2</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">exec(v1: 10, v2: 20, fn: &#123; v1, v2 in return v1 + v2 &#125;)</span><br><span class="line"></span><br><span class="line">exec(v1: 10, v2: 20, fn: &#123; v1, v2 in v1 + v2 &#125;)</span><br><span class="line"></span><br><span class="line">exec(v1: 10, v2: 20, fn: &#123; $0 + $1 &#125;)</span><br><span class="line"></span><br><span class="line">exec(v1: 10, v2: 20, fn: +)</span><br><span class="line"></span><br><span class="line">// 尾随闭包</span><br><span class="line">exec(v1: 10, v2: 20) &#123; $0 + $1 &#125;</span><br></pre></td></tr></table></figure><h3 id="尾随闭包"><a href="#尾随闭包" class="headerlink" title="尾随闭包"></a>尾随闭包</h3><ul><li><p>如果将一个很长的闭包表达式作为函数的最后一个实参，使用尾随闭包可以增强函数的可读性</p></li><li><p>尾随闭包是一个被书写在函数调用括号外面（后面）的闭包表达式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func exec(v1: Int, v2: Int, fn: (Int, Int) -&gt; Int) &#123;</span><br><span class="line">    print(fn(v1, v2))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exec(v1: 10, v2: 20) &#123; $0 + $1 &#125; </span><br></pre></td></tr></table></figure></li><li><p>如果闭包表达式是函数的唯一实参，而且使用了尾随闭包的语法，那就不需要在函数名后边写圆括号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func exec(fn: (Int, Int) -&gt; Int) &#123;</span><br><span class="line">    print(fn(1, 2))</span><br><span class="line">&#125;</span><br><span class="line">exec(fn: &#123; $0 + $1 &#125;)</span><br><span class="line">exec() &#123; $0 + $1 &#125;</span><br><span class="line">exec &#123; $0 + $1 &#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>示例 – 数组的排序</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">func sort(by areInIncreasingOrder: (Element, Element) -&gt; Bool)</span><br><span class="line"></span><br><span class="line">/// 返回true: i1排在i2前面</span><br><span class="line">/// 返回false: i1排在i2后面</span><br><span class="line">func cmp(i1: Int, i2: Int) -&gt; Bool &#123;</span><br><span class="line">    // 大的排在前面</span><br><span class="line">    return i1 &gt; i2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var nums = [11, 2, 18, 6, 5, 68, 45]</span><br><span class="line">nums.sort(by: cmp)</span><br><span class="line">// [68, 45, 18, 11, 6, 5, 2]</span><br><span class="line"></span><br><span class="line">nums.sort(by: &#123;</span><br><span class="line">    (i1: Int, i2: Int) -&gt; Bool in</span><br><span class="line">    return i1 &lt; i2</span><br><span class="line">&#125;)</span><br><span class="line">nums.sort(by: &#123; i1, i2 in return i1 &lt; i2 &#125;)</span><br><span class="line">nums.sort(by: &#123; i1, i2 in i1 &lt; i2 &#125;)</span><br><span class="line">nums.sort(by: &#123; $0 &lt; $1 &#125;)</span><br><span class="line">nums.sort(by: &lt;)</span><br><span class="line">nums.sort() &#123; $0 &lt; $1 &#125;</span><br><span class="line">nums.sort &#123; $0 &lt; $1 &#125;</span><br><span class="line">// [2, 5, 6, 11, 18, 45, 68]</span><br></pre></td></tr></table></figure><blockquote><p>忽略参数</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func exec(fn: (Int, Int) -&gt; Int) &#123;</span><br><span class="line">    print(fn(1, 2))</span><br><span class="line">&#125;</span><br><span class="line">exec &#123; _,_ in 10 &#125; // 10，无论参数传什么都是返回10</span><br></pre></td></tr></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ul><li>网上有各种关于闭包的定义，个人觉得比较严谨的定义是<ul><li>一个函数和它所 <code>捕获的变量\常量环境组合起来 </code>，称为闭包</li><li>一般指定义在 <code>函数内部的函数 </code></li><li>一般它捕获的是外层函数的局部变量\常量</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">typealias Fn = (Int) -&gt; Int</span><br><span class="line"></span><br><span class="line">func getFn() -&gt; Fn &#123;</span><br><span class="line">    var num = 0</span><br><span class="line">    func plus(_ i: Int) -&gt; Int &#123;</span><br><span class="line">        num += i</span><br><span class="line">        return num</span><br><span class="line">    &#125;</span><br><span class="line">    return plus</span><br><span class="line">&#125; // 返回的plus和num形成了闭包</span><br><span class="line"></span><br><span class="line">// 和上面的写法等价</span><br><span class="line">func getFn() -&gt; Fn &#123;</span><br><span class="line">    var num = 0</span><br><span class="line">    return &#123;</span><br><span class="line">        num += $0</span><br><span class="line">        return num</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var fn1 = getFn()</span><br><span class="line">var fn2 = getFn()</span><br><span class="line">fn1(1) // 1</span><br><span class="line">fn2(2) // 2</span><br><span class="line">fn1(3) // 4</span><br><span class="line">fn2(4) // 6</span><br><span class="line">fn1(5) // 9</span><br><span class="line">fn2(6) // 12</span><br></pre></td></tr></table></figure><ul><li>可以把闭包想象成是一个 <code>类的实例对象 </code><ul><li>内存在 <code>堆空间 </code></li><li>捕获的局部变量\常量就是对象的成员（存储属性）</li><li>组成闭包的函数就是类内部定义的方法</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Closure &#123;</span><br><span class="line">    var num = 0</span><br><span class="line">    func plus(_ i: Int) -&gt; Int &#123;</span><br><span class="line">        num += i</span><br><span class="line">        return num</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var cs1 = Closure()</span><br><span class="line">var cs2 = Closure()</span><br><span class="line">cs1.plus(1) // 1</span><br><span class="line">cs2.plus(2) // 2</span><br><span class="line">cs1.plus(3) // 4</span><br><span class="line">cs2.plus(4) // 6</span><br><span class="line">cs1.plus(5) // 9</span><br><span class="line">cs2.plus(6) // 12</span><br></pre></td></tr></table></figure><blockquote><ul><li>思考：如果num是全局变量呢？<ul><li>如果是全局变量，即不会捕获全局变量，也就不会分配堆空间，全局变量本身就可以直接访问。</li></ul></li></ul></blockquote><blockquote><p>练习</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">typealias Fn = (Int) -&gt; (Int, Int)</span><br><span class="line">func getFns() -&gt; (Fn, Fn) &#123;</span><br><span class="line">    var num1 = 0</span><br><span class="line">    var num2 = 0</span><br><span class="line">    func plus(_ i: Int) -&gt; (Int, Int) &#123;</span><br><span class="line">        num1 += i</span><br><span class="line">        num2 += i &lt;&lt; 1 //相当于 i*2</span><br><span class="line">        return (num1, num2)</span><br><span class="line">    &#125;</span><br><span class="line">    func minus(_ i: Int) -&gt; (Int, Int) &#123;</span><br><span class="line">        num1 -= i</span><br><span class="line">        num2 -= i &lt;&lt; 1 //相当于 i*2</span><br><span class="line">        return (num1, num2)</span><br><span class="line">    &#125;</span><br><span class="line">    return (plus, minus)</span><br><span class="line">&#125;</span><br><span class="line">let (p, m) = getFns()</span><br><span class="line">p(5) // (5, 10)</span><br><span class="line">m(4) // (1, 2)</span><br><span class="line">p(3) // (4, 8)</span><br><span class="line">m(2) // (2, 4)</span><br><span class="line"></span><br><span class="line">//以下是把上面的函数想像成类的改写</span><br><span class="line">class Closure &#123;</span><br><span class="line">    var num1 = 0</span><br><span class="line">    var num2 = 0</span><br><span class="line">    func plus(_ i: Int) -&gt; (Int, Int) &#123;</span><br><span class="line">        num1 += i</span><br><span class="line">        num2 += i &lt;&lt; 1 //相当于 i*2</span><br><span class="line">        return (num1, num2)</span><br><span class="line">    &#125;</span><br><span class="line">    func minus(_ i: Int) -&gt; (Int, Int) &#123;</span><br><span class="line">        num1 -= i</span><br><span class="line">        num2 -= i &lt;&lt; 1 //相当于 i*2</span><br><span class="line">        return (num1, num2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var cs = Closure()</span><br><span class="line">cs.plus(5) // (5, 10)</span><br><span class="line">cs.minus(4) // (1, 2)</span><br><span class="line">cs.plus(3) // (4, 8)</span><br><span class="line">cs.minus(2) // (2, 4)</span><br><span class="line"></span><br><span class="line">var functions: [() -&gt; Int] = []</span><br><span class="line">for i in 1...3 &#123;</span><br><span class="line">    functions.append &#123; i &#125; // 此&#123; i &#125;，是一个闭包表达式放入数组中</span><br><span class="line">&#125;</span><br><span class="line">for f in functions &#123;</span><br><span class="line">    print(f())</span><br><span class="line">&#125;</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// 3</span><br></pre></td></tr></table></figure><blockquote><p>注意<br>如果返回值是函数类型，那么参数的修饰要保持统一</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func add(_ num: Int) -&gt; (inout Int) -&gt; Void &#123;</span><br><span class="line">    func plus(v: inout Int) &#123;</span><br><span class="line">        v += num</span><br><span class="line">    &#125;</span><br><span class="line">    return plus</span><br><span class="line">&#125;</span><br><span class="line">var num = 5</span><br><span class="line">add(20)(&amp;num)</span><br><span class="line">print(num)</span><br></pre></td></tr></table></figure><h2 id="自动闭包"><a href="#自动闭包" class="headerlink" title="自动闭包"></a>自动闭包</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 如果第1个数大于0，返回第一个数。否则返回第2个数</span><br><span class="line">func getFirstPositive(_ v1: Int, _ v2: Int) -&gt; Int &#123;</span><br><span class="line">    return v1 &gt; 0 ? v1 : v2</span><br><span class="line">&#125;</span><br><span class="line">getFirstPositive(10, 20) // 10</span><br><span class="line">getFirstPositive(-2, 20) // 20</span><br><span class="line">getFirstPositive(0, -4) // -4</span><br><span class="line"></span><br><span class="line">// 改成函数类型的参数，可以让v2延迟加载</span><br><span class="line">func getFirstPositive(_ v1: Int, _ v2: () -&gt; Int) -&gt; Int? &#123;</span><br><span class="line">    return v1 &gt; 0 ? v1 : v2()</span><br><span class="line">&#125;</span><br><span class="line">getFirstPositive(-4) &#123; 20 &#125;</span><br><span class="line"></span><br><span class="line">func getFirstPositive(_ v1: Int, _ v2: @autoclosure () -&gt; Int) -&gt; Int? &#123;</span><br><span class="line">    return v1 &gt; 0 ? v1 : v2()</span><br><span class="line">&#125;</span><br><span class="line">getFirstPositive(-4, 20)</span><br></pre></td></tr></table></figure><ul><li><code>@autoclosure 会自动将 20 封装成闭包 &#123; 20 &#125; </code></li><li>@autoclosure 只支持 <code>() -&gt; T</code> 格式的参数</li><li>@autoclosure 并非只支持最后1个参数</li><li>空合并运算符 ?? 使用了 @autoclosure 技术</li><li>有@autoclosure、无@autoclosure，构成了函数重载</li><li>为了避免与期望冲突，使用了@autoclosure的地方最好明确注释清楚：这个值会被推迟执行</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;闭包表达式&quot;&gt;&lt;a href=&quot;#闭包表达式&quot; class=&quot;headerlink&quot; title=&quot;闭包表达式&quot;&gt;&lt;/a&gt;闭包表达式&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在Swift中，可以通过func定义一个函数，也可以通过 &lt;code&gt;闭包表达式 &lt;/co</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Swift" scheme="http://www.hxtec.top/tags/Swift/"/>
    
    <category term="语法" scheme="http://www.hxtec.top/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
</feed>
