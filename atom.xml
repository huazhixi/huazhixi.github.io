<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ivan&#39;s Blog</title>
  
  <subtitle>华曦之家</subtitle>
  <link href="http://www.hxtec.top/atom.xml" rel="self"/>
  
  <link href="http://www.hxtec.top/"/>
  <updated>2022-09-18T11:04:45.699Z</updated>
  <id>http://www.hxtec.top/</id>
  
  <author>
    <name>ivan_华之曦</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Swift-方法，下标</title>
    <link href="http://www.hxtec.top/2022/09/18/Swift-%E6%96%B9%E6%B3%95%EF%BC%8C%E4%B8%8B%E6%A0%87/"/>
    <id>http://www.hxtec.top/2022/09/18/Swift-%E6%96%B9%E6%B3%95%EF%BC%8C%E4%B8%8B%E6%A0%87/</id>
    <published>2022-09-18T11:02:44.000Z</published>
    <updated>2022-09-18T11:04:45.699Z</updated>
    
    <content type="html"><![CDATA[<h2 id="方法（Method）"><a href="#方法（Method）" class="headerlink" title="方法（Method）"></a>方法（Method）</h2><ul><li><p>枚举、结构体、类都可以定义实例方法、类型方法</p><ol><li>实例方法（Instance Method）：通过实例对象调用</li><li>类型方法（Type Method）:通过类型调用，用&#x3D;&#x3D;static&#x3D;&#x3D;或者&#x3D;&#x3D;class&#x3D;&#x3D;关键字定义<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Car &#123;</span><br><span class="line">    static var cout = 0</span><br><span class="line">    init() &#123;</span><br><span class="line">        Car.cout += 1 </span><br><span class="line">    &#125;</span><br><span class="line">    static func getCout() -&gt; Int &#123; cout &#125; </span><br><span class="line">&#125;</span><br><span class="line">let c0 = Car()</span><br><span class="line">let c1 = Car()</span><br><span class="line">let c2 = Car()</span><br><span class="line">print(Car.getCout()) // 3</span><br></pre></td></tr></table></figure></li></ol></li><li><p>self</p><ul><li>在实例方法中代表实例对象</li><li>在类型方法中代表类型</li></ul></li><li><p>在类型方法static func getCount中，cout.cout, Car.self.cout, Car.cout</p></li></ul><h3 id="mutating"><a href="#mutating" class="headerlink" title="mutating"></a>mutating</h3><ul><li>结构体和枚举是值类型，默认情况下，值类型的属性不能被自身的实例方法修改</li><li>在func关键字前加&#x3D;&#x3D;mutating&#x3D;&#x3D;可以允许这种修改行为<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct Point &#123;</span><br><span class="line">    var x = 0.0, y = 0.0</span><br><span class="line">    mutating func moveBy(deltaX: Double, deltaY: Double) &#123;</span><br><span class="line">        x += deltaX</span><br><span class="line">        y += deltaY</span><br><span class="line">        // self = Point(x: x + deltaX, y: y + deltaY)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum StateSwitch &#123;</span><br><span class="line">    case low, middle, high</span><br><span class="line">    mutating func next() &#123;</span><br><span class="line">        switch self &#123;</span><br><span class="line">          case .low:</span><br><span class="line">            self = .middle</span><br><span class="line">          case .middle:</span><br><span class="line">            self = .high</span><br><span class="line">          case .high:</span><br><span class="line">            self = .low</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="discardableResult"><a href="#discardableResult" class="headerlink" title="@discardableResult"></a>@discardableResult</h3><blockquote><p>在func前面加个@discardableResult，可以消除，函数调用后返回值未被使用的警告</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct Point &#123;</span><br><span class="line">    var x = 0.0, y = 0.0</span><br><span class="line">    @discardableResult mutating</span><br><span class="line">    func moveX(deltaX: Double) -&gt; Double &#123;</span><br><span class="line">        x += deltaX</span><br><span class="line">        return x </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">var p = Point()</span><br><span class="line">p.moveX(deltaX: 10)</span><br><span class="line"></span><br><span class="line">@discardableResult</span><br><span class="line">func get() -&gt; Int &#123;</span><br><span class="line">    return 10</span><br><span class="line">&#125;</span><br><span class="line">get()</span><br></pre></td></tr></table></figure><h2 id="下标（subscript）"><a href="#下标（subscript）" class="headerlink" title="下标（subscript）"></a>下标（subscript）</h2><ul><li><p>使用subscript可以给任意类型（枚举、结构体、类）增加下标功能，有些地方也翻译为：下标脚本</p></li><li><p>subscript的语法类似于实例方法、计算属性，本质就是方法（函数）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">    var x = 0.0, y = 0.0</span><br><span class="line">    subscript(index: Int) -&gt; Double &#123;</span><br><span class="line">        set &#123;</span><br><span class="line">            if index == 0 &#123; </span><br><span class="line">                x = newValue</span><br><span class="line">            &#125; else if index == 1 &#123;</span><br><span class="line">                y = newValue</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        get &#123;</span><br><span class="line">            if index == 0 &#123;</span><br><span class="line">                return x</span><br><span class="line">            &#125; else if index == 1 &#123;</span><br><span class="line">                return y </span><br><span class="line">            &#125;</span><br><span class="line">            return 0 </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = Point()</span><br><span class="line">p[0] = 11.1</span><br><span class="line">p[1] = 22.2</span><br><span class="line">print(p.x) // 11.1</span><br><span class="line">print(p.y) // 22.2</span><br><span class="line">print(p[0]) // 11.1</span><br><span class="line">print(p[1]) // 22.2</span><br></pre></td></tr></table></figure></li><li><p>subscript中定义的返回值类型决定了</p><ul><li>get方法的返回值类型</li><li>set方法中newValue的类型</li></ul></li><li><p>subscript可以接受多个参数，并且类型任意</p></li></ul><h3 id="下标细节"><a href="#下标细节" class="headerlink" title="下标细节"></a>下标细节</h3><blockquote><p>subscript可以没有set方法，但必须有get方法</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">    var x = 0.0, y = 0.0</span><br><span class="line">    subscript(index: Int) -&gt; Double &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            if index == 0 &#123;</span><br><span class="line">                return x</span><br><span class="line">             &#125; else if index == 1 &#123;</span><br><span class="line">                return y</span><br><span class="line">            &#125;</span><br><span class="line">            return 0</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果只有get方法，可以省略get关键字<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">    var x = 0.0, y = 0.0</span><br><span class="line">    subscript(index: Int) -&gt; Double &#123;</span><br><span class="line">        if index == 0 &#123;</span><br><span class="line">            return x</span><br><span class="line">        &#125; else if index == 1 &#123;</span><br><span class="line">            return y</span><br><span class="line">        &#125;</span><br><span class="line">        return 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>可以设置参数标签</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">    var x = 0.0, y = 0.0</span><br><span class="line">    subscript(index i: Int) -&gt; Double &#123;</span><br><span class="line">        if i == 0 &#123;</span><br><span class="line">            return x</span><br><span class="line">        &#125; else if i == 1 &#123;</span><br><span class="line">            return y </span><br><span class="line">        &#125;</span><br><span class="line">        return 0 </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = Point()</span><br><span class="line">p.y = 22.2</span><br><span class="line">print(p[index: 1]) // 22.2</span><br></pre></td></tr></table></figure><blockquote><p>下标可以是类型方法</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Sum &#123;</span><br><span class="line">    static subscript(v1: Int, v2: Int) -&gt; Int &#123;</span><br><span class="line">    return v1 + v2</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">print(Sum[10, 20]) // 30</span><br></pre></td></tr></table></figure><h3 id="结构体、类作为返回值对比"><a href="#结构体、类作为返回值对比" class="headerlink" title="结构体、类作为返回值对比"></a>结构体、类作为返回值对比</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 类作为返回值 </span><br><span class="line">class Point &#123;</span><br><span class="line">    var x = 0, y = 0 </span><br><span class="line">&#125;</span><br><span class="line">class PointManager &#123;</span><br><span class="line">    var point = Point()</span><br><span class="line">    subscript(index: Int) -&gt; Point &#123;</span><br><span class="line">        get &#123; point &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">var pm = PointManager()</span><br><span class="line">pm[0].x = 11</span><br><span class="line">pm[0].y = 22</span><br><span class="line">// Point(x: 11, y: 22)</span><br><span class="line">print(pm[0])</span><br><span class="line">// Point(x: 11, y: 22)</span><br><span class="line">print(pm.point)</span><br><span class="line"></span><br><span class="line">// 结构体作为返回值 </span><br><span class="line">struct Point &#123;</span><br><span class="line">    var x = 0, y = 0 </span><br><span class="line">&#125;</span><br><span class="line">class PointManager &#123;</span><br><span class="line">    var point = Point()</span><br><span class="line">    subscript(index: Int) -&gt; Point &#123;</span><br><span class="line">        set &#123; point = newValue &#125;</span><br><span class="line">        get &#123; point &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接收多个参数的下标"><a href="#接收多个参数的下标" class="headerlink" title="接收多个参数的下标"></a>接收多个参数的下标</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Grid &#123;</span><br><span class="line">    var data = [</span><br><span class="line">                [0, 1, 2],</span><br><span class="line">                [3, 4, 5],</span><br><span class="line">                [6, 7, 8] ]</span><br><span class="line">    subscript(row: Int, column: Int) -&gt; Int &#123;</span><br><span class="line">        set &#123;</span><br><span class="line">            guard row &gt;= 0 &amp;&amp; row &lt; 3 &amp;&amp; column &gt;= 0 &amp;&amp; column &lt; 3 else &#123;</span><br><span class="line">                return</span><br><span class="line">            &#125;</span><br><span class="line">            data[row][column] = newValue</span><br><span class="line">        &#125;</span><br><span class="line">        get &#123;</span><br><span class="line">            guard row &gt;= 0 &amp;&amp; row &lt; 3 &amp;&amp; column &gt;= 0 &amp;&amp; column &lt; 3 else &#123;</span><br><span class="line">                return 0 </span><br><span class="line">            &#125;</span><br><span class="line">            return data[row][column]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var grid = Grid()</span><br><span class="line">grid[0, 1] = 77</span><br><span class="line">grid[1, 2] = 88</span><br><span class="line">grid[2, 0] = 99</span><br><span class="line">print(grid.data)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;方法（Method）&quot;&gt;&lt;a href=&quot;#方法（Method）&quot; class=&quot;headerlink&quot; title=&quot;方法（Method）&quot;&gt;&lt;/a&gt;方法（Method）&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;枚举、结构体、类都可以定义实例方法、类型方法&lt;/p&gt;
&lt;o</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Swift" scheme="http://www.hxtec.top/tags/Swift/"/>
    
    <category term="语法" scheme="http://www.hxtec.top/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Swift-属性</title>
    <link href="http://www.hxtec.top/2022/09/18/Swift-%E5%B1%9E%E6%80%A7/"/>
    <id>http://www.hxtec.top/2022/09/18/Swift-%E5%B1%9E%E6%80%A7/</id>
    <published>2022-09-18T10:57:31.000Z</published>
    <updated>2022-09-18T11:01:51.991Z</updated>
    
    <content type="html"><![CDATA[<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="Swift中跟实例相关的属性可以分为两大类："><a href="#Swift中跟实例相关的属性可以分为两大类：" class="headerlink" title="Swift中跟实例相关的属性可以分为两大类："></a>Swift中跟实例相关的属性可以分为两大类：</h3><ul><li><p><code>存储属性 </code>(Stored Property)</p><ul><li>类似于成员变量这个概念</li><li>存储在实例的内存中</li><li>结构体、类可以定义存储属性</li><li>枚举 <code>不可以 </code>定义存储属性</li></ul></li><li><p><code>计算属性 </code>(Computed Property)</p><ul><li>本质就是方法(函数)</li><li>不占用实例的内存</li><li>枚举、结构体、类都可以定义计算属性</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">struct Circle &#123;</span><br><span class="line">    // 存储属性</span><br><span class="line">    var radius: Double</span><br><span class="line">    </span><br><span class="line">    // 计算属性</span><br><span class="line">    var diameter: Double &#123;</span><br><span class="line">        set &#123;</span><br><span class="line">            radius = newValue / 2</span><br><span class="line">        &#125;</span><br><span class="line">        get &#123;</span><br><span class="line">            radius * 2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(MemoryLayout&lt;Circle&gt;.stride) // 8</span><br><span class="line"></span><br><span class="line">var circle = Circle(radius: 5)</span><br><span class="line">print(circle.radius) // 5.0</span><br><span class="line">print(circle.diameter) // 10.0</span><br><span class="line"></span><br><span class="line">circle.diameter = 12</span><br><span class="line">print(circle.radius) // 6.0</span><br><span class="line">print(circle.diameter) // 12.0</span><br></pre></td></tr></table></figure><h4 id="存储属性"><a href="#存储属性" class="headerlink" title="存储属性"></a>存储属性</h4><p>关于存储属性，Swift有个明确的规定</p><ul><li>在创建类&#x2F;结构体的实例时，必须为所有的存储属性设置一个合适的初始值<ul><li>可以分配一个默认的属性值作为属性定义的一部分</li><li>可以在初始化器里为存储属性设置一个初始值</li></ul></li></ul><h4 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h4><ul><li><p><code>set </code>传入的新值默认叫做newValue，也可以自定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct Circle &#123;</span><br><span class="line">    // 存储属性</span><br><span class="line">    var radius: Double</span><br><span class="line">    // 计算属性</span><br><span class="line">    var diameter: Double &#123;</span><br><span class="line">        set(newDiameter) &#123;//默认是newValue，这里自定义为newDiameter</span><br><span class="line">            radius = newDiameter / 2</span><br><span class="line">        &#125;</span><br><span class="line">        get &#123;</span><br><span class="line">            radius * 2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>只读计算属性：只有 <code>get </code>，没有 <code>set </code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct Circle &#123;</span><br><span class="line">    // 存储属性</span><br><span class="line">    var radius: Double</span><br><span class="line">    // 计算属性</span><br><span class="line">    var diameter: Double &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            radius * 2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//下面是简化方式</span><br><span class="line">struct Circle &#123;</span><br><span class="line">    // 存储属性</span><br><span class="line">    var radius: Double</span><br><span class="line">    // 计算属性</span><br><span class="line">    var diameter: Double &#123; radius * 2 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义计算属性只能用 <code>var </code>，不能用 <code>let </code></p><ul><li><code>let </code>代表常量：值是一成不变的</li><li>计算属性的值是可能发生变化的(即使是只读计算属性)</li></ul></li></ul><h3 id="枚举rawValue原理"><a href="#枚举rawValue原理" class="headerlink" title="枚举rawValue原理"></a>枚举rawValue原理</h3><ul><li>枚举原始值rawValue的本质是：只读计算属性<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">enum TestEnum : Int &#123;</span><br><span class="line">    case test1 = 1, test2 = 2, test3 = 3</span><br><span class="line">    </span><br><span class="line">    //模拟Swift内部实现的rawValue计算属性</span><br><span class="line">    var rawValue: Int &#123;</span><br><span class="line">        switch self &#123;</span><br><span class="line">        case .test1:</span><br><span class="line">            return 10</span><br><span class="line">        case .test2:</span><br><span class="line">            return 11</span><br><span class="line">        case .test3:</span><br><span class="line">            return 12</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">print(TestEnum.test3.rawValue) // 12</span><br></pre></td></tr></table></figure></li></ul><h4 id="延迟存储属性-Lazy-Stored-Property"><a href="#延迟存储属性-Lazy-Stored-Property" class="headerlink" title="延迟存储属性(Lazy Stored Property)"></a>延迟存储属性(Lazy Stored Property)</h4><ul><li>使用lazy可以定义一个延迟存储属性，在第一次用到属性的时候才会进行初始化<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Car &#123;</span><br><span class="line">    init() &#123;</span><br><span class="line">        print(&quot;Car init!&quot;) &#125;</span><br><span class="line">    func run() &#123;</span><br><span class="line">        print(&quot;Car is running!&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Person &#123;</span><br><span class="line">    lazy var car = Car()</span><br><span class="line">    init() &#123;</span><br><span class="line">        print(&quot;Person init!&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    func goOut() &#123;</span><br><span class="line">        car.run()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let p = Person()</span><br><span class="line">print(&quot;--------&quot;)</span><br><span class="line">p.goOut()</span><br><span class="line"></span><br><span class="line">Person init!</span><br><span class="line">--------</span><br><span class="line">Car init!</span><br><span class="line">Car is running!</span><br><span class="line"></span><br><span class="line">class PhotoView &#123;</span><br><span class="line">    lazy var image: Image = &#123;</span><br><span class="line">        let url = &quot;https://www.520it.com/xx.png&quot;</span><br><span class="line">        let data = Data(url: url)</span><br><span class="line">        return Image(data: data)</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>lazy属性必须是var，不能是let，由于 <code>let </code>必须在实例的初始化方法完成之前就拥有值</li><li>如果多条线程同时第一次访问lazy属性，无法保证属性只被初始化一次</li></ul><h4 id="延迟存储属性注意点"><a href="#延迟存储属性注意点" class="headerlink" title="延迟存储属性注意点"></a>延迟存储属性注意点</h4><ul><li>当结构体包含一个延迟存储属性时，只有var才能访问延迟存储属性</li><li>因为延迟属性初始化时，需要改变结构体的内存<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct Point &#123;</span><br><span class="line">    var x = 0</span><br><span class="line">    var y = 0</span><br><span class="line">    lazy var z = 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p = Point()</span><br><span class="line">//下方报错内容：Cannot use mutating getter on immutable value: &#x27;p&#x27; is a &#x27;let&#x27; constant</span><br><span class="line">//print(p.z)</span><br></pre></td></tr></table></figure></li></ul><h3 id="属性观察器-Property-Observer"><a href="#属性观察器-Property-Observer" class="headerlink" title="属性观察器(Property Observer)"></a>属性观察器(Property Observer)</h3><ul><li>可以为非lazy的var存储属性设置属性观察器 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> struct Circle &#123;</span><br><span class="line">    var radius: Double &#123;</span><br><span class="line">        willSet &#123;</span><br><span class="line">            print(&quot;willSet&quot;, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            print(&quot;didSet&quot;, oldValue, radius) &#125; &#125;</span><br><span class="line">    init() &#123;</span><br><span class="line">        self.radius = 1.0</span><br><span class="line">        print(&quot;Circle init!&quot;)   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// Circle init!</span><br><span class="line">var circle = Circle()</span><br><span class="line"></span><br><span class="line">// willSet 10.5</span><br><span class="line">// didSet 1.0 10.5</span><br><span class="line">circle.radius = 10.5</span><br><span class="line"></span><br><span class="line">// 10.5</span><br><span class="line">print(circle.radius)</span><br></pre></td></tr></table></figure></li><li><code>willSet </code>会传递新值，默认叫newValue</li><li><code>didSet </code>会传递旧值，默认叫oldValue</li><li>在初始化器中设置属性值不会触发willSet和didSet</li><li>在属性定义时设置初始值也不会触发willSet和didSet</li></ul><h3 id="全局变量、局部变量"><a href="#全局变量、局部变量" class="headerlink" title="全局变量、局部变量"></a>全局变量、局部变量</h3><ul><li>属性观察器、计算属性的功能，同样可以应用在全局变量、局部变量上<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var num: Int &#123;</span><br><span class="line">    get &#123;</span><br><span class="line">        return 10</span><br><span class="line">    &#125;</span><br><span class="line">    set &#123;</span><br><span class="line">        print(&quot;setNum&quot;, newValue)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">num = 11 // setNum 11</span><br><span class="line">print(num) // 10</span><br><span class="line"></span><br><span class="line">func test() &#123;</span><br><span class="line">    var age = 10 &#123;</span><br><span class="line">        willSet &#123;</span><br><span class="line">            print(&quot;willSet&quot;, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            print(&quot;didSet&quot;, oldValue, age)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    age = 11</span><br><span class="line">    // willSet 11</span><br><span class="line">    // didSet 10 11</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br></pre></td></tr></table></figure></li></ul><h3 id="inout的再次研究"><a href="#inout的再次研究" class="headerlink" title="inout的再次研究"></a>inout的再次研究</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">struct Shape &#123;</span><br><span class="line">    var width: Int</span><br><span class="line">    var side: Int &#123;</span><br><span class="line">        willSet &#123;</span><br><span class="line">            print(&quot;willSetSide&quot;, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            print(&quot;didSetSide&quot;, oldValue, side) &#125; &#125;</span><br><span class="line">    var girth: Int &#123;</span><br><span class="line">        set &#123;</span><br><span class="line">            width = newValue / side</span><br><span class="line">            print(&quot;setGirth&quot;, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        get &#123;</span><br><span class="line">            print(&quot;getGirth&quot;)</span><br><span class="line">            return width * side</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    func show() &#123;</span><br><span class="line">        print(&quot;width=\(width), side=\(side), girth=\(girth)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">func test(_ num: inout Int) &#123;</span><br><span class="line">    num = 20</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var s = Shape(width: 10, side: 4)</span><br><span class="line">test(&amp;s.width)</span><br><span class="line">s.show()</span><br><span class="line">print(&quot;----------&quot;)</span><br><span class="line">test(&amp;s.side)</span><br><span class="line">s.show()</span><br><span class="line">print(&quot;----------&quot;)</span><br><span class="line">test(&amp;s.girth)</span><br><span class="line">s.show()</span><br><span class="line"></span><br><span class="line">getGirth</span><br><span class="line">width=20, side=4, girth=80</span><br><span class="line">----------</span><br><span class="line">willSetSide 20</span><br><span class="line">didSetSide 4 20</span><br><span class="line">getGirth</span><br><span class="line">width=20, side=20, girth=400</span><br><span class="line">----------</span><br><span class="line">getGirth</span><br><span class="line">setGirth 20</span><br><span class="line">getGirth</span><br><span class="line">width=1, side=20, girth=20</span><br></pre></td></tr></table></figure><blockquote><p>inout的本质总结</p><ul><li>如果实参有物理内存地址，且没有设置属性观察器，直接将实参的内存地址传入函数(实参进行引用传递)</li><li>如果实参是计算属性或者设置属性观察器，采取 Copy In Copy Out的做法</li><li>调用该函数时，先复制实参的值，产生副本  <code>[get] </code> <ul><li>将副本的内存地址传入函数(对副本进行引用传递)，在函数内部可以修改副本的值</li><li>函数返回后，再将副本的值覆盖实参的值  <code>[set] </code></li></ul></li></ul></blockquote><ul><li>总结：inout的本质就是引用传递(地址传递)</li></ul><h3 id="类型属性"><a href="#类型属性" class="headerlink" title="类型属性"></a>类型属性</h3><blockquote><p>严格来说，属性可以分为：</p><ul><li>实例属性（Instance Property）：只能通过实例去访问<ul><li>存储实例属性（Stored Instance Property）：存储在实例的内存中，每个实例都有1份 </li><li>计算实例属性（Computed Instance Property）</li></ul></li><li>类型属性（Type Property）：只能通过类型去访问<ul><li>存储类型属性（Stored Type Property）：整个程序运行过程中，就只有1份内存（类似于全局变量）</li><li>计算类型属性（Computed Type Property）</li></ul></li></ul></blockquote><ul><li>可以通过 <code>static </code>定义类型属性</li><li>如果是类，也可以用关键字 <code>class </code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct Car &#123;</span><br><span class="line">    static var count: Int = 0</span><br><span class="line">    init() &#123;</span><br><span class="line">        Car.count += 1 </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">let c1 = Car()</span><br><span class="line">let c2 = Car()</span><br><span class="line">let c3 = Car()</span><br><span class="line">print(Car.count) // 3</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>类型属性细节</p><ul><li>不同于存储实例属性，你必须给存储类型属性设定初始值，因为类型没有像实例那样的init初始化器来初始化存储属性</li><li>存储类型属性默认就是lazy，会在第一次使用的时候才初始化就算被多个线程同时访问，保证只会初始化一次，存储类型属性可以是let</li><li>枚举类型也可以定义类型属性（存储类型属性、计算类型属性）</li></ul></blockquote><h2 id="应用-单例模式"><a href="#应用-单例模式" class="headerlink" title="应用 - 单例模式"></a>应用 - 单例模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class FileManager &#123;</span><br><span class="line">    public static let shared = FileManager()</span><br><span class="line">    private init() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class FileManager &#123;</span><br><span class="line">    public static let shared = &#123;</span><br><span class="line">        // ....</span><br><span class="line">        // ....</span><br><span class="line">        return FileManager()</span><br><span class="line">    &#125;()</span><br><span class="line">    private init() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;属性&quot;&gt;&lt;a href=&quot;#属性&quot; class=&quot;headerlink&quot; title=&quot;属性&quot;&gt;&lt;/a&gt;属性&lt;/h2&gt;&lt;h3 id=&quot;Swift中跟实例相关的属性可以分为两大类：&quot;&gt;&lt;a href=&quot;#Swift中跟实例相关的属性可以分为两大类：&quot; class=&quot;</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Swift" scheme="http://www.hxtec.top/tags/Swift/"/>
    
    <category term="语法" scheme="http://www.hxtec.top/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Swift-结构体和类</title>
    <link href="http://www.hxtec.top/2022/09/18/Swift-%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%B1%BB/"/>
    <id>http://www.hxtec.top/2022/09/18/Swift-%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%B1%BB/</id>
    <published>2022-09-18T10:54:34.000Z</published>
    <updated>2022-09-18T10:56:46.132Z</updated>
    
    <content type="html"><![CDATA[<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><ul><li>在 Swift 标准库中，绝大多数的公开类型都是结构体，而枚举和类只占很小一部分</li><li>比如Bool、Int、Double、 String、Array、Dictionary等常见类型都是结构体</li><li>所有的结构体都有一个编译器自动生成的初始化器（initializer，初始化方法、构造器、构造方法）</li><li>在第⑥行调用的，可以传入所有成员值，用以初始化所有成员（存储属性，Stored Property）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">① struct Date &#123; </span><br><span class="line">②   var year: Int</span><br><span class="line">③   var month: Int</span><br><span class="line">④   var day: Int</span><br><span class="line">⑤ &#125; </span><br><span class="line">⑥ var date = Date(year: 2019, month: 6, day: 23)</span><br></pre></td></tr></table></figure></li></ul><h3 id="结构体的初始化器"><a href="#结构体的初始化器" class="headerlink" title="结构体的初始化器"></a>结构体的初始化器</h3><ul><li>编译器会根据情况，可能会为结构体生成多个初始化器，宗旨是：保证所有成员都有初始值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">struct Point &#123;</span><br><span class="line">    var x: Int</span><br><span class="line">    var y: Int</span><br><span class="line">&#125;</span><br><span class="line">var p1 = Point(x: 10, y: 20)</span><br><span class="line">//var p2 = Point(x: 10)    x</span><br><span class="line">//var p3 = Point(y: 20)    x</span><br><span class="line">//var p4 = Point()        x</span><br><span class="line"></span><br><span class="line">struct Point1 &#123;</span><br><span class="line">    var x: Int = 0</span><br><span class="line">    var y: Int</span><br><span class="line">&#125;</span><br><span class="line">var p1 = Point1(x: 10, y: 20)</span><br><span class="line">var p3 = Point1(y: 20)</span><br><span class="line">//var p2 = Point1(x: 10)   x</span><br><span class="line">//var p4 = Point1()        x</span><br><span class="line"></span><br><span class="line">struct Point3 &#123;</span><br><span class="line">    var x: Int = 0</span><br><span class="line">    var y: Int = 0</span><br><span class="line">&#125;</span><br><span class="line">var p1 = Point(x: 10, y: 20)</span><br><span class="line">var p2 = Port(x: 10)</span><br><span class="line">var p3 = Port(y: 20)</span><br><span class="line">var p4 = Point()</span><br></pre></td></tr></table></figure><h3 id="自定义初始化器"><a href="#自定义初始化器" class="headerlink" title="自定义初始化器"></a>自定义初始化器</h3><ul><li>一旦在定义结构体时自定义了初始化器，编译器就不会再帮它自动生成其他初始化器<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct Point &#123;</span><br><span class="line">    var x: Int = 0</span><br><span class="line">    var y: Int = 0</span><br><span class="line">    init(x: Int, y: Int) &#123;</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var p1 = Point(x: 10, y: 20)</span><br><span class="line">//var p2 = Port(x: 10)        x</span><br><span class="line">//var p3 = Port(y: 20)        x</span><br><span class="line">//var p4 = Point()            x</span><br></pre></td></tr></table></figure></li></ul><h3 id="窥探初始化器的本质"><a href="#窥探初始化器的本质" class="headerlink" title="窥探初始化器的本质"></a>窥探初始化器的本质</h3><ul><li>以下2段代码完全等效<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct Point &#123;</span><br><span class="line">    var x: Int = 0</span><br><span class="line">    var y: Int = 0    </span><br><span class="line">&#125;</span><br><span class="line">var p = Point()</span><br><span class="line"></span><br><span class="line">struct Point &#123;</span><br><span class="line">    var x: Int</span><br><span class="line">    var y: Int</span><br><span class="line">    init() &#123;</span><br><span class="line">        x = 0 </span><br><span class="line">        y = 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var p = Point()</span><br></pre></td></tr></table></figure></li></ul><h3 id="结构体内存结构"><a href="#结构体内存结构" class="headerlink" title="结构体内存结构"></a>结构体内存结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct Point &#123;</span><br><span class="line">    var x: Int = 0</span><br><span class="line">    var y: Int = 0</span><br><span class="line">    var origin: Bool = false</span><br><span class="line">&#125;</span><br><span class="line">print(MemoryLayout&lt;Point&gt;.size) // 17</span><br><span class="line">print(MemoryLayout&lt;Point&gt;.stride) // 24</span><br><span class="line">print(MemoryLayout&lt;Point&gt;.alignment) // 8</span><br></pre></td></tr></table></figure><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ul><li>类的定义和结构体类似，但编译器并没有为类自动生成可以传入成员值的初始化器<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 类</span><br><span class="line">class Point &#123;</span><br><span class="line">    var x: Int = 0</span><br><span class="line">    var y: Int = 0</span><br><span class="line">&#125;</span><br><span class="line">let p1 = Point()</span><br><span class="line">//let p2 = Point(x: 10, y: 20)     x</span><br><span class="line">//let p3 = Point(x: 10)            x</span><br><span class="line">//let p4 = Point(y: 20)            x</span><br><span class="line"></span><br><span class="line">// 结构体</span><br><span class="line">struct Point &#123;</span><br><span class="line">    var x: Int = 0</span><br><span class="line">    var y: Int = 0</span><br><span class="line">&#125;</span><br><span class="line">let p1 = Point()</span><br><span class="line">let p2 = Point(x: 10, y: 20)</span><br><span class="line">let p3 = Point(x: 10)</span><br><span class="line">let p4 = Point(y: 20)</span><br><span class="line"></span><br><span class="line">// 类</span><br><span class="line">struct Point &#123;</span><br><span class="line">    var x: Int</span><br><span class="line">    var y: Int</span><br><span class="line">&#125;</span><br><span class="line">// let p1 = Point() x 不能初始化成功，成员没有初始值</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="类的初始化器"><a href="#类的初始化器" class="headerlink" title="类的初始化器"></a>类的初始化器</h3><ul><li>如果类的所有成员都在定义的时候指定了初始值，编译器会为类生成无参的初始化器</li><li>成员的初始化是在这个初始化器中完成的</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">    var x: Int = 10</span><br><span class="line">    var y: Int = 20</span><br><span class="line">&#125;</span><br><span class="line">let p1 = Point()</span><br><span class="line"></span><br><span class="line">class Point &#123;</span><br><span class="line">    var x: Int</span><br><span class="line">    var y: Int</span><br><span class="line">    init() &#123;</span><br><span class="line">        x = 10</span><br><span class="line">        y = 20</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">let p1 = Point()</span><br></pre></td></tr></table></figure><ul><li>上面2段代码是完全等效的</li></ul><h3 id="结构体与类的本质区别"><a href="#结构体与类的本质区别" class="headerlink" title="结构体与类的本质区别"></a>结构体与类的本质区别</h3><ul><li>结构体是&#x3D;&#x3D;值类型&#x3D;&#x3D;（枚举也是值类型），类是&#x3D;&#x3D;引用类型&#x3D;&#x3D;（指针类型）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Size &#123;</span><br><span class="line">    var width = 1</span><br><span class="line">    var height = 2</span><br><span class="line">&#125;</span><br><span class="line">struct Point &#123;</span><br><span class="line">    var x = 3</span><br><span class="line">    var y = 4</span><br><span class="line">&#125;</span><br><span class="line">func test() &#123;</span><br><span class="line">    var size = Size()</span><br><span class="line">    var point = Point()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="http://rfshxohrg.hn-bkt.clouddn.com/Snip20220827_30.png" alt="image"></li></ul><h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3><ul><li>值类型赋值给var、let或者给函数传参，是&#x3D;&#x3D;直接将所有内容拷贝一份&#x3D;&#x3D;</li><li>类似于对文件进行copy、paste操作，产生了全新的文件副本。属于&#x3D;&#x3D;深拷贝&#x3D;&#x3D;（deep copy）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct Point &#123;</span><br><span class="line">    var x: Int</span><br><span class="line">    var y: Int</span><br><span class="line">&#125;</span><br><span class="line">func test() &#123;</span><br><span class="line">    var p1 = Point(x: 10, y: 20)</span><br><span class="line">    var p2 = p1</span><br><span class="line">&#125;</span><br><span class="line">p2.x = 11</span><br><span class="line">p2.y = 22</span><br><span class="line">// 请问p1.x和p1.y是多少？</span><br><span class="line">// p1.x和p1.y的值仍然是10，20，p2为深拷贝，修改p2不影响p1</span><br></pre></td></tr></table></figure><img src="http://rfshxohrg.hn-bkt.clouddn.com/Snip20220827_31.png" alt="image"></li></ul><h3 id="值类型的赋值操作"><a href="#值类型的赋值操作" class="headerlink" title="值类型的赋值操作"></a>值类型的赋值操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//字符串String</span><br><span class="line">var s1 = &quot;Jack&quot;</span><br><span class="line">var s2 = s1</span><br><span class="line">s2.append(&quot;_Rose&quot;)</span><br><span class="line">print(s1) // Jack</span><br><span class="line">print(s2) // Jack_Rose</span><br><span class="line"></span><br><span class="line">//数组Array</span><br><span class="line">var a1 = [1, 2, 3]</span><br><span class="line">var a2 = a1</span><br><span class="line">a2.append(4)</span><br><span class="line">a1[0] = 2</span><br><span class="line">print(a1) // [2, 2, 3]</span><br><span class="line">print(a2) // [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">// 字典Dictionary</span><br><span class="line">var d1 = [&quot;max&quot; : 10, &quot;min&quot; : 2]</span><br><span class="line">var d2 = d1</span><br><span class="line">d1[&quot;other&quot;] = 7</span><br><span class="line">d2[&quot;max&quot;] = 12</span><br><span class="line">print(d1) // [&quot;other&quot;: 7, &quot;max&quot;: 10, &quot;min&quot;: 2]</span><br><span class="line">print(d2) // [&quot;max&quot;: 12, &quot;min&quot;: 2]</span><br></pre></td></tr></table></figure><ul><li>在Swift标准库中，为了提升性能，String、Array、Dictionary、Set采取了&#x3D;&#x3D;Copy On Write&#x3D;&#x3D;的技术</li><li>比如仅当有“写”操作时，才会真正执行拷贝操作</li><li>对于标准库值类型的赋值操作，Swift能确保最佳性能，所有没必要为了保证最佳性能来避免赋值</li><li>建议：不需要修改的，尽量定义成let</li></ul><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><ul><li>引用赋值给var、let或者给函数传参，是将&#x3D;&#x3D;内存地址拷贝一份&#x3D;&#x3D;</li><li>类似于制作一个文件的替身（快捷方式、链接），指向的是同一个文件。属于&#x3D;&#x3D;浅拷贝&#x3D;&#x3D;（shallow copy）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Size &#123;</span><br><span class="line">    var width: Int</span><br><span class="line">    var height: Int</span><br><span class="line">    init(width: Int, height: Int) &#123;</span><br><span class="line">        self.width = width</span><br><span class="line">        self.height = height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func test() &#123;</span><br><span class="line">    var s1 = Size(width: 10, height: 20)</span><br><span class="line">    var s2 = s1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s2.width = 11</span><br><span class="line">s2.height = 22</span><br><span class="line">// 请问s1.width和s1.height是多少？</span><br><span class="line">// s1.width=11 s1.height=22，两个对象(局部变量)地址不一样，但是变量所对应的堆空间的地址是一样，所以修改一个对象的值，另一个也是改变的。</span><br></pre></td></tr></table></figure><img src="http://rfshxohrg.hn-bkt.clouddn.com/Snip20220827_29.png" alt="image"></li></ul><h3 id="对象的堆空间申请过程"><a href="#对象的堆空间申请过程" class="headerlink" title="对象的堆空间申请过程"></a>对象的堆空间申请过程</h3><ul><li>在Swift中，创建类的实例对象，要向堆空间申请内存，大概流程如下：<ul><li>Class.__allocating_init()</li><li>libswiftCore.dylib：&#x3D;&#x3D;<em>swift_allocObject</em>&#x3D;&#x3D;</li><li>libswiftCore.dylib：&#x3D;&#x3D;swift_slowAlloc&#x3D;&#x3D;</li><li>libsystem_malloc.dylib：&#x3D;&#x3D;malloc&#x3D;&#x3D;</li></ul></li><li>在Mac、iOS中的malloc函数分配的内存大小总是16的倍数 </li><li>通过class_getInstanceSize可以得知：类的对象至少需要占用多少内存<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">    var x = 11          //8个字节</span><br><span class="line">    var test = true     //1个字节，考虑到内存对齐所以占用8个字节，实际使用1个字节</span><br><span class="line">    var y = 22          //8个字节</span><br><span class="line">&#125;</span><br><span class="line">var p = Point()</span><br><span class="line">class_getInstanceSize(type(of: p)) // 40</span><br><span class="line">class_getInstanceSize(Point.self) // 40</span><br><span class="line">malloc_size(p)  //48</span><br><span class="line">// 对象在内存中有一个指向类型信息和引用计数各占8个字节。</span><br><span class="line">// 通过malloc_size分配的为48，因malloc函数分配的内存大小总是16的倍数。</span><br></pre></td></tr></table></figure></li></ul><h3 id="引用类型的赋值操作"><a href="#引用类型的赋值操作" class="headerlink" title="引用类型的赋值操作"></a>引用类型的赋值操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Size &#123;</span><br><span class="line">    var width: Int</span><br><span class="line">    var height: Int</span><br><span class="line">    init(width: Int, height: Int) &#123;</span><br><span class="line">        self.width = width</span><br><span class="line">        self.height = height</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">var s1 = Size(width: 10, height: 20)</span><br><span class="line">s1 = Size(width: 11, height: 22)</span><br></pre></td></tr></table></figure><p><img src="http://rfshxohrg.hn-bkt.clouddn.com/Snip20220828_36.png" alt="image"></p><h3 id="值类型、引用类型的let"><a href="#值类型、引用类型的let" class="headerlink" title="值类型、引用类型的let"></a>值类型、引用类型的let</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">struct Point &#123;</span><br><span class="line">    var x: Int</span><br><span class="line">    var y: Int</span><br><span class="line">&#125;</span><br><span class="line">class Size &#123;</span><br><span class="line">    var width: Int</span><br><span class="line">    var height: Int</span><br><span class="line">    init(width: Int, height: Int) &#123;</span><br><span class="line">        self.width = width</span><br><span class="line">        self.height = height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p = Point(x: 10, y: 20)</span><br><span class="line">//p = Point(x: 11, y: 22)       x</span><br><span class="line">//p.x = 33                      x</span><br><span class="line">//p.y == 44                     x</span><br><span class="line"></span><br><span class="line">let s = Size(width: 10, height: 20)</span><br><span class="line">//s = Size(width: 11, height: 22)       x</span><br><span class="line">s.width = 33</span><br><span class="line">s.height = 44</span><br><span class="line"></span><br><span class="line">let str = &quot;Jack&quot;</span><br><span class="line">//str.appending(&quot;_Rose&quot;)    x</span><br><span class="line"></span><br><span class="line">let array = [1, 2, 3]</span><br><span class="line">//array[0] = 4              x</span><br><span class="line">//array.append(5)           x</span><br></pre></td></tr></table></figure><h3 id="嵌套类型"><a href="#嵌套类型" class="headerlink" title="嵌套类型"></a>嵌套类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct Poker &#123;</span><br><span class="line">    enum Suit : Character &#123;</span><br><span class="line">        case spades = &quot;♠&quot; , hearts = &quot;♥&quot; , diamonds = &quot;♦&quot; , clubs = &quot;♣&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    enum Rank : Int &#123;</span><br><span class="line">        case two = 2, three, four, five, six, seven, eight, nine, ten</span><br><span class="line">        case jack, queen, king, ace</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">print(Poker.Suit.hearts.rawValue)</span><br><span class="line">var suit = Poker.Suit.spades</span><br><span class="line">suit = .diamonds</span><br><span class="line">var rank = Poker.Rank.five</span><br><span class="line">rank = .king</span><br></pre></td></tr></table></figure><h3 id="枚举、结构体、类都可以定义方法"><a href="#枚举、结构体、类都可以定义方法" class="headerlink" title="枚举、结构体、类都可以定义方法"></a>枚举、结构体、类都可以定义方法</h3><ul><li>一般把定义在枚举、结构体、类内部的函数，叫做方法。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Size &#123;</span><br><span class="line">    var width = 10</span><br><span class="line">    var height = 10</span><br><span class="line">    func show() &#123;</span><br><span class="line">        print(&quot;width=\(width), height=\(height)&quot;) &#125; &#125;</span><br><span class="line">let s = Size()</span><br><span class="line">s.show() // width=10, height=10</span><br><span class="line"></span><br><span class="line">struct Point &#123;</span><br><span class="line">    var x = 10</span><br><span class="line">    var y = 10</span><br><span class="line">    func show() &#123;</span><br><span class="line">        print(&quot;x=\(x), y=\(y)&quot;) &#125; &#125;</span><br><span class="line">let p = Point()</span><br><span class="line">p.show() // x=10, y=10</span><br><span class="line"></span><br><span class="line">enum PokerFace : Character &#123;</span><br><span class="line">    case spades = &quot;♠&quot;, hearts = &quot;♥&quot;, diamonds = &quot;♦&quot;, clubs = &quot;♣&quot;</span><br><span class="line">    func show() &#123;</span><br><span class="line">        print(&quot;face is \(rawValue)&quot;) &#125; &#125;</span><br><span class="line">let pf = PokerFace.hearts</span><br><span class="line">pf.show() // face is ♥</span><br></pre></td></tr></table></figure></li><li>方法占用对象的内存么？<ul><li>不占用</li><li>方法的&#x3D;&#x3D;本质就是函数&#x3D;&#x3D;</li><li>方法、函数都存在内存的&#x3D;&#x3D;代码段&#x3D;&#x3D;</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;结构体&quot;&gt;&lt;a href=&quot;#结构体&quot; class=&quot;headerlink&quot; title=&quot;结构体&quot;&gt;&lt;/a&gt;结构体&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在 Swift 标准库中，绝大多数的公开类型都是结构体，而枚举和类只占很小一部分&lt;/li&gt;
&lt;li&gt;比如Bool、Int</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Swift" scheme="http://www.hxtec.top/tags/Swift/"/>
    
    <category term="语法" scheme="http://www.hxtec.top/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Swift-枚举</title>
    <link href="http://www.hxtec.top/2022/09/18/Swift-%E6%9E%9A%E4%B8%BE/"/>
    <id>http://www.hxtec.top/2022/09/18/Swift-%E6%9E%9A%E4%B8%BE/</id>
    <published>2022-09-18T10:52:10.000Z</published>
    <updated>2022-09-18T11:04:49.467Z</updated>
    
    <content type="html"><![CDATA[<h2 id="枚举的基本用法"><a href="#枚举的基本用法" class="headerlink" title="枚举的基本用法"></a>枚举的基本用法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">enum Direction &#123;</span><br><span class="line">    case north</span><br><span class="line">    case south</span><br><span class="line">    case east</span><br><span class="line">    case west</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum Direction2 &#123;</span><br><span class="line">    case north, south, east, west</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var dir = Direction.west</span><br><span class="line">dir = Direction.east</span><br><span class="line">dir = .north</span><br><span class="line">print(dir)// north</span><br><span class="line"></span><br><span class="line">switch dir &#123;</span><br><span class="line">case. north:</span><br><span class="line">    print(&quot;north&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关联值-Associated-Values"><a href="#关联值-Associated-Values" class="headerlink" title="关联值(Associated Values)"></a>关联值(Associated Values)</h2><blockquote><p>有时将枚举的成员值跟其他类型的值关联存储在一起，会非常有用<br>必要时let也可以改为var</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 日期</span><br><span class="line">enum Date &#123;</span><br><span class="line">    case digit(year: Int, month: Int, day: Int)</span><br><span class="line">    case string(String) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var date = Date.digit(year: 2011, month: 9, day: 10)</span><br><span class="line">date = .string(&quot;2011-09-10&quot;)</span><br><span class="line"></span><br><span class="line">switch date &#123;</span><br><span class="line">case .digit(let year, let month, let day):</span><br><span class="line">    print(year, month, day)</span><br><span class="line">case let .string(value):</span><br><span class="line">    print(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 密码手势</span><br><span class="line">enum Password &#123;</span><br><span class="line">    case number(Int, Int, Int, Int)</span><br><span class="line">    case gesture(String)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var pwd = Password.number(1, 2, 3, 4)</span><br><span class="line">pwd = .gesture(&quot;1234&quot;)</span><br><span class="line"></span><br><span class="line">switch pwd &#123;</span><br><span class="line">case let .number(n1, n2, n3, n4):</span><br><span class="line">    print(&quot;number is &quot;, n1, n2, n3, n4)</span><br><span class="line">case let .gesture(str):</span><br><span class="line">    print(&quot;guesture is &quot;, str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原始值-Raw-Values"><a href="#原始值-Raw-Values" class="headerlink" title="原始值(Raw Values)"></a>原始值(Raw Values)</h2><blockquote><p>枚举成员可以使用相同类型的默认值预先对应，这个默认值叫做：原始值</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">enum PokerSuit : Character &#123;</span><br><span class="line">    case spade = &quot;♠&quot;</span><br><span class="line">    case heart = &quot;♥&quot;</span><br><span class="line">    case diamond = &quot;♦&quot;</span><br><span class="line">    case club = &quot;♣&quot;</span><br><span class="line">&#125;</span><br><span class="line">var suit = PokerSuit.spade</span><br><span class="line">print(suit) // spade</span><br><span class="line">print(suit.rawValue) // ♠</span><br><span class="line">print(PokerSuit.club.rawValue) // ♣</span><br><span class="line"></span><br><span class="line">enum Grade : String &#123;</span><br><span class="line">    case perfect = &quot;A&quot;</span><br><span class="line">    case great = &quot;B&quot;</span><br><span class="line">    case good = &quot;C&quot;</span><br><span class="line">    case bad = &quot;D&quot;</span><br><span class="line">&#125;</span><br><span class="line">print(Grade.perfect.rawValue) // A</span><br><span class="line">print(Grade.great.rawValue) // B</span><br><span class="line">print(Grade.good.rawValue) // C</span><br><span class="line">print(Grade.bad.rawValue) // D</span><br></pre></td></tr></table></figure><blockquote><p>注意：原始值不占用枚举变量的内存</p></blockquote><h2 id="隐式原始值-Implicitly-Assigned-Raw-Values"><a href="#隐式原始值-Implicitly-Assigned-Raw-Values" class="headerlink" title="隐式原始值(Implicitly Assigned Raw Values)"></a>隐式原始值(Implicitly Assigned Raw Values)</h2><blockquote><p>如果枚举的原始值类型是Int, String, Swift会自动分配原始值</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">enum Direction : String &#123;</span><br><span class="line">    case north = &quot;north&quot;</span><br><span class="line">    case south = &quot;south&quot;</span><br><span class="line">    case east = &quot;east&quot;</span><br><span class="line">    case west = &quot;west&quot;</span><br><span class="line">&#125;</span><br><span class="line">// 等价于</span><br><span class="line">enum Direction : String &#123;</span><br><span class="line">    case north, south, east, west</span><br><span class="line">&#125;</span><br><span class="line">print(Direction.north) // north</span><br><span class="line">print(Direction.north.rawValue) // north</span><br><span class="line"></span><br><span class="line">enum Season : Int &#123;</span><br><span class="line">    case spring, summer, autumn, winter</span><br><span class="line">&#125;</span><br><span class="line">print(Season.spring.rawValue) // 0</span><br><span class="line">print(Season.summer.rawValue) // 1</span><br><span class="line">print(Season.autumn.rawValue) // 2</span><br><span class="line">print(Season.winter.rawValue) // 3</span><br><span class="line"></span><br><span class="line">enum Season : Int &#123;</span><br><span class="line">    case spring = 1, summer, autumn = 4, winter</span><br><span class="line">&#125;</span><br><span class="line">print(Season.spring.rawValue) // 1</span><br><span class="line">print(Season.summer.rawValue) // 2</span><br><span class="line">print(Season.autumn.rawValue) // 4</span><br><span class="line">print(Season.winter.rawValue) // 5</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="MemoryLayout"><a href="#MemoryLayout" class="headerlink" title="MemoryLayout"></a>MemoryLayout</h2><blockquote><p>可以使用MemoryLayout获取数据类型占用的内存大小</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">enum Password &#123;</span><br><span class="line">    case number(Int, Int, Int, Int)</span><br><span class="line">    case other</span><br><span class="line">&#125;</span><br><span class="line">MemoryLayout&lt;Password&gt;.stride // 40, 分配占用的空间大小</span><br><span class="line">MemoryLayout&lt;Password&gt;.size // 33, 实际用到的空间大小</span><br><span class="line">MemoryLayout&lt;Password&gt;.alignment // 8, 对齐参数</span><br><span class="line">var pwd = Password.number(9, 8, 6, 4)</span><br><span class="line">pwd = .other</span><br><span class="line">MemoryLayout.stride(ofValue: pwd) // 40</span><br><span class="line">MemoryLayout.size(ofValue: pwd) // 33</span><br><span class="line">MemoryLayout.alignment(ofValue: pwd) // 8</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;枚举的基本用法&quot;&gt;&lt;a href=&quot;#枚举的基本用法&quot; class=&quot;headerlink&quot; title=&quot;枚举的基本用法&quot;&gt;&lt;/a&gt;枚举的基本用法&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Swift" scheme="http://www.hxtec.top/tags/Swift/"/>
    
    <category term="语法" scheme="http://www.hxtec.top/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Swift-函数</title>
    <link href="http://www.hxtec.top/2022/09/18/Swift-%E5%87%BD%E6%95%B0/"/>
    <id>http://www.hxtec.top/2022/09/18/Swift-%E5%87%BD%E6%95%B0/</id>
    <published>2022-09-18T10:48:30.000Z</published>
    <updated>2022-09-18T10:51:19.996Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h2><blockquote><p>形参默认是let，也只能是let</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func pi() -&gt; Double &#123;</span><br><span class="line">    return 3.14</span><br><span class="line">&#125;</span><br><span class="line">func sum(v1: Int, v2: Int) -&gt; Int &#123;</span><br><span class="line">    return v1 + v2</span><br><span class="line">&#125;</span><br><span class="line">sum(v1: 10, v2: 20)</span><br></pre></td></tr></table></figure><blockquote><p>无返回值</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func sayHello() -&gt; Void &#123;</span><br><span class="line">    print(&quot;Hello&quot;) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func sayHello() -&gt; () &#123;</span><br><span class="line">    print(&quot;Hello&quot;) </span><br><span class="line">&#125;</span><br><span class="line">func sayHello() &#123;</span><br><span class="line">    print(&quot;Hello&quot;) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="隐式返回（Implicit-Return）"><a href="#隐式返回（Implicit-Return）" class="headerlink" title="隐式返回（Implicit Return）"></a>隐式返回（Implicit Return）</h2><ul><li>如果整个函数体是一个单一表达式，那么函数会隐式返回这个表达式<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func sum(v1: Int, v2: Int) -&gt; Int &#123;</span><br><span class="line">    v1 + v2</span><br><span class="line">&#125;</span><br><span class="line">sum(v1: 10, v2: 20) // 30</span><br></pre></td></tr></table></figure></li></ul><h2 id="返回元组：实现多返回值"><a href="#返回元组：实现多返回值" class="headerlink" title="返回元组：实现多返回值"></a>返回元组：实现多返回值</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func calculate(v1: Int, v2: Int) -&gt; (sum: Int, difference: Int, average: Int) &#123;</span><br><span class="line">    let sum = v1 + v2</span><br><span class="line">    return (sum, v1 - v2, sum &gt;&gt; 1)</span><br><span class="line">&#125;</span><br><span class="line">let result = calculate(v1: 20, v2: 10)</span><br><span class="line">result.sum // 30</span><br><span class="line">result.difference // 10</span><br><span class="line">result.average // 15</span><br></pre></td></tr></table></figure><h2 id="函数的文档注释"><a href="#函数的文档注释" class="headerlink" title="函数的文档注释"></a>函数的文档注释</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/// 求和【概述】</span><br><span class="line">///</span><br><span class="line">/// 将2个整数相加【更详细的描述】</span><br><span class="line">///</span><br><span class="line">/// - Parameter v1: 第1个整数</span><br><span class="line">/// - Parameter v2: 第2个整数</span><br><span class="line">/// - Returns: 2个整数的和</span><br><span class="line">///</span><br><span class="line">/// - Note:传入2个整数即可【批注】</span><br><span class="line">///</span><br><span class="line">func sum(v1: Int, v2: Int) -&gt; Int &#123;</span><br><span class="line">    v1 + v2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参数标签（Argument-Label）"><a href="#参数标签（Argument-Label）" class="headerlink" title="参数标签（Argument Label）"></a>参数标签（Argument Label）</h2><ul><li><p>可以修改参数标签</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func goToWork(at time: String) &#123;</span><br><span class="line">    print(&quot;this time is \(time)&quot;) </span><br><span class="line">&#125;</span><br><span class="line">goToWork(at: &quot;08:00&quot;)</span><br><span class="line">// this time is 08:00</span><br></pre></td></tr></table></figure></li><li><p>可以使用下划线 _ 省略参数标签</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func sum(_ v1: Int, _ v2: Int) -&gt; Int &#123;</span><br><span class="line">    v1 + v2</span><br><span class="line">&#125;</span><br><span class="line">sum(10, 20)</span><br></pre></td></tr></table></figure></li></ul><h2 id="默认参数值（Default-Parameter-Value）"><a href="#默认参数值（Default-Parameter-Value）" class="headerlink" title="默认参数值（Default Parameter Value）"></a>默认参数值（Default Parameter Value）</h2><ul><li><p>参数可以有默认值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func check(name: String = &quot;nobody&quot;, age: Int, job: String = &quot;none&quot;) &#123;</span><br><span class="line">    print(&quot;name=\(name), age=\(age), job=\(job)&quot;) </span><br><span class="line">&#125;</span><br><span class="line">check(name: &quot;Jack&quot;, age: 20, job: &quot;Doctor&quot;) // name=Jack, age=20, job=Doctor</span><br><span class="line">check(name: &quot;Rose&quot;, age: 18) // name=Rose, age=18, job=none</span><br><span class="line">check(age: 10, job: &quot;Batman&quot;) // name=nobody, age=10, job=Batman</span><br><span class="line">check(age: 15) // name=nobody, age=15, job=none</span><br></pre></td></tr></table></figure></li><li><p>C++的默认参数值有个限制：必须从右往左设置。由于Swift拥有参数标签，因此并没有此类限制</p></li><li><p>但是在省略参数标签时，需要特别注意，避免出错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 这里的middle不可以省略参数标签</span><br><span class="line">func test(_ first: Int = 10, middle: Int, _ last: Int = 30) &#123; &#125;</span><br><span class="line">test(middle: 20)</span><br></pre></td></tr></table></figure></li></ul><h2 id="可变参数（Variadic-Parameter）"><a href="#可变参数（Variadic-Parameter）" class="headerlink" title="可变参数（Variadic Parameter）"></a>可变参数（Variadic Parameter）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func sum(_ numbers: Int...) -&gt; Int &#123;</span><br><span class="line">    var total = 0</span><br><span class="line">    for number in numbers &#123;</span><br><span class="line">        total += number</span><br><span class="line">    &#125;</span><br><span class="line">    return total</span><br><span class="line">&#125;</span><br><span class="line">sum(10, 20, 30, 40) // 100</span><br></pre></td></tr></table></figure><ul><li>一个函数最多只能有1个可变参数</li><li>紧跟在可变参数后面的参数不能省略参数标签<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 参数string不能省略标签</span><br><span class="line">func test(_ numbers: Int..., string: String, _ other: String) &#123; &#125;</span><br><span class="line">test(10, 20, 30, string: &quot;Jack&quot;, &quot;Rose&quot;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="Swift自带的print函数"><a href="#Swift自带的print函数" class="headerlink" title="Swift自带的print函数"></a>Swift自带的print函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/// - Parameters:</span><br><span class="line">/// - items: Zero or more items to print.</span><br><span class="line">/// - separator: A string to print between each item. The default is a single space (`&quot; &quot;`).</span><br><span class="line">/// - terminator: The string to print after all items have been printed. The</span><br><span class="line">/// default is a newline (`&quot;\n&quot;`).</span><br><span class="line">public func print(_ items: Any..., separator: String = &quot; &quot;, terminator: String = &quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">print(1, 2, 3, 4, 5) // 1 2 3 4 5</span><br><span class="line"></span><br><span class="line">print(1, 2, 3, 4, 5, separator: &quot;_&quot;) // 1_2_3_4_5</span><br><span class="line"></span><br><span class="line">print(&quot;My name is Jake.&quot;, terminator: &quot;&quot;)</span><br><span class="line">print(&quot;My age is 18.&quot;)</span><br><span class="line">// My name is Jake.My age is 18.</span><br></pre></td></tr></table></figure><h2 id="输入输出参数（In-Out-Parameter）"><a href="#输入输出参数（In-Out-Parameter）" class="headerlink" title="输入输出参数（In-Out Parameter）"></a>输入输出参数（In-Out Parameter）</h2><ul><li><p>可以用inout定义一个输入输出参数：可以在函数内部修改外部实参的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func swapValues(_ v1: inout Int, _ v2: inout Int) &#123;</span><br><span class="line">    let tmp = v1</span><br><span class="line">    v1 = v2</span><br><span class="line">    v2 = tmp</span><br><span class="line">&#125;</span><br><span class="line">var num1 = 10</span><br><span class="line">var num2 = 20</span><br><span class="line">swapValues(&amp;num1, &amp;num2)</span><br><span class="line"></span><br><span class="line">func swapValues(_ v1: inout Int, _ v2: inout Int) &#123;</span><br><span class="line">    (v1, v2) = (v2, v1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可变参数不能标记为inout</p></li><li><p>inout参数不能有默认值</p></li><li><p>inout参数只能传入可以被多次赋值的</p></li><li><p>inout参数的本质是地址传递（引用传递）</p></li></ul><h2 id="函数重载（Function-Overload）"><a href="#函数重载（Function-Overload）" class="headerlink" title="函数重载（Function Overload）"></a>函数重载（Function Overload）</h2><ul><li>规则<ol><li>函数名相同</li><li>参数个数不同 || 参数类型不同 || 参数标签不同</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">func sum(v1: Int, v2: Int) -&gt; Int &#123;</span><br><span class="line">    v1 + v2</span><br><span class="line">&#125;</span><br><span class="line">func sum(v1: Int, v2: Int, v3: Int) -&gt; Int &#123;</span><br><span class="line">    v1 + v2 + v3</span><br><span class="line">&#125; // 参数个数不同</span><br><span class="line">func sum(v1: Int, v2: Double) -&gt; Double &#123;</span><br><span class="line">    Double(v1) + v2</span><br><span class="line">&#125; // 参数类型不同</span><br><span class="line">func sum(v1: Double, v2: Int) -&gt; Double &#123;</span><br><span class="line">    v1 + Double(v2)</span><br><span class="line">&#125; // 参数类型不同</span><br><span class="line">func sum(_ v1: Int, _ v2: Int) -&gt; Int &#123;</span><br><span class="line">    v1 + v2</span><br><span class="line">&#125; // 参数标签不同</span><br><span class="line">func sum(a: Int, b: Int) -&gt; Int &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125; // 参数标签不同</span><br><span class="line"></span><br><span class="line">sum(v1: 10, v2: 20) // 30</span><br><span class="line">sum(v1: 10, v2: 20, v3: 30) // 60</span><br><span class="line">sum(v1: 10, v2: 20.0) // 30.0</span><br><span class="line">sum(v1: 10.0, v2: 20) // 30.0</span><br><span class="line">sum(10, 20) // 30</span><br><span class="line">sum(a: 10, b: 20) // 30</span><br></pre></td></tr></table></figure><h2 id="函数重载注意点"><a href="#函数重载注意点" class="headerlink" title="函数重载注意点"></a>函数重载注意点</h2><ul><li><p>返回值类型与函数重载无关</p></li><li><p>默认参数值和函数重载一起使用产生二义性时，编译器并不会报错（在C++中会报错）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func sum(v1: Int, v2: Int) -&gt; Int &#123;</span><br><span class="line">    v1 + v2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func sum(v1: Int, v2: Int, v3: Int = 10) -&gt; Int &#123;</span><br><span class="line">    v1 + v2 + v3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 会调用sum(v1: Int, v2: Int) </span><br><span class="line">sum(v1: 10, v2: 20)</span><br></pre></td></tr></table></figure></li><li><p>可变参数、省略参数标签、函数重载一起使用产生二义性时，编译器有可能会报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func sum(v1: Int, v2: Int) -&gt; Int &#123;</span><br><span class="line">    v1 + v2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func sum(_ v1: Int, _ v2: Int) -&gt; Int &#123;</span><br><span class="line">    v1 + v2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func sum(_ numbers: Int...) -&gt; Int &#123;</span><br><span class="line">    var total = 0</span><br><span class="line">    for number in numbers &#123;</span><br><span class="line">        total += number</span><br><span class="line">    &#125;</span><br><span class="line">    return total</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// error: ambiguous use of &#x27;sum&#x27;</span><br><span class="line">sum(10, 20)</span><br></pre></td></tr></table></figure></li></ul><h2 id="内联函数（Inline-Function）"><a href="#内联函数（Inline-Function）" class="headerlink" title="内联函数（Inline Function）"></a>内联函数（Inline Function）</h2><ul><li><p>如果开启了编译器优化（Release模式默认会开启优化），编译器会自动将某些函数变成内联函数</p></li><li><p>将函数调用展开成函数体</p></li><li><p>哪些函数不会被自动内联？</p><ol><li>函数体比较长</li><li>包含递归调用</li><li>包含动态派发</li><li>……</li></ol></li></ul><h2 id="inline"><a href="#inline" class="headerlink" title="@inline"></a>@inline</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 永远不会被内联（即使开启了编译器优化）</span><br><span class="line">@inline(never) func test() &#123;</span><br><span class="line">    print(&quot;test&quot;) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 开启编译器优化后，即使代码很长，也会被内联（递归调用函数、动态派发的函数除外）</span><br><span class="line">@inline(__always) func test() &#123;</span><br><span class="line">    print(&quot;test&quot;) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在Release模式下，编译器已经开启优化，会自动决定哪些函数需要内联，因此没必要使用@inline</li></ul><h2 id="函数类型（Function-Type）"><a href="#函数类型（Function-Type）" class="headerlink" title="函数类型（Function Type）"></a>函数类型（Function Type）</h2><ul><li>每一个函数都是有类型的，函数类型由形式参数类型、返回值类型组成<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func test() &#123; &#125; // () -&gt; Void 或者 () -&gt; ()</span><br><span class="line"></span><br><span class="line">func sum(a: Int, b: Int) -&gt; Int &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125; // (Int, Int) -&gt; Int</span><br><span class="line"></span><br><span class="line">// 定义变量</span><br><span class="line">var fn: (Int, Int) -&gt; Int = sum</span><br><span class="line">fn(2, 3) // 5，调用时不需要参数标签</span><br></pre></td></tr></table></figure></li></ul><h2 id="函数类型作为函数参数"><a href="#函数类型作为函数参数" class="headerlink" title="函数类型作为函数参数"></a>函数类型作为函数参数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func sum(v1: Int, v2: Int) -&gt; Int &#123;</span><br><span class="line">    v1 + v2</span><br><span class="line">&#125;</span><br><span class="line">func difference(v1: Int, v2: Int) -&gt; Int &#123;</span><br><span class="line">    v1 - v2</span><br><span class="line">&#125;</span><br><span class="line">func printResult(_ mathFn: (Int, Int) -&gt; Int, _ a: Int, _ b: Int) &#123;</span><br><span class="line">    print(&quot;Result: \(mathFn(a, b))&quot;) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printResult(sum, 5, 2) // Result: 7</span><br><span class="line">printResult(difference, 5, 2) // Result: 3</span><br></pre></td></tr></table></figure><h2 id="函数类型作为函数返回值"><a href="#函数类型作为函数返回值" class="headerlink" title="函数类型作为函数返回值"></a>函数类型作为函数返回值</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func next(_ input: Int) -&gt; Int &#123;</span><br><span class="line">    input + 1 </span><br><span class="line">&#125;</span><br><span class="line">func previous(_ input: Int) -&gt; Int &#123;</span><br><span class="line">    input - 1</span><br><span class="line">&#125;</span><br><span class="line">func forward(_ forward: Bool) -&gt; (Int) -&gt; Int &#123;</span><br><span class="line">    forward ? next : previous</span><br><span class="line">&#125;</span><br><span class="line">forward(true)(3) // 4</span><br><span class="line">forward(false)(3) // 2</span><br></pre></td></tr></table></figure><ul><li>返回值是函数类型的函数，叫做高阶函数（Higher-Order Function）</li></ul><h2 id="typealias"><a href="#typealias" class="headerlink" title="typealias"></a>typealias</h2><ul><li><p>typealias用来给类型起别名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">typealias Byte = Int8</span><br><span class="line">typealias Short = Int16</span><br><span class="line">typealias Long = Int64</span><br><span class="line"></span><br><span class="line">typealias Date = (year: Int, month: Int, day: Int)</span><br><span class="line">func test(_ date: Date) &#123;</span><br><span class="line">    print(date.0)</span><br><span class="line">    print(date.year)</span><br><span class="line">&#125;</span><br><span class="line">test((2011, 9, 10))</span><br><span class="line"></span><br><span class="line">typealias IntFn = (Int, Int) -&gt; Int</span><br><span class="line">func difference(v1: Int, v2: Int) -&gt; Int &#123;</span><br><span class="line">    v1 - v2</span><br><span class="line">&#125;</span><br><span class="line">let fn: IntFn = difference</span><br><span class="line">fn(20, 10) // 10</span><br><span class="line"></span><br><span class="line">func setFn(_ fn: IntFn) &#123; &#125;</span><br><span class="line">setFn(difference)</span><br><span class="line"></span><br><span class="line">func getFn() -&gt; IntFn &#123; difference &#125;</span><br></pre></td></tr></table></figure></li><li><p>按照Swift标准库的定义，Void就是空元组()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public typealias Void = ()</span><br></pre></td></tr></table></figure></li></ul><h2 id="嵌套函数（Nested-Function）"><a href="#嵌套函数（Nested-Function）" class="headerlink" title="嵌套函数（Nested Function）"></a>嵌套函数（Nested Function）</h2><ul><li>将函数定义在函数内部<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func forward(_ forward: Bool) -&gt; (Int) -&gt; Int &#123;</span><br><span class="line">    func next(_ input: Int) -&gt; Int &#123;</span><br><span class="line">        input + 1 </span><br><span class="line">    &#125;</span><br><span class="line">    func previous(_ input: Int) -&gt; Int &#123;</span><br><span class="line">        input - 1 </span><br><span class="line">    &#125;</span><br><span class="line">    return forward ? next : previous</span><br><span class="line">&#125;</span><br><span class="line">forward(true)(3) // 4</span><br><span class="line">forward(false)(3) // 2</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;函数的定义&quot;&gt;&lt;a href=&quot;#函数的定义&quot; class=&quot;headerlink&quot; title=&quot;函数的定义&quot;&gt;&lt;/a&gt;函数的定义&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;形参默认是let，也只能是let&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure cl</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Swift" scheme="http://www.hxtec.top/tags/Swift/"/>
    
    <category term="语法" scheme="http://www.hxtec.top/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Swift-流程控制</title>
    <link href="http://www.hxtec.top/2022/09/18/Swift-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <id>http://www.hxtec.top/2022/09/18/Swift-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</id>
    <published>2022-09-18T10:45:05.000Z</published>
    <updated>2022-09-18T10:48:09.220Z</updated>
    
    <content type="html"><![CDATA[<h2 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h2><ul><li>if后面的条件只能是Bool类型</li><li>if后面的条件可以省略小括号</li><li>条件后面的大括号不能省略</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let age = 4</span><br><span class="line">if age &gt;= 22 &#123;</span><br><span class="line">    print(&quot;Get married&quot;)</span><br><span class="line">&#125; else if age &gt;= 18 &#123;</span><br><span class="line">    print(&quot;Being a adult&quot;)</span><br><span class="line">&#125; else if age &gt;= 7 &#123;</span><br><span class="line">    print(&quot;Go to school&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    print(&quot;Just a child&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var num = 5</span><br><span class="line">while num &gt; 0 &#123;</span><br><span class="line">    print(&quot;num is \(num)&quot;)</span><br><span class="line">    num -= 1</span><br><span class="line">&#125;// 打印了5次</span><br><span class="line"></span><br><span class="line">var num = -1</span><br><span class="line">repeat &#123;</span><br><span class="line">    print(&quot;num is \(num)&quot;)</span><br><span class="line">&#125; while num &gt; 0 //打印了一次</span><br></pre></td></tr></table></figure><ul><li>repeat-while相当于C语言中的do-while</li><li>这里不用num–，是因为</li><li>从Swift3开始，去除了自增（++）、自减（–）运算符</li></ul><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><blockquote><p>闭区间运算符： a…b, a &lt;&#x3D; 取值 &lt;&#x3D; b</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">let names = [&quot;Anna&quot;, &quot;Alex&quot;, &quot;Brian&quot;, &quot;Jack&quot;]</span><br><span class="line">for i in 0...3 &#123;</span><br><span class="line">    print(names[i])</span><br><span class="line">&#125;// Anna Alex Brian Jack</span><br><span class="line"></span><br><span class="line">let range = 1...3</span><br><span class="line">for i in range &#123;</span><br><span class="line">    print(names[i])</span><br><span class="line">&#125;// Alex Brian Jack</span><br><span class="line"></span><br><span class="line">let a = 1</span><br><span class="line">let b = 2</span><br><span class="line">for i in a...b &#123;</span><br><span class="line">    print(names[i])</span><br><span class="line">&#125;// Alex Brian</span><br><span class="line"></span><br><span class="line">// i默认是let, 有需要时可以声明为var</span><br><span class="line">for  var i in 1...3 &#123;</span><br><span class="line">    i += 5</span><br><span class="line">    print(i)</span><br><span class="line">&#125;// 6 7 8</span><br><span class="line"></span><br><span class="line">for _ in 1...3 &#123;</span><br><span class="line">    print(&quot;for&quot;)</span><br><span class="line">&#125;// 打印了3次</span><br></pre></td></tr></table></figure><blockquote><p>半开区间运算符： a..&lt;b, a&lt;&#x3D; 取值 &lt; b</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i in 1..&lt;5 &#123;</span><br><span class="line">    print(i)</span><br><span class="line">&#125;// 1 2 3 4 </span><br></pre></td></tr></table></figure><h2 id="for区间运算符用在数组上"><a href="#for区间运算符用在数组上" class="headerlink" title="for区间运算符用在数组上"></a>for区间运算符用在数组上</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let names = [&quot;Anna&quot;, &quot;Alex&quot;, &quot;Brian&quot;, &quot;Jack&quot;]</span><br><span class="line">for name in names[0...3] &#123;</span><br><span class="line">    print(name)</span><br><span class="line">&#125; // Anna Alex Brian Jack</span><br><span class="line"></span><br><span class="line">单侧区间：让区间朝一个方向尽可能的远</span><br><span class="line">for name in names[2...] &#123;</span><br><span class="line">    print(name)</span><br><span class="line">&#125; // Brian Jack</span><br><span class="line">for name in names[...2] &#123;</span><br><span class="line">    print(name)</span><br><span class="line">&#125; // Anna Alex Brian</span><br><span class="line">for name in names[..&lt;2] &#123;</span><br><span class="line">    print(name)</span><br><span class="line">&#125; // Anna Alex</span><br><span class="line"></span><br><span class="line">let range = ...5</span><br><span class="line">range.contains(7) // false</span><br><span class="line">range.contains(4) // true</span><br><span class="line">range.contains(-3) // true</span><br></pre></td></tr></table></figure><h2 id="区间类型"><a href="#区间类型" class="headerlink" title="区间类型"></a>区间类型</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let range1: ClosedRange&lt;Int&gt; = 1...3</span><br><span class="line">let range2: Range&lt;Int&gt; = 1..&lt;3</span><br><span class="line">let range3: PartialRangeThrough&lt;Int&gt; = ...5 </span><br><span class="line"></span><br><span class="line">字符、字符串也能使用区间运算符，但默认不能用在for-in中</span><br><span class="line">let stringRange1 = &quot;cc&quot;...&quot;ff&quot; // ClosedRange&lt;String&gt;</span><br><span class="line">stringRange1.contains(&quot;cb&quot;) // false</span><br><span class="line">stringRange1.contains(&quot;dz&quot;) // true</span><br><span class="line">stringRange1.contains(&quot;fg&quot;) // false</span><br><span class="line">let stringRange2 = &quot;a&quot;...&quot;f&quot;</span><br><span class="line">stringRange2.contains(&quot;d&quot;) // true</span><br><span class="line">stringRange2.contains(&quot;h&quot;) // false</span><br><span class="line">// \0到~囊括了所有可能要用到的ASCII字符</span><br><span class="line">let characterRange: ClosedRange&lt;Character&gt; = &quot;\0&quot;...&quot;~&quot;</span><br><span class="line">characterRange.contains(&quot;G&quot;) // true  </span><br></pre></td></tr></table></figure><h2 id="带间隔的区间值"><a href="#带间隔的区间值" class="headerlink" title="带间隔的区间值"></a>带间隔的区间值</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let hours = 11</span><br><span class="line">let horInterval = 2</span><br><span class="line">// tickMark的取值：从4开始，累加2，不超过11</span><br><span class="line">for tickMark in stride(from: 4, to: hours, by: horInterval) &#123;</span><br><span class="line">    print(tickMark)</span><br><span class="line">&#125;// 4 6 8 10</span><br></pre></td></tr></table></figure><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var number = 1</span><br><span class="line">switch number &#123;</span><br><span class="line">case 1:</span><br><span class="line">    print(&quot;number is 1&quot;)</span><br><span class="line">case 2:</span><br><span class="line">    print(&quot;number is 2&quot;)</span><br><span class="line">default:</span><br><span class="line">    print(&quot;number is other&quot;)</span><br><span class="line">&#125;// number is 1</span><br></pre></td></tr></table></figure><ul><li>默认可以不写break,并不会贯穿到后面的条件</li><li>case,default后面不能写大括号{}</li></ul><h2 id="fallthrough"><a href="#fallthrough" class="headerlink" title="fallthrough"></a>fallthrough</h2><blockquote><p>使用fallthrough可以实现贯穿效果</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var number = 1</span><br><span class="line">switch number &#123;</span><br><span class="line">case 1:</span><br><span class="line">print(&quot;number is 1&quot;)</span><br><span class="line">fallthrough</span><br><span class="line">case 2:</span><br><span class="line">print(&quot;number is 2&quot;)</span><br><span class="line">default:</span><br><span class="line">print(&quot;number is other&quot;) &#125;</span><br><span class="line">// number is 1</span><br><span class="line">// number is 2</span><br></pre></td></tr></table></figure><h2 id="switch注意点"><a href="#switch注意点" class="headerlink" title="switch注意点"></a>switch注意点</h2><ul><li>switch必须要保证能处理所有情况</li><li>case、default后面至少要有一条语句</li><li>如果不想做任何事，加个break即可<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var number = 1</span><br><span class="line">switch number &#123;</span><br><span class="line">case 1:</span><br><span class="line">    print(&quot;number is 1&quot;)</span><br><span class="line">case 2:</span><br><span class="line">    print(&quot;number is 2&quot;)</span><br><span class="line">default:</span><br><span class="line">    break</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果能保证已处理所有情况，也可以不必使用default</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">enum Answer &#123; case right, wrong &#125;</span><br><span class="line">let answer = Answer.right</span><br><span class="line">switch answer &#123;</span><br><span class="line">case Answer.right:</span><br><span class="line">    print(&quot;right&quot;)</span><br><span class="line">case Answer.wrong:</span><br><span class="line">    print(&quot;wrong&quot;) &#125;</span><br><span class="line">    </span><br><span class="line">// 由于已确定answer是Ansewer类型，因此可以省略Answer</span><br><span class="line">switch answer &#123;</span><br><span class="line">case .right:</span><br><span class="line">    print(&quot;right&quot;)</span><br><span class="line">case .wrong:</span><br><span class="line">    print(&quot;wrong&quot;) &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="复合条件"><a href="#复合条件" class="headerlink" title="复合条件"></a>复合条件</h2><blockquote><p>switch也支持Character、String类型</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">let string = &quot;Jack&quot;</span><br><span class="line">switch string &#123;</span><br><span class="line">case &quot;Jack&quot;:</span><br><span class="line">    fallthrough</span><br><span class="line">case &quot;Rose&quot;:</span><br><span class="line">    print(&quot;Right person&quot;)</span><br><span class="line">default:</span><br><span class="line">    break</span><br><span class="line">&#125; // Right person</span><br><span class="line"></span><br><span class="line">let character: Character = &quot;a&quot;</span><br><span class="line">switch character &#123;</span><br><span class="line">case &quot;a&quot;, &quot;A&quot;:</span><br><span class="line">    print(&quot;The letter A&quot;)</span><br><span class="line">default:</span><br><span class="line">    print(&quot;Not the letter A&quot;) &#125; // The letter A</span><br><span class="line"></span><br><span class="line">switch string &#123;</span><br><span class="line">case &quot;Jack&quot;, &quot;Rose&quot;:</span><br><span class="line">    print(&quot;Right person&quot;)</span><br><span class="line">default:</span><br><span class="line">    break</span><br><span class="line">&#125; // Right person</span><br></pre></td></tr></table></figure><h2 id="区间匹配、元组匹配"><a href="#区间匹配、元组匹配" class="headerlink" title="区间匹配、元组匹配"></a>区间匹配、元组匹配</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">let count = 62</span><br><span class="line">switch count &#123;</span><br><span class="line">case 0:</span><br><span class="line">    print(&quot;none&quot;)</span><br><span class="line">case 1..&lt;5:</span><br><span class="line">    print(&quot;a few&quot;)</span><br><span class="line">case 5..&lt;12:</span><br><span class="line">    print(&quot;several&quot;)</span><br><span class="line">case 12..&lt;100:</span><br><span class="line">    print(&quot;dozens of&quot;)</span><br><span class="line">case 100..&lt;1000:</span><br><span class="line">    print(&quot;hundreds of&quot;)</span><br><span class="line">default:</span><br><span class="line">    print(&quot;many&quot;)</span><br><span class="line">&#125; // dozens of</span><br><span class="line"></span><br><span class="line">let point = (1, 1)</span><br><span class="line">switch point &#123;</span><br><span class="line">case (0, 0):</span><br><span class="line">    print(&quot;the origin&quot;)</span><br><span class="line">case (_, 0):</span><br><span class="line">    print(&quot;on the x-axis&quot;)</span><br><span class="line">case (0, _):</span><br><span class="line">    print(&quot;on the y-axis&quot;)</span><br><span class="line">case (-2...2, -2...2):</span><br><span class="line">    print(&quot;inside the box&quot;)</span><br><span class="line">default:</span><br><span class="line">    print(&quot;outside of the box&quot;) &#125; // inside the box</span><br></pre></td></tr></table></figure><ul><li>可以使用下划线 _ 忽略某个值</li><li>关于case匹配问题，属于模式匹配（Pattern Matching）的范畴</li></ul><h2 id="值绑定"><a href="#值绑定" class="headerlink" title="值绑定"></a>值绑定</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let point = (2, 0)</span><br><span class="line">switch point &#123;</span><br><span class="line">case (let x, 0):</span><br><span class="line">    print(&quot;on the x-axis with an x value of \(x)&quot;)</span><br><span class="line">case (0, let y):</span><br><span class="line">    print(&quot;on the y-axis with a y value of \(y)&quot;)</span><br><span class="line">case let (x, y):</span><br><span class="line">    print(&quot;somewhere else at (\(x), \(y))&quot;)</span><br><span class="line">&#125; // on the x-axis with an x value of 2</span><br></pre></td></tr></table></figure><ul><li>必要时let也可以改为var</li></ul><h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let point = (1, -1)</span><br><span class="line">switch point &#123;</span><br><span class="line">case let (x, y) where x == y:</span><br><span class="line">    print(&quot;on the line x == y&quot;)</span><br><span class="line">case let (x, y) where x == -y:</span><br><span class="line">    print(&quot;on the line x == -y&quot;)</span><br><span class="line">case let (x, y):</span><br><span class="line">    print(&quot;(\(x), \(y)) is just some arbitrary point&quot;)</span><br><span class="line">&#125; // on the line x == -y</span><br><span class="line"></span><br><span class="line">// 将所有正数加起来</span><br><span class="line">var numbers = [10, 20, -10, -20, 30, -30]</span><br><span class="line">var sum = 0</span><br><span class="line">for num in numbers where num &gt; 0 &#123; // 使用where来过滤num</span><br><span class="line">    sum += num</span><br><span class="line">&#125;</span><br><span class="line">print(sum) // 60</span><br></pre></td></tr></table></figure><h3 id="标签语句"><a href="#标签语句" class="headerlink" title="标签语句"></a>标签语句</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">outer: for i in 1...4 &#123;</span><br><span class="line">    for k in 1...4 &#123;</span><br><span class="line">        if k == 3 &#123;</span><br><span class="line">            continue outer</span><br><span class="line">        &#125;</span><br><span class="line">        if i == 3 &#123;</span><br><span class="line">            break outer</span><br><span class="line">        &#125;</span><br><span class="line">        print(&quot;i == \(i), k == \(k)&quot;) &#125; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;if-else&quot;&gt;&lt;a href=&quot;#if-else&quot; class=&quot;headerlink&quot; title=&quot;if-else&quot;&gt;&lt;/a&gt;if-else&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;if后面的条件只能是Bool类型&lt;/li&gt;
&lt;li&gt;if后面的条件可以省略小括号&lt;/li</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Swift" scheme="http://www.hxtec.top/tags/Swift/"/>
    
    <category term="语法" scheme="http://www.hxtec.top/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Swift-基础语法</title>
    <link href="http://www.hxtec.top/2022/09/18/Swift-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>http://www.hxtec.top/2022/09/18/Swift-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</id>
    <published>2022-09-18T10:37:59.000Z</published>
    <updated>2022-09-18T10:44:35.399Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><ul><li>不用编写main函数，Swift将全局范围内的首句可执行代码作为程序入口</li><li>一句代码尾部可以省略分号（ <code>; </code>），多句代码写到同一行时必须用分号（;）隔开</li><li>用 <code>var </code>定义变量， <code>let </code>定义常量，编译器能自动推断出变量\常量的类型</li></ul><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 单行注释</span><br><span class="line">/*</span><br><span class="line">多行注释</span><br><span class="line"> */</span><br><span class="line"> /*</span><br><span class="line"> 1</span><br><span class="line"> /* 多行注释的嵌套 */</span><br><span class="line"> 2</span><br><span class="line">  */</span><br></pre></td></tr></table></figure><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><ul><li>只能赋值1次 </li><li>它的值不要求在编译时期确定，但使用之前必须赋值1次</li><li>常量、变量在初始化之前都不能使用</li></ul><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><ul><li>标识符（比如常量名、变量名、函数名）几乎可以使用任何字符</li><li>标识符不能以数字开头，不能包含空白字符、制表符、箭头等特殊字符</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func 🐂🍺() &#123;</span><br><span class="line">    print(&quot;666&quot;)</span><br><span class="line">&#125;</span><br><span class="line">🐂🍺()</span><br><span class="line"></span><br><span class="line">let 🦊 = &quot;Fox&quot;</span><br><span class="line">var 🐵 = &quot;Monkey&quot;</span><br></pre></td></tr></table></figure><h3 id="常见数据类型"><a href="#常见数据类型" class="headerlink" title="常见数据类型"></a>常见数据类型</h3><ol><li>值类型</li></ol><ul><li>枚举 enum<br>  optional</li><li>结构体 struct<br>  Bool, Int, Float, Double, Character<br>  String, Array, Dictionary, Set</li></ul><ol start="2"><li>引用类型</li></ol><ul><li>类 Class</li></ul><p>注：</p><ul><li>整数类型：Int8、Int16、Int32、Int64、UInt8、UInt16、UInt32、UInt64</li><li>在32bit平台，Int等价于Int32；在64bit平台， Int等价于Int64</li><li>整数的最值：UInt8.max、Int16.min</li><li>一般情况下，都是直接使用Int即可</li><li>浮点类型：Float，32位，精度只有6位；Double，64位，精度至少15位</li></ul><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 整数转换</span><br><span class="line">let int1: UInt16 = 2_000</span><br><span class="line">let int2: UInt8 = 1</span><br><span class="line">let int3 = int1 + UInt16(int2)</span><br><span class="line"></span><br><span class="line">// 整数、浮点数转换</span><br><span class="line">let int = 3</span><br><span class="line">let double = 0.314</span><br><span class="line">let pi = Double(int) + double</span><br><span class="line">let intPi = Int(pi)</span><br><span class="line"></span><br><span class="line">// 字面量可以直接相加 ，因为数字字面量本身没有明确的类型</span><br><span class="line">let result = 3 + 0.14159</span><br></pre></td></tr></table></figure><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let http404Error = (404, &quot;Not Found&quot;)</span><br><span class="line">print(&quot;The status code is \(http404Error.0)&quot;)</span><br><span class="line"></span><br><span class="line">let (statusCode, statusMessage) = http404Error</span><br><span class="line">print(&quot;The status code is \(statusCode)&quot;)</span><br><span class="line"></span><br><span class="line">let (justTheStatusCode, _) = http404Error</span><br><span class="line"></span><br><span class="line">let http200Status = (statusCode: 200, description: &quot;OK&quot;)</span><br><span class="line">print(&quot;The status code is \(http200Status.statusCode)&quot;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基础语法&quot;&gt;&lt;a href=&quot;#基础语法&quot; class=&quot;headerlink&quot; title=&quot;基础语法&quot;&gt;&lt;/a&gt;基础语法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;不用编写main函数，Swift将全局范围内的首句可执行代码作为程序入口&lt;/li&gt;
&lt;li&gt;一句代码尾部可以省略</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Swift" scheme="http://www.hxtec.top/tags/Swift/"/>
    
    <category term="语法" scheme="http://www.hxtec.top/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>佳能相机</title>
    <link href="http://www.hxtec.top/2022/09/17/%E4%BD%B3%E8%83%BD%E7%9B%B8%E6%9C%BA/"/>
    <id>http://www.hxtec.top/2022/09/17/%E4%BD%B3%E8%83%BD%E7%9B%B8%E6%9C%BA/</id>
    <published>2022-09-17T10:25:51.000Z</published>
    <updated>2022-09-17T10:28:10.201Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、佳能单反相机的相关问题"><a href="#一、佳能单反相机的相关问题" class="headerlink" title="一、佳能单反相机的相关问题"></a>一、佳能单反相机的相关问题</h2><h3 id="1-佳能单反和尼康单反哪个好"><a href="#1-佳能单反和尼康单反哪个好" class="headerlink" title="1.佳能单反和尼康单反哪个好"></a>1.佳能单反和尼康单反哪个好</h3><p>1、尼康的使用评价：<strong>上手较难，风景很好</strong></p><ul><li>尼康偏向金属风，所以材质坚硬，沉重的质感不得不说是相机品质的体现，<strong>风景拍摄</strong>很赞。但同时也增加了<strong>携带的困难</strong>。</li><li>繁琐和困难的上手教程是很多新手头疼的问题，所以<strong>新手上路并不推荐</strong>。</li></ul><p>2、佳能的使用体验：<strong>上手容易，成像优质</strong></p><ul><li>佳能优越的<strong>人像摄影</strong>使佳能在摄影人像方面非常受人欢迎。搭载优秀的图像处理器，使得佳能拍出来的照片在后期处理非常出色。</li><li>简单易学的操作，让佳能深受新手欢迎。人们可以很容易地上手色彩和操作页面。</li></ul><p><strong>结论：</strong></p><ul><li>如果你是新手，对人像拍摄要求高，那么佳能可能更适合你；</li><li>反之如果你也是个专业大佬了，对风景拍摄要求高，那么可以选尼康。</li></ul><h3 id="2-单反相机-VS-微单相机-VS-普通数码相机（三者的比较）"><a href="#2-单反相机-VS-微单相机-VS-普通数码相机（三者的比较）" class="headerlink" title="2.单反相机 VS 微单相机 VS 普通数码相机（三者的比较）"></a>2.单反相机 VS 微单相机 VS 普通数码相机（三者的比较）</h3><h3 id="3-佳能单反型号的比较"><a href="#3-佳能单反型号的比较" class="headerlink" title="3.佳能单反型号的比较"></a>3.佳能单反型号的比较</h3><p>佳能所有数码单反采用以数字加字母D方式命名。在数字方面，数字位数越少，型号越高端。</p><ul><li>全画幅和旗舰APS-C画幅单反：一位数机型XD</li><li>高端APS-C画幅单反：两位数XXD）</li><li>中端APS-C画幅单反：三位数XXXD</li><li>低端APS-C画幅单反：四位数XXXXD</li></ul><h2 id="二、如何去选购一台好的佳能单反相机"><a href="#二、如何去选购一台好的佳能单反相机" class="headerlink" title="二、如何去选购一台好的佳能单反相机"></a>二、如何去选购一台好的佳能单反相机</h2><p>下面我们介绍几个最重要的性能：</p><p><strong>1、图像处理器和传感器</strong></p><p>单反相机的图像处理器就像是电脑的CPU芯片一样，他是这个相机的核心所在。在图片呈现的过程中，图像处理器负责接收感光器的数据，也就是说，他是照相的第一步，也是最关键的一步。</p><p>它需要一个好的传感器，传感器的类型分为全画幅，中画幅等。画幅越大的相机越优秀，就像屏幕越大的电子设备也就越贵，在选购单反相机时，选择全画幅才能有好的图像处理。</p><p><strong>2、像素</strong></p><p>它是计算数码影像的一种单位。 我们的照片由大量的像素构成。像素是决定一个相机的关键因素,根据预算和个人需求，大部分是越高的像素成像越好，结合个人要求来选择合适自己的像素，不必追求过高的像素。当下绝大部分单反和微单相机的像素都在两千万以上。</p><p><strong>小结：</strong> 尽管理论上像素越大越好，不过目前主流的相机的像素使用过来完全绰绰有余。</p><p><strong>3、续航能力</strong></p><p>当你在出去旅游或者野外拍摄时，你最关心的除了风景是否优美，然后就是你相机的电量问题，如果你拿着一部随时都要充电的相机的话，那么这个在拍摄过程中是没有任何快乐所言的，所以买相机最重要的因素之一，是他的续航能力，选择续航能力强的相机会，让你的旅途拍摄过程中更加愉快。</p><p><strong>4、连拍速度</strong></p><p>当你想要捕捉到旅途中一个动态的美景时，这个时候就要考虑你相机的连拍速度了。把你的相机连拍速度很快的话，那么你可以轻易捕捉到一张富有动态美的图片，在考虑相机参数的同时也要把连拍速度考虑进去，因为这一功能也是彰显相机性能是否强大的原因之一。</p><p><strong>5、感光度</strong></p><p>感光器有CCD和CMOS。原理是将感受到的物理光学信号转化为数码信息。在拍摄过程中，通过调解感光度可以获得不同光线下的照片。高感光度的相机可以给照片带来质的飞跃。</p><p><strong>6、其他功能</strong></p><p>防抖：相机的防抖功能可以让相片拍摄的更加清晰，减少因手抖导致的画面模糊，具备防抖功能的机身可以将任何一款镜头变为防抖镜头，增加相片的画质和清晰度。<br>防尘防水：当相机在日常使用和存放中，防水防尘的功能可以让相机的使用寿命延长，是相机的防护伞。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、佳能单反相机的相关问题&quot;&gt;&lt;a href=&quot;#一、佳能单反相机的相关问题&quot; class=&quot;headerlink&quot; title=&quot;一、佳能单反相机的相关问题&quot;&gt;&lt;/a&gt;一、佳能单反相机的相关问题&lt;/h2&gt;&lt;h3 id=&quot;1-佳能单反和尼康单反哪个好&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="相机" scheme="http://www.hxtec.top/categories/%E7%9B%B8%E6%9C%BA/"/>
    
    
    <category term="Camera" scheme="http://www.hxtec.top/tags/Camera/"/>
    
  </entry>
  
  <entry>
    <title>思考致富</title>
    <link href="http://www.hxtec.top/2022/09/17/%E6%80%9D%E8%80%83%E8%87%B4%E5%AF%8C/"/>
    <id>http://www.hxtec.top/2022/09/17/%E6%80%9D%E8%80%83%E8%87%B4%E5%AF%8C/</id>
    <published>2022-09-17T10:10:01.000Z</published>
    <updated>2022-09-17T10:24:38.837Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、心想才能事成"><a href="#一、心想才能事成" class="headerlink" title="一、心想才能事成"></a>一、心想才能事成</h2><ul><li>如果一个人真想做一件事，那他一定会做成。</li><li>成功人士，最伟大的成功在于，面临失败时能坚持再迈出一步。</li><li>不管一件事有多困难，都要坚持做下去。</li><li>成功钟情于那些有成功意识的人。</li><li>我们是自己命运的主宰者。</li></ul><h2 id="二、欲望"><a href="#二、欲望" class="headerlink" title="二、欲望"></a>二、欲望</h2><ul><li>拥有梦想，希望，愿望，欲望和计划。</li><li>明确的目标</li><li>绝不轻言放弃</li><li>没有人能被打败，除非接受失败的事实</li><li>一个人只有相信自己能得到某物，都会准备接受它。</li><li><code>每一种逆境，都隐藏着相同的优势。 </code></li></ul><h2 id="三、信心"><a href="#三、信心" class="headerlink" title="三、信心"></a>三、信心</h2><ul><li>信心，爱和性的力量最为强大。</li><li><code>不断反复并确定地对潜意识发号施令，是自发培养信心的唯一方法。 </code></li><li><code>抑制、排队消极负面情感，是一个人最基本的态度。 </code></li><li>一切都与心态有关，最后的胜利，属于那个相信自己能行的我。</li><li>杰出人物，他们每个人的背后几乎都有一个女性的爱在支持着他。</li></ul><h2 id="四、自我暗示"><a href="#四、自我暗示" class="headerlink" title="四、自我暗示"></a>四、自我暗示</h2><ul><li>你，只有你，来决定你为之奋斗的回报（即多钱意识），是否值得你为之辛苦地付出。</li></ul><h2 id="五、专业知识"><a href="#五、专业知识" class="headerlink" title="五、专业知识"></a>五、专业知识</h2><ul><li>知识只是潜在的力量，只有与明确的行动计划和目标相结合，知识才能成为力量。</li><li>人们只珍惜那些需要付费的东西。</li><li>那些安排业余时间在家学习的人，尤其是那些靠薪水为生的人，很少会满足于久居低层的现状，他们的行动为自己开辟了一条晋升之路，清除了前进道路上的障碍，赢得了有权给予他们机会的人的青睐。</li><li>从最底层做起，往往会让人感到前途暗淡，沮丧绝望， <code>它会扼杀一个人的抱负。 </code></li><li>不论一个人是升至高位，还是屈居低职，都取决于他对环境的控制能力。</li><li><code>成败在很大程度上才是“习惯”的结果 </code></li><li><code>和一个不向逆境妥协的人共事并密切接触，将是一笔永远无法用多钱衡量的财富。 </code></li><li>靠周密计划，避免从低层做起。</li><li>专业知识易得，而创新构想难求。</li></ul><h2 id="六、想象力"><a href="#六、想象力" class="headerlink" title="六、想象力"></a>六、想象力</h2><ul><li>想象力会因为疏于使用而变得迟钝，但也会因为使用而变得活跃、敏锐。</li><li>欲望是一种意念冲动，意念冲动就是一种能量形式。</li><li>当一股炽烈的欲望支撑着一个明确的目标时，一个人就会被激发出内在的热情、生机和力量。</li><li><code>假如你认为辛苦工作和诚实守信是唯一的致富之路，那么你一定要打消这个念头。 </code></li><li><code>一般的欲望不可能战胜失望、气馁、、暂时的挫折及批评，那是一种强烈的欲望，一种萦绕于心、挥之不去的意念。 </code></li><li>构想是一股无形的力量，却比产生它们的有形的头脑更强大。</li></ul><h2 id="七、精心策划"><a href="#七、精心策划" class="headerlink" title="七、精心策划"></a>七、精心策划</h2><ul><li>大部分人会遭遇失败的关键，是由于缺乏创造新计划来取代失败计划的持久毅力。</li><li><code>暂时的挫折并不代表永远的失败。 </code></li><li><code>如果轻易放弃，就是一个半途而废的人，一个半途而废的人，永远不可能成功，成功的人，绝不会半途而废。 </code></li><li>欲望才是赚钱的媒介。</li><li>无法控制自我的人，永远无法控制其他人。</li><li>最伟大的领导是众人之仆。</li><li>教育必须多讲实践，少讲理论。</li><li>关注自己能做什么。</li><li>有教养的人懂得在不侵犯他人利益的前提下，支获得自己想要的东西。</li><li>只有先控制自己，才能控制环境。</li><li><code>如果婚姻不和谐，失败会接踵而至，表现为不幸和痛苦，它能摧毁一个人所有的雄心壮志。 </code></li><li>任何形式的放纵，对成功来说都是致命的。</li><li>一夜暴富比贫穷理可怕。</li><li><code>诚实是一种不可替代的品质。 </code></li><li><code>谋求新的职位时，必须确保自己的价值高于目前所得到的报酬。 </code></li><li>一年一度的自我分析非常必要， <code>一个人的目标应该是不断前进。 </code></li><li>机会就在眼前。</li></ul><blockquote><p> 领导者的主要素质</p></blockquote><ol><li>因对自我以及所从事职业的认知而产生的毫不动摇的勇气</li><li>自制力</li><li>强烈的正义感</li><li>果断的决策</li><li>明确的计划</li><li>不计报酬的工作习惯</li><li>愉悦随和的个性</li><li>同情与体谅</li><li>掌握细节</li><li>愿负全责</li><li>合作</li></ol><p>能引起下属情感共鸣与认同的领导为佳</p><h2 id="八、决心"><a href="#八、决心" class="headerlink" title="八、决心"></a>八、决心</h2><ul><li>意见是世界上最廉价的商品，如果做决策时晚受他人影响，那么很难做成任何事。</li><li>如果总是受别人观点的影响，那么将失去自己的目标。</li><li><code>自己大脑，就要用它做出自己的决策。 </code></li><li><code>真正的智慧通常表现为谦虚和沉默。 </code></li><li>先做后说</li><li>各行种业的领导者都是那些能下决心的人。</li></ul><h2 id="九、毅力"><a href="#九、毅力" class="headerlink" title="九、毅力"></a>九、毅力</h2><ul><li><p>多钱意识必须刻意培养，除非一个人生来就有这种意识。</p></li><li><p>财富不会回应愿望，只能通过欲望的力量，借助持久的毅力，来回应明确的计划。</p></li><li><p>每一次失败都蕴藏着一颗潜在成功的种子。</p><blockquote><p> <strong>毅力形成具有明确的因素：</strong></p><ol><li>明确的目标，知道自己想要什么，强烈的动机会驱使人克服任何困难。</li><li>欲望</li><li>自信</li><li>明确的计划</li><li>认清自我</li><li>合作</li><li>意志力</li><li>习惯</li></ol></blockquote></li><li><p><code>如果坚持下去，机遇迟早会降临到自己头上。 </code></p></li><li><p><code>机遇都是自己创造的 </code>，来自毅力，其出发点是明确的目的。</p></li><li><p><code>财富不会回应欲望，只能通过欲望的力量，借助持久的毅力，来回应明确的计划。 </code></p><blockquote><p>如何培养毅力：</p><ol><li>在强烈欲望的驱使下，拥有明确的目的。</li><li>不断用行动体现出明确计划。</li><li>不受消极懈怠思想的影响，包括来自家人，朋友和熟人等思想的影响。</li><li>结交一个或几个能鼓励你依照计划和目标行事的人。</li></ol></blockquote></li><li><p>除了毅力，再找不到任何特质可以与其惊人成就相关的了。</p></li></ul><h2 id="十、智囊团的力量"><a href="#十、智囊团的力量" class="headerlink" title="十、智囊团的力量"></a>十、智囊团的力量</h2><ul><li>人类的大脑是一种能量形式</li><li>使他人的智慧与自己的智慧结合在一起。这正是获得力量的秘诀。</li><li>伟大的力量可以通过智慧的友善结盟而产生。</li><li>追求金钱时，那股力量必须再加上信心、欲望和毅力。</li><li><code>积极的思想情感会形成个人通往财富 </code>的那一侧水流，消极的情感形成带领个人流向贫穷的另一侧水流。</li></ul><h2 id="十一、性欲转换的奥秘"><a href="#十一、性欲转换的奥秘" class="headerlink" title="十一、性欲转换的奥秘"></a>十一、性欲转换的奥秘</h2><ul><li>性激情隐含三种建设性潜在力量：<blockquote><ol><li>人类的繁衍</li><li>保持健康（它的治疗作用无可比拟）</li><li>通过转化性欲力量，将庸才变成天才</li></ol></blockquote></li><li><code>性欲是人类最强烈的一种欲望。 </code></li><li>性欲的表达是天生的，自然的。</li><li><code>假如不用创造性的方式加以引导，它就会以不具有价值的渠道发泄出来。 </code></li><li><code>获得卓越成就的人，其背后都有女性的力量在驱动他们。 </code></li><li>大部分人只有通过情感才能受到影响。</li><li>“当事的女主角”通常都是个谦逊，甘愿自我牺牲的妻子。</li><li><code>一般人要在4-~60岁才能进入创造力最强的阶段，接近这个年纪是，不应心怀恐惧、忧虑，而是应该满怀希望、热切期待。 </code> 40~60岁是创造人生业绩的黄金时期。</li><li><code>30~40岁，人们开始学习性欲转换的技巧。 </code></li></ul><blockquote><p>开启情感动力</p></blockquote><ul><li>当爱开始和性的激情融合起来是，其结果就是目标专一、心态稳定、判断准确、身心平衡。<br> <code>一个人到了40岁之后，如果仍然无法体会并以自己的经验来加以印证这些的话，那真可谓是最大的不幸。 </code>    </li><li>当性激情里有了爱的情感之后，同样一个人就可能会更明智，心态更平和地引导自己的行为。</li><li>抑制所有破坏性情感的产生。</li><li><code>要想成为天才，除了通过自我努力之外，别无他法。 </code></li><li>爱、浪漫和性都能驱使男人达到成就的巅峰。    </li><li>爱的作用犹如安全阀，能确保身心平衡、宁静，做出建设性的工作。</li></ul><blockquote><p>真爱永存</p></blockquote><ul><li>得不到爱的激励而无法登上成就高峰的人是没有希望的——他会犹如行尸走肉。    </li><li>真正爱过的人不可能完全失去爱，也别存有真爱只有一次的念头。爱去了还会再来，没有一定的次数，但从来没有两份爱会以相同的方式影响一个人。</li><li>所有的爱都是财富，除非一个在爱离去时变得愤世嫉俗。    </li><li>爱是精神的，性是生理的。    </li><li>无疑，爱是人生最大的体验。  </li><li>只有爱，或者只有性，都无法为婚姻带来幸福， <code>这两种美好情感互相融合所产生的婚姻，是世人追求的理想精神境界。 </code></li></ul><blockquote><p>女人可以成就男人，也可以毁灭男人</p></blockquote><ul><li><code>如果妻子能了解爱、性激情和浪漫之间的真正关系，那么她的丈夫是幸运的。 </code> 受到这三种神圣组合所激励时，没有一种劳动会成为负担，因为此时，即使最低等的劳动形式也是基于爱而产生的。  </li><li>成就和毁灭，其实就在于女人是否了解“爱”，“性”和“浪漫情感”。</li><li>假如一个女人让男人对她失去兴趣而去对另外一个女人产生兴趣，通常是因为她对于性、爱和浪漫情感的无知和漠视所导致的，这种说法的前提当然是假设他们之间曾经存在一份真爱。</li></ul><blockquote><p>没有女性的财富毫无价值</p></blockquote><ul><li>男人最强的动力是取悦女人的欲望！    </li><li>现代男人取悦女人的欲望与史前没有改变。  </li><li>如果生命中的女人被夺走，那么再多的财富对于大多数男人而言都没有意义。    </li><li>了解男人的本性并巧妙地迎合其需要的女人，无须担心来自其他女人的竞争。    </li><li>用积极的心态，面对惨淡的人生，永远相信美好的事情即将到来。</li></ul><h2 id="十二、潜意识——连接环节"><a href="#十二、潜意识——连接环节" class="headerlink" title="十二、潜意识——连接环节"></a>十二、潜意识——连接环节</h2><ul><li>潜意识只有通过习惯才能受到自己的意愿指引。</li></ul><blockquote><p>利用积极情感</p></blockquote><ul><li>只有被赋予情感的意念，才能对潜意识产生行动的影响力</li><li>积极情感和消极情感不会同时存在于心，一定是只有一种占据主导地位。    </li><li>认识不到这一重要事实的男人，就失去了取得成就所需的最强大的力量。</li><li><code>我们有责任让积极情感成为内心的主宰力量。 </code></li></ul><h2 id="十三、大脑——思想的广播站和接收站"><a href="#十三、大脑——思想的广播站和接收站" class="headerlink" title="十三、大脑——思想的广播站和接收站"></a>十三、大脑——思想的广播站和接收站</h2><ul><li>就强度和马士图而言，性高居人类各种情感之首。</li><li>潜意识、创造型想象力和自我暗示。</li></ul><h2 id="十四、第六感——通往智慧殿堂之门"><a href="#十四、第六感——通往智慧殿堂之门" class="headerlink" title="十四、第六感——通往智慧殿堂之门"></a>十四、第六感——通往智慧殿堂之门</h2><ul><li>即使无法成为真正的伟人，也要模仿伟人，在感觉和行动上尽可能地接近他们。</li><li>让个人可以正确无误地指引自己，获得人生中追求的一切。</li><li><code>任何成就的起点都是欲望，终极目标则是寻求认识——认识自我，认识他人，认识自然规律，认识和理解幸福。 </code></li></ul><h2 id="十五、6种恐惧——剖析自我，找出成功路上的“拦路虎”"><a href="#十五、6种恐惧——剖析自我，找出成功路上的“拦路虎”" class="headerlink" title="十五、6种恐惧——剖析自我，找出成功路上的“拦路虎”"></a>十五、6种恐惧——剖析自我，找出成功路上的“拦路虎”</h2><ul><li>除掉的三个敌人：犹豫、怀疑和恐惧。</li><li>财富可能是多钱，还可能是大于多钱价值的心态。</li><li>6各恐惧：1.贫穷 2.批评 3.病痛 4.失去爱情 5.衰老 6.死亡</li><li>一个人的心态是可以控制和引导的。</li><li><code>人的意念冲动，不管是自觉的，还是不自觉的，都会很快转化为它的实质对等物。 </code></li><li><code>每个人都有能力完全控制自己的意志。 </code></li><li>通往财富之路的起点，就是欲望。</li><li><code>带给人类痛苦和屈辱的莫过于贫穷了。 </code></li><li>疾病有时始于消极的意念冲动。</li><li>40~60岁是一个人的黄金时期，身心两方面都是如此，应该因为到了这个充满智慧和领悟的年龄而心存感激。</li><li>忙碌的人无暇想到死亡。</li><li><code>不安定的心是无助的。 </code></li><li>要成功，必须有平和的心态。</li><li><code>你有能力控制自己的意志，也一定能掌握自己的命运。 </code></li><li><code>我们可以影响、指引并最终控制自己的环境，创造自己想要的人生。 </code></li><li>刻意与那些能从正面影响你、让你为自己思考和行动的人为伴。</li><li>意志控制是自律和习惯的结果。如果你不控制意志，那么它就会控制你。</li><li>寻找托词并以它来为失败辩护，这是所有的人都乐此不疲的习惯，编造托词是个根深蒂固的习惯。</li><li><code>生命就像一盘棋，你的对手就是时间。 </code></li><li>满足感属于那些征服自我，向生活索取回报的人，这种回报值得你为之努力。</li></ul><h4 id="精选"><a href="#精选" class="headerlink" title="精选"></a>精选</h4><ul><li>所有的成就，所有的财富，都有其意念的源泉。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、心想才能事成&quot;&gt;&lt;a href=&quot;#一、心想才能事成&quot; class=&quot;headerlink&quot; title=&quot;一、心想才能事成&quot;&gt;&lt;/a&gt;一、心想才能事成&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;如果一个人真想做一件事，那他一定会做成。&lt;/li&gt;
&lt;li&gt;成功人士，最伟大的成</summary>
      
    
    
    
    <category term="读书笔记" scheme="http://www.hxtec.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="励志" scheme="http://www.hxtec.top/tags/%E5%8A%B1%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>好好学习</title>
    <link href="http://www.hxtec.top/2022/09/17/%E5%A5%BD%E5%A5%BD%E5%AD%A6%E4%B9%A0/"/>
    <id>http://www.hxtec.top/2022/09/17/%E5%A5%BD%E5%A5%BD%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-09-17T10:07:34.000Z</published>
    <updated>2022-09-17T10:17:28.147Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、知识管理与认识优势"><a href="#一、知识管理与认识优势" class="headerlink" title="一、知识管理与认识优势"></a>一、知识管理与认识优势</h2><p>知识与知识是不一样的，有些知识比其他知识的威力更大，少数的知识能够给我们带来关键的影响，这就是临界知识。</p><h3 id="在海量信息即时获取时代，我们拼什么？"><a href="#在海量信息即时获取时代，我们拼什么？" class="headerlink" title="在海量信息即时获取时代，我们拼什么？"></a>在海量信息即时获取时代，我们拼什么？</h3><ul><li>一阶段，知识数量构建认识优势</li><li>二阶段，知识获取速度构建认知优势</li><li>三阶段，知识深度构建认知优势，认识的深度</li></ul><h3 id="如何提升认知深度？"><a href="#如何提升认知深度？" class="headerlink" title="如何提升认知深度？"></a>如何提升认知深度？</h3><h3 id="为什么大多数人的学习层次上不去？"><a href="#为什么大多数人的学习层次上不去？" class="headerlink" title="为什么大多数人的学习层次上不去？"></a>为什么大多数人的学习层次上不去？</h3><ul><li>重要的是：认识效率</li><li>对于大多数人而言，我们知道的，只是我们以为自己知道了</li><li>如果我们的学习是在了解问题本质，了解解决方案的底层规律，能够让我们认清楚问题表象背后的实质，那我们就是在提升认知效率。</li></ul><h3 id="到底哪些知识值得学？"><a href="#到底哪些知识值得学？" class="headerlink" title="到底哪些知识值得学？"></a>到底哪些知识值得学？</h3><ul><li>斜杠&#x3D;兼职？ 你更多的只是经历了一下而已，认知深度资并没有明显增加。</li><li>斜杠是结果，不是原因。斜杠是提升认知深度的结果，而不是追求多元的结果。</li><li>一开始就能带来直接利益和诱惑的事情，很可能要拿未来的机会作代价。</li><li>一个人，活成一支队伍。</li><li>无用之用，方为大用。</li><li>执行能力、专业能力和结构能力都应该学。</li></ul><h2 id="二、掌握临界知识的底层思维与方法"><a href="#二、掌握临界知识的底层思维与方法" class="headerlink" title="二、掌握临界知识的底层思维与方法"></a>二、掌握临界知识的底层思维与方法</h2><p>对于学习临界知识而言，首先要掌握的底层思维与方法，其次才是具体的知识和技能</p><h3 id="跳出“低水平勤奋陷阱”"><a href="#跳出“低水平勤奋陷阱”" class="headerlink" title="跳出“低水平勤奋陷阱”"></a>跳出“低水平勤奋陷阱”</h3><ul><li>读书，自然是最基本而又重要的方式。</li><li>在新旧知识间建立联系，理解和记忆一个个孤立的信息，可不是我们大脑擅长的高效行为。</li><li>用记忆宫殿法，花时间去加工这些信息。</li><li>读书一定要花时间、耐心和思考力，将获得的新知识和已有的知识进行网络状的联系。</li><li>生命有限，不要把有限的生命浪费在那些“低水平勤奋陷阱”里。</li></ul><h3 id="学习临界知识"><a href="#学习临界知识" class="headerlink" title="学习临界知识"></a>学习临界知识</h3><ul><li>绿灯思维</li><li>习惯性防卫的根源是惧怕暴露出我们想法背后的思维。</li><li>以慢为快</li><li>真正高效的学习，其实是知识融会贯通的结果。</li><li>读书的目的：打通知识的阻塞，实现融会贯通</li><li>知道、明白一个道理，和相信、践行一个道理是两码事。</li><li>真正阻碍我们的是我们的不确定和恐惧。</li><li>别说读书无用，是你不认真、没读好。</li></ul><h3 id="提升学习能力的三个底层方法"><a href="#提升学习能力的三个底层方法" class="headerlink" title="提升学习能力的三个底层方法"></a>提升学习能力的三个底层方法</h3><ul><li>学习临界知识的过程，本身就是深度思考的过程。</li><li>复盘我们每天的生活：复盘每一天的决策都是在什么样的假设下做出的，又产生了什么样的效果。</li><li>让自己安静，向内求。</li><li>加速改变理假设、发现新假设的过程，就是在提升我们的学习能力。</li><li>反思、以教为学和刻意练习。</li><li>反思的实质是对假设进行校正。<ul><li>做事的顺序：做出假设-&gt;采取行动-&gt;产生结果</li><li>反思的顺序：观察结果(现象)-&gt;研究原先假设-&gt;反思校正假设</li></ul></li><li>把生活的点滴细节管理好，就是在管理我们自己的人生。</li><li>我们读书就是读别人的生活经历和感悟，而最好的书，其实是我们自己的生活经历和感悟。</li><li>人之所以会改变，是因为他得到了反馈。（人的进步和行为的改变，往往源自反馈）</li><li>人与人之间的差距不是来自年龄，甚至不是来自经验，而是来自经验总结、反思和升华的能力。</li><li>如何与我们的负面情绪相处，以及如何积极地调动我们的正面情绪，使之发挥更大的作用。</li><li>所谓心理表征，是指我们的大脑在思考问题时对应的心理结构。</li><li>元认知，是对我们思考过程的思考。正是我们的思考过程，决定了我们思考的结果。</li><li>刻意练习，就是提升元认识能力的过程。差别表现为认知效率与认知深度。</li><li>元认知与临界知识，一个是思考过程，一个是思考工具。</li><li>刻意练习最关键的还不是掌握具体的临界知识，而是要改变我们的思考过程，有意识地应用更高级的心理表征解决问题，提升元认知能力。</li><li><code>持续、刻意地进行大量专注练习 </code>。</li></ul><h3 id="持续提升学习能力的三个技巧"><a href="#持续提升学习能力的三个技巧" class="headerlink" title="持续提升学习能力的三个技巧"></a>持续提升学习能力的三个技巧</h3><blockquote><p> 记录、定期回顾与付费购买。</p></blockquote><ul><li>记录是主动思考的过程，是挖掘看得见的事情背后看不见的关系。</li><li>记录的时间跨度越长，就越可能让自己看到更深层的规律。</li><li>如果看不到事情背后的长期规律，那么我们就只能对发生的事情本身做出反应，而无法顾及更长远的利益。</li><li>越是复杂的问题，越要用基本、简单的原则思考，比如正直、不撒谎、不贪婪、不给人添乱。</li><li>影响提升认知效率的因素有两个：<ul><li>学习内容的数量和质量，故想办法提升自己学习内容的质量并增加数量</li><li>用于学习的时间，故增加有效学习时间。</li></ul></li><li>越早让自己的认知升级，就越能享受其带来的复利效应。</li></ul><h2 id="三、发现和应用自己的临界知识"><a href="#三、发现和应用自己的临界知识" class="headerlink" title="三、发现和应用自己的临界知识"></a>三、发现和应用自己的临界知识</h2><p>在掌握了理念和方法的基础上，回到核心问题：如何找到临界知识？怎样能够把临界知识真正应用起来，实现知行合一？</p><h3 id="为什么临界知识能四两拨千斤？"><a href="#为什么临界知识能四两拨千斤？" class="headerlink" title="为什么临界知识能四两拨千斤？"></a>为什么临界知识能四两拨千斤？</h3><ul><li>很多时候，复杂的世界是由简单的基本规律决定的。</li><li>复杂系统不是简单的因果关系累加，而是各因素相互影响的动态系统。</li><li>用临界知识学习和思考是效率最高的。</li></ul><h3 id="如何发现自己的临界知识？"><a href="#如何发现自己的临界知识？" class="headerlink" title="如何发现自己的临界知识？"></a>如何发现自己的临界知识？</h3><ul><li>临界知识其实是对事物更底层规律的总结。</li><li>持续高强度练习是提升能力的必由之路。</li><li>只有构建提升心理表征，才能把练习从低水平重复提升到更高层次。</li><li>我们不是要找一个答案，而是要培养自己找出答案的能力。</li></ul><h3 id="天赋与学习临界知识的关系"><a href="#天赋与学习临界知识的关系" class="headerlink" title="天赋与学习临界知识的关系"></a>天赋与学习临界知识的关系</h3><ul><li>坚持努力这件事情，除了要有意志力外，更重要的应该是对这个成长过程从心底热爱和喜欢。</li><li>你的优势就是那些让你感到自己很强大的事。</li><li>方法和技巧永远只是工具：内心的热情和天赋，才是让生活创造精彩奇迹的剑刃。</li><li>真正重要的是：我们应当对这个世界充满好奇，有自己的热情和独立思考。</li></ul><h3 id="如何应用临界知识？"><a href="#如何应用临界知识？" class="headerlink" title="如何应用临界知识？"></a>如何应用临界知识？</h3><ul><li>刻意练习必须关注两点：1.抓住问题的本质进行训练；2.大量地持续练习。</li><li>认知能力提升的背后，偷不得一点懒。</li><li>我们能成为顶级选手并没有什么秘诀，而是对可能是基本技能的东西有更深刻的理解。</li><li>我们的决策是基于我们获得的信息质量。</li><li>穷人的思维带宽被眼前的危机占满了，他们没有多余的时间来考虑长远。</li><li>解释大致分为三个层次：现象解释，技术规律解释和通用规律解释。</li></ul><h3 id="用临界知识构建自己的“能力圈”"><a href="#用临界知识构建自己的“能力圈”" class="headerlink" title="用临界知识构建自己的“能力圈”"></a>用临界知识构建自己的“能力圈”</h3><ul><li>在能力圈中投资。</li><li>要配得上自己的欲望。 <code>你必须让自己配得上自己的欲望。 </code></li><li>不能界定边界的能力，称不上真正的能力。</li><li><code>重大的决策，请在你的能力圈内做出。 </code> 即使那是一个看起来很好的机会。</li><li>做狙击手，而非敢死队，因为我们80%的成功，是由20%的决定引发的。</li><li><code>你的本事是不是真的好，一个重要的标准是有没有人愿意为此埋单。 </code></li></ul><h2 id="四、案例：核心临界知识及其应用"><a href="#四、案例：核心临界知识及其应用" class="headerlink" title="四、案例：核心临界知识及其应用"></a>四、案例：核心临界知识及其应用</h2><p>每个人都应当有自己的框架来安排自己的临界知识，不过，确实有一些重要的临界知识是通用的。<br>《穷查理宝典》提及的几个临界知识：复利效应、概率论、黄金思维圈、进化论、系统思考、二八法则、安全空间。</p><h3 id="复利效应"><a href="#复利效应" class="headerlink" title="复利效应"></a>复利效应</h3><blockquote><p> 复利 - 世界第八大奇迹</p></blockquote><ul><li>被爱因斯坦称为世界第八大奇迹的，是“复利”。</li><li>复利的本质： <code>做事情A，会导致结果B，而结果B又会加强A，不断循环。 </code></li><li>数学就是一个思考工具，表达工具，而不是计算工具。</li><li>数学的本质是表达的艺术。</li><li>幂律分布，正太分布。</li><li>只有执行的次数足够多时，复利的效应才能发挥出来。</li><li>你所触碰的世界比你想象的更广阔。</li><li>运气只能左右黑天鹅事件的迟早，却不能左右它是否发生。</li><li>拓展人脉的关键： <code>首先是不断地提升自己的价值，让自己变得对他人有帮助，其次，才是让别人知道自己的价值。 </code></li><li><code>当你的收入扣除生活成本和自我成长之外，还有闲置资金的时候 </code>，这些钱，才是应该拿去理财投资的，这才是真正理解了复利模型。</li></ul><h3 id="概率论"><a href="#概率论" class="headerlink" title="概率论"></a>概率论</h3><ul><li>我们不能仅仅凭借结果来判断之前的决策是好的。</li><li>生活是一个各项条件随机发生的概率分布。</li><li>解读已经发生的事情，应对不确定的未来。</li><li>过去的每一件事情的结果，是众多可能的结果之一。</li><li>如果我们在大概率事件上持续投入，在概率事件发生的可能性会极大增加。</li><li>我们要有冗余备份、安全备份，防止小概率事件给我们造成无法挽回的损失。</li><li>极致努力可以改变获胜的概率，概率不是固定值，而是动态值。</li></ul><h3 id="黄金思维圈"><a href="#黄金思维圈" class="headerlink" title="黄金思维圈"></a>黄金思维圈</h3><ul><li>技术层面的事情有很多成熟的方法，给予时间训练就能提高；而思维方式的问题，因为涉及很多底层的假设和思维模式，如果没有一定的基础是难以改变的。</li><li>优秀的人，在思考问题时，不会被表象迷惑。</li><li>以始为终地去开展工作。</li></ul><blockquote><p> 工作话题，建议：</p></blockquote><ul><li><code>关注你接下来会和谁一起工作，做什么事情，能收获什么。 </code></li><li><code>创造各种机会参与多种问题的解决过程，寻找你喜欢并且敬佩的导师。 </code></li><li>新人尽快成长，职场老人，靠的是业绩能力和全局视野，让人相信新的可能性。</li><li><code>好工作真正的价值在于训练你的思维方式，开拓视野。 </code></li></ul><h3 id="进化论"><a href="#进化论" class="headerlink" title="进化论"></a>进化论</h3><ul><li>坐以待毙，是最危险的</li><li><code>位置比努力重要 </code></li><li>你在哪儿比你干什么更重要，因为你所处的位置拥有信息优势。</li><li>找到人脉中心，要么自己成为人脉中心，要么结识更多的人脉中心</li><li>说大道理，人人可以，可是践行的，就微乎其微。</li><li>破局知道的太多，却没有行动：<ol><li>祈祷自己拥有冒险的基因</li><li>精益创业，最小成本试错，最小成本，快速试错，快速改进</li><li>模仿领先者的行动， 模仿也是管理学上的对标，真正的模仿是理解“为什么”。</li></ol></li><li>所以， <code>重要的不是你知道多少，而是你能采取行动，改变多少。 </code> 知道和做到是两码事儿。</li></ul><h3 id="系统思考"><a href="#系统思考" class="headerlink" title="系统思考"></a>系统思考</h3><ul><li>群体是无法思考的。</li><li>当因和果在系统中有延迟之时，我们就很难看到背后的动作规律。</li><li>训练系统思考能力：<ol><li>关注“关系”而非“事物”</li><li>分析系统结构，也可以从历史情况入手</li><li>独立思考，快速试错，观察系统的结果</li><li>系统关键解有时在信息制高点</li></ol></li><li>及时反馈，对系统的行为有很大的影响， <code>有时候成功，不是因为努力，只是幸运地处在正确的位置。 </code></li></ul><h3 id="二八法则"><a href="#二八法则" class="headerlink" title="二八法则"></a>二八法则</h3><ul><li>人脉的三个价值：<ol><li>情感，提供情感慰藉</li><li>信息，提供信息情报</li><li>能力，分享资源能力</li></ol></li><li>结构洞，非重复关系</li><li><code>信息和财富一样，从来不会均匀地传播。 </code></li><li>真正的人脉，应该是促成连接，促成信息交流的。</li><li><code>信任，是构建能力交换的基础。 </code></li><li>能够成为好朋友，最核心的是价值观的认同。</li><li>真诚，永远是你赢得别人信任的好伙伴。</li><li>快速建立对方信任：<ol><li>自我暴露</li><li>做一个给予者，互惠原理，将欲取之，必先予之。</li></ol></li><li>等到未来的某一天，只注意到结果的人会对你说：当初你真是走了狗屎运了。你一笑就好。</li></ul><h3 id="安全空间"><a href="#安全空间" class="headerlink" title="安全空间"></a>安全空间</h3><ul><li>应该有一个可以保证自己生存的计划</li></ul><blockquote><p> 综合应用</p></blockquote><ul><li>术从简，道从心</li><li><code>只有能够改变你行动的信息才是知识。 </code></li><li><code>对于学习这件事情，自己是最好的老师。 </code></li><li>一切的学习和努力无非三个目标：一是解释问题，二是解决问题，三是预测问题。</li><li>真正的优势不是去追那些what，而是 <code>问自己why </code></li><li>不追热点，关注经典。</li><li>诚然， <code>任何一个问题都没有标准答案。 </code></li><li><code>深度的认知学习，永远要耐得住寂寞，下得去苦功夫。 </code></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、知识管理与认识优势&quot;&gt;&lt;a href=&quot;#一、知识管理与认识优势&quot; class=&quot;headerlink&quot; title=&quot;一、知识管理与认识优势&quot;&gt;&lt;/a&gt;一、知识管理与认识优势&lt;/h2&gt;&lt;p&gt;知识与知识是不一样的，有些知识比其他知识的威力更大，少数的知识能够给</summary>
      
    
    
    
    <category term="读书笔记" scheme="http://www.hxtec.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="励志" scheme="http://www.hxtec.top/tags/%E5%8A%B1%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Block - __block本质</title>
    <link href="http://www.hxtec.top/2022/09/17/Block-block%E6%9C%AC%E8%B4%A8/"/>
    <id>http://www.hxtec.top/2022/09/17/Block-block%E6%9C%AC%E8%B4%A8/</id>
    <published>2022-09-17T09:54:02.000Z</published>
    <updated>2022-09-18T10:40:50.836Z</updated>
    
    <content type="html"><![CDATA[<h2 id="block修饰符"><a href="#block修饰符" class="headerlink" title="__block修饰符"></a>__block修饰符</h2><ul><li>__block可以用于解决block内部无法修改auto变量值的问题</li><li>__block不能修饰全局变量、静态变量（static）</li><li>编译器会将__block变量包装成一个对象</li></ul><blockquote><p>示例1：__block修饰auto常量时</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">__block int age = 10;</span><br><span class="line">^&#123;</span><br><span class="line">    NSLog(@&quot;age is %d&quot;, age);</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line">//C++源码分析</span><br><span class="line">//block对象信息</span><br><span class="line">struct __block_impl &#123;</span><br><span class="line">    void *isa;</span><br><span class="line">    int Flags;</span><br><span class="line">    int Reserved;</span><br><span class="line">    void *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//block描述信息，大小，copy, dispose操作</span><br><span class="line">struct __main_block_desc_0 &#123;</span><br><span class="line">    size_t reserved;</span><br><span class="line">    size_t Block_size;</span><br><span class="line">    void (*copy)(void);</span><br><span class="line">    void (*dispose)(void);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//被包装成__Block_byref_age_0结构体</span><br><span class="line">struct __Block_byref_age_0 &#123;</span><br><span class="line">  void *__isa;</span><br><span class="line">__Block_byref_age_0 *__forwarding;</span><br><span class="line"> int __flags;</span><br><span class="line"> int __size;</span><br><span class="line"> int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//block结构体内容</span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  NSObject *p;</span><br><span class="line">  </span><br><span class="line">  //被包装成一个函数</span><br><span class="line">  __Block_byref_age_0 *age; // by ref</span><br><span class="line">  </span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, NSObject *_p, __Block_byref_age_0 *_age, int flags=0) : p(_p), age(_age-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>示例1：__block修饰对象时</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">//ARC环境下，编译器会对block进行copy操作。</span><br><span class="line">Person *person = [[Person alloc] init];</span><br><span class="line">Block block = ^&#123;</span><br><span class="line">    NSLog(@&quot;%p&quot;, person);</span><br><span class="line">&#125;;</span><br><span class="line">block();</span><br><span class="line">        </span><br><span class="line">//C++源码解析：</span><br><span class="line">struct __block_impl &#123;</span><br><span class="line">    void *isa;</span><br><span class="line">    int Flags;</span><br><span class="line">    int Reserved;</span><br><span class="line">    void *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct __main_block_desc_0 &#123;</span><br><span class="line">    size_t reserved;</span><br><span class="line">    size_t Block_size;</span><br><span class="line">    void (*copy)(void);</span><br><span class="line">    void (*dispose)(void);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct __Block_byref_weakPerson_0 &#123;</span><br><span class="line">  void *__isa; // 8</span><br><span class="line"> __Block_byref_weakPerson_0 *__forwarding; // 8</span><br><span class="line"> int __flags; // 4</span><br><span class="line"> int __size; // 4</span><br><span class="line"> </span><br><span class="line"> //内存管理相关</span><br><span class="line"> void (*__Block_byref_id_object_copy)(void*, void*); // 8</span><br><span class="line"> void (*__Block_byref_id_object_dispose)(void*); // 8</span><br><span class="line"> </span><br><span class="line"> Person *__weak weakPerson;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  </span><br><span class="line">  __Block_byref_weakPerson_0 *weakPerson; // by ref</span><br><span class="line">  </span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_weakPerson_0 *_weakPerson, int flags=0) : weakPerson(_weakPerson-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="block的内存管理"><a href="#block的内存管理" class="headerlink" title="__block的内存管理"></a>__block的内存管理</h2><ul><li>当block在栈上时，并不会对__block变量产生强引用</li><li>当block被copy到堆时<ul><li>会调用block内部的copy函数</li><li>copy函数内部会调用_Block_object_assign函数</li><li>_Block_object_assign函数会对__block变量形成强引用（retain）</li></ul></li><li>当block从堆中移除时<ul><li>会调用block内部的dispose函数</li><li>dispose函数内部会调用_Block_object_dispose函数</li><li>_Block_object_dispose函数会自动释放引用的__block变量（release）</li></ul></li></ul><h3 id="block的-forwarding指针"><a href="#block的-forwarding指针" class="headerlink" title="__block的__forwarding指针"></a>__block的__forwarding指针</h3><ul><li>在栈上的话，__forwarding指向自己</li><li>在堆上的话，__forwarding指向复制到堆上的的__block变量结构体的指针</li></ul><h3 id="对象类型的auto变量、-block变量"><a href="#对象类型的auto变量、-block变量" class="headerlink" title="对象类型的auto变量、__block变量"></a>对象类型的auto变量、__block变量</h3><ul><li>当block在栈上时，对它们都不会产生强引用</li><li>当block拷贝到堆上时，都会通过copy函数来处理它们<ul><li>__block变量（假设变量名叫做a）</li><li>_Block_object_assign((void*)&amp;dst-&gt;a, (void*)src-&gt;a, 8&#x2F;<em>BLOCK_FIELD_IS_BYREF</em>&#x2F;);</li></ul></li><li>对象类型的auto变量（假设变量名叫做p）<ul><li>_Block_object_assign((void*)&amp;dst-&gt;p, (void*)src-&gt;p, 3&#x2F;<em>BLOCK_FIELD_IS_OBJECT</em>&#x2F;);</li></ul></li><li>当block从堆上移除时，都会通过dispose函数来释放它们<ul><li>__block变量（假设变量名叫做a）</li><li>_Block_object_dispose((void*)src-&gt;a, 8&#x2F;<em>BLOCK_FIELD_IS_BYREF</em>&#x2F;);</li></ul></li><li>对象类型的auto变量（假设变量名叫做p）<ul><li>_Block_object_dispose((void*)src-&gt;p, 3&#x2F;<em>BLOCK_FIELD_IS_OBJECT</em>&#x2F;);</li></ul></li></ul><h3 id="被-block修饰的对象类型"><a href="#被-block修饰的对象类型" class="headerlink" title="被__block修饰的对象类型"></a>被__block修饰的对象类型</h3><ul><li>当__block变量在栈上时，不会对指向的对象产生强引用</li><li>当__block变量被copy到堆时<ul><li>会调用__block变量内部的copy函数</li><li>copy函数内部会调用_Block_object_assign函数</li><li>_Block_object_assign函数会根据所指向对象的修饰符（__strong、__weak、__unsafe_unretained）做出相应的操作，形成强引用（retain）或者弱引用（ <code>注意：这里仅限于ARC时会retain，MRC时不会retain </code>）</li></ul></li><li>如果__block变量从堆上移除<ul><li>会调用__block变量内部的dispose函数</li><li>dispose函数内部会调用_Block_object_dispose函数</li><li>_Block_object_dispose函数会自动释放指向的对象（release）</li></ul></li></ul><h3 id="循环引用问题"><a href="#循环引用问题" class="headerlink" title="循环引用问题"></a>循环引用问题</h3><h4 id="解决循环引用问题-ARC"><a href="#解决循环引用问题-ARC" class="headerlink" title="解决循环引用问题 - ARC"></a>解决循环引用问题 - ARC</h4><blockquote><p>用__weak、__unsafe_unretained解决</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//用__weak解决</span><br><span class="line">__weak typeof(self) weakSelf = self;</span><br><span class="line">self.block = ^&#123;</span><br><span class="line">    NSLog(@&quot;%p&quot;, weakSelf);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//用__unsafe_unretained解决</span><br><span class="line">__unsafe_unretained id weakSelf = self;</span><br><span class="line">self.block = ^&#123;</span><br><span class="line">    NSLog(@&quot;%p&quot;, weakSelf);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">注：</span><br><span class="line">// __weak：不会产生强引用，指向的对象销毁时，会自动让指针置为nil</span><br><span class="line">// __unsafe_unretained：不会产生强引用，不安全，指向的对象销毁时，指针存储的地址值不变</span><br></pre></td></tr></table></figure><blockquote><p>用__block解决（必须要调用block）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__block id weakSelf = self;</span><br><span class="line">self.block = ^&#123;</span><br><span class="line">    NSLog(@&quot;%p&quot;, weakSelf);</span><br><span class="line">    weakSelf = nil;</span><br><span class="line">&#125;;</span><br><span class="line">self.block()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;block修饰符&quot;&gt;&lt;a href=&quot;#block修饰符&quot; class=&quot;headerlink&quot; title=&quot;__block修饰符&quot;&gt;&lt;/a&gt;__block修饰符&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;__block可以用于解决block内部无法修改auto变量值的问题&lt;/</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Objective-C" scheme="http://www.hxtec.top/tags/Objective-C/"/>
    
    <category term="底层原理" scheme="http://www.hxtec.top/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    <category term="Category" scheme="http://www.hxtec.top/tags/Category/"/>
    
  </entry>
  
  <entry>
    <title>Block - 本质认识，变量捕获，类型</title>
    <link href="http://www.hxtec.top/2022/09/17/Block-%E6%9C%AC%E8%B4%A8%E8%AE%A4%E8%AF%86%EF%BC%8C%E5%8F%98%E9%87%8F%E6%8D%95%E8%8E%B7%EF%BC%8C%E7%B1%BB%E5%9E%8B/"/>
    <id>http://www.hxtec.top/2022/09/17/Block-%E6%9C%AC%E8%B4%A8%E8%AE%A4%E8%AF%86%EF%BC%8C%E5%8F%98%E9%87%8F%E6%8D%95%E8%8E%B7%EF%BC%8C%E7%B1%BB%E5%9E%8B/</id>
    <published>2022-09-17T09:45:57.000Z</published>
    <updated>2022-09-18T10:40:40.013Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本认识"><a href="#基本认识" class="headerlink" title="基本认识"></a>基本认识</h2><ul><li>block本质上也是一个OC对象，它内部也有个isa指针</li><li>block是封装了函数调用以及函数调用环境的OC对象</li><li>以下是一个block：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int age = 20;</span><br><span class="line">        </span><br><span class="line">void (^block)(int, int) =  ^(int a , int b)&#123;</span><br><span class="line">    NSLog(@&quot;this is a block! -- %d&quot;, age);</span><br><span class="line">&#125;;</span><br><span class="line">block()</span><br></pre></td></tr></table></figure></li></ul><h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_desc_0 &#123;</span><br><span class="line">    size_t reserved;</span><br><span class="line">    size_t Block_size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct __block_impl &#123;</span><br><span class="line">    void *isa;</span><br><span class="line">    int Flags;</span><br><span class="line">    int Reserved;</span><br><span class="line">    void *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">    struct __block_impl impl;</span><br><span class="line">    struct __main_block_desc_0* Desc;</span><br><span class="line">    int age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="block变量捕获"><a href="#block变量捕获" class="headerlink" title="block变量捕获"></a>block变量捕获</h3><ul><li>为了保证block内部能够正常访问外部的变量，block有个变量捕获机制<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">变量类型        捕获到block内部         访问方式</span><br><span class="line">局部变量          auto    √            值传递</span><br><span class="line">               static    √            指针传递</span><br><span class="line">全局变量                  ×            直接访问</span><br></pre></td></tr></table></figure></li></ul><h3 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h3><blockquote><p>auto和static局部变量捕获</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">void test &#123;</span><br><span class="line">    auto int a = 10;</span><br><span class="line">    static int b = 10;</span><br><span class="line">    block = ^&#123;</span><br><span class="line">        NSLog(@&quot;age is %d, height is %d&quot;, a, b);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//prama mark: - 编译后的源码</span><br><span class="line"></span><br><span class="line">struct __test_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __test_block_desc_0* Desc;</span><br><span class="line">  int a;//值传递</span><br><span class="line">  int *b;//指针传递</span><br><span class="line">  __test_block_impl_0(void *fp, struct __test_block_desc_0 *desc, int _a, int *_b, int flags=0) : a(_a), b(_b) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __test_block_func_0(struct __test_block_impl_0 *__cself) &#123;</span><br><span class="line">  int a = __cself-&gt;a; // bound by copy，值传递</span><br><span class="line">  int *b = __cself-&gt;b; // bound by copy 指针传递</span><br><span class="line"></span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_2r__m13fp2x2n9dvlr8d68yry500000gn_T_main_fd2a14_mi_0, a, (*b));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">static struct __test_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __test_block_desc_0_DATA = &#123; 0, sizeof(struct __test_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    auto int a = 10;</span><br><span class="line">    static int b = 10;</span><br><span class="line">    block = ((void (*)())&amp;__test_block_impl_0((void *)__test_block_func_0, &amp;__test_block_desc_0_DATA, a, &amp;b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="block类型"><a href="#block类型" class="headerlink" title="block类型"></a>block类型</h3><ul><li>block有3种类型，可以通过调用class方法或者isa指针查看具体类型，最终都是继承自NSBlock类型<ul><li><strong>NSGlobalBlock</strong> （ _NSConcreteGlobalBlock ）（数据区）</li><li><strong>NSStackBlock</strong> （ _NSConcreteStackBlock ）（栈区）</li><li><strong>NSMallocBlock</strong> （ _NSConcreteMallocBlock ）（堆区）</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// Global：没有访问auto变量</span><br><span class="line">void (^block1)(void) = ^&#123;</span><br><span class="line">    NSLog(@&quot;block1---------&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">// Stack：访问了auto变量</span><br><span class="line">int age = 10;</span><br><span class="line">void (^block2)(void) = ^&#123;</span><br><span class="line">    NSLog(@&quot;block2---------%d&quot;, age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// NSMallocBlock（MRC环境下）</span><br><span class="line">//对stack类型的block进行copy操作，就会变成malloc类型的block</span><br><span class="line">int age = 10;</span><br><span class="line">block = [^&#123;</span><br><span class="line">    NSLog(@&quot;block---------%d&quot;, age);</span><br><span class="line">&#125; copy];</span><br><span class="line">[block release];</span><br></pre></td></tr></table></figure><blockquote><p> block父类层级结构，如下：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// __NSGlobalBlock__ : __NSGlobalBlock : NSBlock : NSObject</span><br><span class="line">void (^block)(void) = ^&#123;</span><br><span class="line">    NSLog(@&quot;Hello&quot;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@&quot;, [block class]);</span><br><span class="line">NSLog(@&quot;%@&quot;, [[block class] superclass]);</span><br><span class="line">NSLog(@&quot;%@&quot;, [[[block class] superclass] superclass]);</span><br><span class="line">NSLog(@&quot;%@&quot;, [[[[block class] superclass] superclass] superclass]);</span><br></pre></td></tr></table></figure><h3 id="block的copy"><a href="#block的copy" class="headerlink" title="block的copy"></a>block的copy</h3><ul><li>在ARC环境下，编译器会根据情况自动将栈上的block复制到堆上，比如以下情况<ul><li>block作为函数返回值时</li><li>将block赋值给__strong指针时</li><li>block作为Cocoa API中方法名含有usingBlock的方法参数时</li><li>block作为GCD API的方法参数时</li></ul></li><li>MRC下block属性的建议写法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (copy, nonatomic) void (^block)(void);</span><br></pre></td></tr></table></figure></li><li>ARC下block属性的建议写法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@property (strong, nonatomic) void (^block)(void);</span><br><span class="line">@property (copy, nonatomic) void (^block)(void);</span><br></pre></td></tr></table></figure></li></ul><h3 id="对象类型的auto变量"><a href="#对象类型的auto变量" class="headerlink" title="对象类型的auto变量"></a>对象类型的auto变量</h3><ul><li>当block内部访问了对象类型的auto变量时，如果block是在栈上，将不会对auto变量产生强引用</li><li>如果block被拷贝到堆上，会调用block内部的copy函数<ul><li>copy函数内部会调用<code>_Block_object_assign</code>函数</li><li><code>_Block_object_assign</code>函数会根据auto变量的修饰符（__strong、__weak、__unsafe_unretained）做出相应的操作，形成强引用（retain）或者弱引用</li></ul></li><li>如果block从堆上移除，会调用block内部的dispose函数<ul><li>dispose函数内部会调用<code>_Block_object_dispose</code>函数</li><li><code>_Block_object_dispose</code>会自动释放引用的auto变量（release）</li></ul></li></ul><blockquote><p>代码解析：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">typedef void (^Block)(void);</span><br><span class="line">Block block;</span><br><span class="line">&#123;</span><br><span class="line">    Person *person = [[Person alloc] init];</span><br><span class="line">    person.age = 10;</span><br><span class="line"></span><br><span class="line">    //__weak Person *weakPerson = person;</span><br><span class="line">    block = ^&#123;</span><br><span class="line">        NSLog(@&quot;---------%d&quot;, person.age);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//编译后的源代码 </span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  MJPerson *__strong person;//由于没有使用weakPerson,所以这里是strong</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, MJPerson *__strong _person, int flags=0) : person(_person) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  MJPerson *__strong person = __cself-&gt;person; // bound by copy</span><br><span class="line"></span><br><span class="line">                NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_2r__m13fp2x2n9dvlr8d68yry500000gn_T_main_c41e64_mi_0, ((int (*)(id, SEL))(void *)objc_msgSend)((id)person, sel_registerName(&quot;age&quot;)));</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;</span><br><span class="line">    _Block_object_assign((void*)&amp;dst-&gt;person,//对block进行一个引用计数的操作，外界是strong，retain就引用计数加1，外界是weak就是一个弱引用。</span><br><span class="line">    (void*)src-&gt;person, 3/*BLOCK_FIELD_IS_OBJECT*/);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;person, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class="line"></span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);// 将栈上的bock，复制到椎上</span><br><span class="line">  void (*dispose)(struct __main_block_impl_0*);//堆上的block被废弃时，进行dispose操作</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="weak问题解决"><a href="#weak问题解决" class="headerlink" title="__weak问题解决"></a>__weak问题解决</h3><ul><li>ARC环境下，默认对block进行一个copy操作</li><li>在使用clang转换OC为C++代码时，可能会遇到以下问题<ul><li>cannot create __weak reference in file using manual reference</li></ul></li><li>解决方案：支持ARC、指定运行时系统版本，比如<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基本认识&quot;&gt;&lt;a href=&quot;#基本认识&quot; class=&quot;headerlink&quot; title=&quot;基本认识&quot;&gt;&lt;/a&gt;基本认识&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;block本质上也是一个OC对象，它内部也有个isa指针&lt;/li&gt;
&lt;li&gt;block是封装了函数调用以及函数调</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Objective-C" scheme="http://www.hxtec.top/tags/Objective-C/"/>
    
    <category term="底层原理" scheme="http://www.hxtec.top/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    <category term="Block" scheme="http://www.hxtec.top/tags/Block/"/>
    
  </entry>
  
  <entry>
    <title>Category - 关联对象</title>
    <link href="http://www.hxtec.top/2022/09/17/Category-%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/"/>
    <id>http://www.hxtec.top/2022/09/17/Category-%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/</id>
    <published>2022-09-17T09:40:41.000Z</published>
    <updated>2022-09-18T10:41:00.703Z</updated>
    
    <content type="html"><![CDATA[<h4 id="关联对象"><a href="#关联对象" class="headerlink" title="关联对象"></a>关联对象</h4><ul><li>默认情况下，因为分类底层结构的限制，不能添加&#x3D;&#x3D;成员变量&#x3D;&#x3D;到分类中,但可以通过&#x3D;&#x3D;关联对象&#x3D;&#x3D;来间接实现</li><li>关联对象提供了以下API：<ul><li>添加关联对象<ul><li>void objc_setAssociatedObject(id object, const void * key,<br>                  id value, objc_AssociationPolicy policy)</li></ul></li><li>获得关联对象<ul><li>id objc_getAssociatedObject(id object, const void * key)</li></ul></li><li>移除所有的关联对象<ul><li>void objc_removeAssociatedObjects(id object)</li></ul></li></ul></li></ul><h4 id="key的常见用法"><a href="#key的常见用法" class="headerlink" title="key的常见用法"></a>key的常见用法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static void *MyKey = &amp;MyKey;</span><br><span class="line">objc_setAssociatedObject(obj, MyKey, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><br><span class="line">objc_getAssociatedObject(obj, MyKey)</span><br><span class="line"></span><br><span class="line">static char MyKey;</span><br><span class="line">objc_setAssociatedObject(obj, &amp;MyKey, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><br><span class="line">objc_getAssociatedObject(obj, &amp;MyKey)</span><br><span class="line"></span><br><span class="line">使用属性名作为key</span><br><span class="line">objc_setAssociatedObject(obj, @&quot;property&quot;, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">objc_getAssociatedObject(obj, @&quot;property&quot;);</span><br><span class="line"></span><br><span class="line">使用get方法的@selecor作为key</span><br><span class="line">objc_setAssociatedObject(obj, @selector(getter), value, OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><br><span class="line">objc_getAssociatedObject(obj, @selector(getter))</span><br></pre></td></tr></table></figure><ul><li>objc_AssociationPolicy，关联策略<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">objc_AssociationPolicy                    对应的修饰符</span><br><span class="line">OBJC_ASSOCIATION_ASSIGN                        assign</span><br><span class="line">OBJC_ASSOCIATION_RETAIN_NONATOMIC       strong, nonatomic</span><br><span class="line">OBJC_ASSOCIATION_COPY_NONATOMIC         copy, nonatomic</span><br><span class="line">OBJC_ASSOCIATION_RETAIN                    strong, atomic</span><br><span class="line">OBJC_ASSOCIATION_COPY                    copy, atomic</span><br></pre></td></tr></table></figure></li></ul><h4 id="关联对象的原理"><a href="#关联对象的原理" class="headerlink" title="关联对象的原理"></a>关联对象的原理</h4><ul><li>实现关联对象技术的核心对象有<ul><li>AssociationsManager</li><li>AssociationsHashMap</li><li>ObjectAssociationMap</li><li>ObjcAssociation</li></ul></li></ul><h5 id="objc4源码：objc-references-mm"><a href="#objc4源码：objc-references-mm" class="headerlink" title="objc4源码：objc-references.mm"></a>objc4源码：objc-references.mm</h5><blockquote><p>AssociationsManager</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class AssociationsManager &#123;</span><br><span class="line">    // associative references: object pointer -&gt; PtrPtrHashMap.</span><br><span class="line">    static AssociationsHashMap *_map;</span><br><span class="line">public:</span><br><span class="line">    AssociationsManager()   &#123; AssociationsManagerLock.lock(); &#125;</span><br><span class="line">    ~AssociationsManager()  &#123; AssociationsManagerLock.unlock(); &#125;</span><br><span class="line">    </span><br><span class="line">    // </span><br><span class="line">    AssociationsHashMap &amp;associations() &#123;</span><br><span class="line">        if (_map == NULL)</span><br><span class="line">            _map = new AssociationsHashMap();</span><br><span class="line">        return *_map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>AssociationsHashMap</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class AssociationsHashMap : public unordered_map&lt;disguised_ptr_t, ObjectAssociationMap *, DisguisedPointerHash, DisguisedPointerEqual, AssociationsHashMapAllocator&gt; &#123;</span><br><span class="line">public:</span><br><span class="line">    void *operator new(size_t n) &#123; return ::malloc(n); &#125;</span><br><span class="line">    void operator delete(void *ptr) &#123; ::free(ptr); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>ObjectAssociationMap</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class ObjectAssociationMap : public std::map&lt;void *, ObjcAssociation, ObjectPointerLess, ObjectAssociationMapAllocator&gt; &#123;</span><br><span class="line">public:</span><br><span class="line">    void *operator new(size_t n) &#123; return ::malloc(n); &#125;</span><br><span class="line">    void operator delete(void *ptr) &#123; ::free(ptr); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>ObjcAssociation</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class ObjcAssociation &#123;</span><br><span class="line">    </span><br><span class="line">    uintptr_t _policy;</span><br><span class="line">    id _value;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    ObjcAssociation(uintptr_t policy, id value) : _policy(policy), _value(value) &#123;&#125;</span><br><span class="line">    ObjcAssociation() : _policy(0), _value(nil) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    uintptr_t policy() const &#123; return _policy; &#125;</span><br><span class="line">    id value() const &#123; return _value; &#125;</span><br><span class="line">    </span><br><span class="line">    bool hasValue() &#123; return _value != nil; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><strong>notes:</strong></p></blockquote><ul><li>关联对象并不是存储在被关联对象本身内存中</li><li>关联对象存储在全局的统一的一个AssociationsManager中</li><li>设置关联对象为nil，就相当于是移除关联对象</li><li>即为以下的关系：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">AssociationsManager</span><br><span class="line">AssociationsHashMap *_map;</span><br><span class="line"></span><br><span class="line">AssociationsHashMap</span><br><span class="line">disguised_ptr_t    ObjectAssociationMap</span><br><span class="line">disguised_ptr_t    ObjectAssociationMap</span><br><span class="line">...    ...</span><br><span class="line"></span><br><span class="line">AssociationsMap</span><br><span class="line">void *    ObjectAssociation</span><br><span class="line">void *    ObjectAssociation</span><br><span class="line">...    ...</span><br><span class="line"></span><br><span class="line">ObjectAssociation</span><br><span class="line">uintptr_t _policy;</span><br><span class="line">id _value;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;关联对象&quot;&gt;&lt;a href=&quot;#关联对象&quot; class=&quot;headerlink&quot; title=&quot;关联对象&quot;&gt;&lt;/a&gt;关联对象&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;默认情况下，因为分类底层结构的限制，不能添加&amp;#x3D;&amp;#x3D;成员变量&amp;#x3D;&amp;#x3D;到分类中,但</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Objective-C" scheme="http://www.hxtec.top/tags/Objective-C/"/>
    
    <category term="底层原理" scheme="http://www.hxtec.top/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    <category term="Category" scheme="http://www.hxtec.top/tags/Category/"/>
    
  </entry>
  
  <entry>
    <title>Category - initialize</title>
    <link href="http://www.hxtec.top/2022/09/17/Category-initialize/"/>
    <id>http://www.hxtec.top/2022/09/17/Category-initialize/</id>
    <published>2022-09-17T09:38:43.000Z</published>
    <updated>2022-09-18T10:41:04.059Z</updated>
    
    <content type="html"><![CDATA[<h2 id="initialized"><a href="#initialized" class="headerlink" title="initialized"></a>initialized</h2><ul><li>+initialized方法会在类第一次接收到消息时调用 </li><li>调用顺序<ul><li>先调用父类的+initialize，再调用子类的+initialize</li><li>先初始化父类，再初始化子类，每个类只会初始化1次</li></ul></li><li>+initialize和+load的很大区别是，+initialize是通过objc_msgSend进行调用的，所以有以下特点<ul><li>如果子类没有实现+initialize，会调用父类的+initialize（所以父类的+initialize可能会被调用多次）</li><li>如果分类实现了+initialize，就覆盖类本身的+initialize调用</li></ul></li></ul><h4 id="objc4源码解读"><a href="#objc4源码解读" class="headerlink" title="objc4源码解读"></a>objc4源码解读</h4><blockquote><ul><li>objc-msg-arm64.s，汇编级别的源码<ul><li>objc_msgSend，消息发送汇编源码</li></ul></li><li>objc-runtime-new.mm<ul><li>class_getInstanceMethod</li><li>lookUpImpOrNil</li><li>lookUpImpOrForward</li><li>_class_initialize</li><li>callInitialize</li><li>objc_msgSend(cls, SEL_initialize)</li></ul></li></ul></blockquote><h4 id="源码分析，objc-runtime-new-mm文件"><a href="#源码分析，objc-runtime-new-mm文件" class="headerlink" title="源码分析，objc-runtime-new.mm文件"></a>源码分析，objc-runtime-new.mm文件</h4><blockquote><p>class_getInstanceMethod</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/***********************************************************************</span><br><span class="line">* class_getInstanceMethod.  Return the instance method for the</span><br><span class="line">* specified class and selector.</span><br><span class="line">**********************************************************************/</span><br><span class="line">Method class_getInstanceMethod(Class cls, SEL sel)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cls  ||  !sel) return nil;</span><br><span class="line"></span><br><span class="line">    // This deliberately avoids +initialize because it historically did so.</span><br><span class="line"></span><br><span class="line">    // This implementation is a bit weird because it&#x27;s the only place that </span><br><span class="line">    // wants a Method instead of an IMP.</span><br><span class="line"></span><br><span class="line">#warning fixme build and search caches</span><br><span class="line">        </span><br><span class="line">    // Search method lists, try method resolver, etc.</span><br><span class="line">    // 查找方法</span><br><span class="line">    lookUpImpOrNil(cls, sel, nil, </span><br><span class="line">                   NO/*initialize*/, NO/*cache*/, YES/*resolver*/);</span><br><span class="line"></span><br><span class="line">#warning fixme build and search caches</span><br><span class="line"></span><br><span class="line">    return _class_getMethod(cls, sel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>lookUpImpOrNil</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">* lookUpImpOrNil.</span><br><span class="line">* Like lookUpImpOrForward, but returns nil instead of _objc_msgForward_impcache</span><br><span class="line">**********************************************************************/</span><br><span class="line">IMP lookUpImpOrNil(Class cls, SEL sel, id inst, </span><br><span class="line">                   bool initialize, bool cache, bool resolver)</span><br><span class="line">&#123;</span><br><span class="line">    IMP imp = lookUpImpOrForward(cls, sel, inst, initialize, cache, resolver);</span><br><span class="line">    if (imp == _objc_msgForward_impcache) return nil;</span><br><span class="line">    else return imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>lookUpImpOrForward</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">IMP lookUpImpOrForward(Class cls, SEL sel, id inst, </span><br><span class="line">                       bool initialize, bool cache, bool resolver)</span><br><span class="line">&#123;</span><br><span class="line">    IMP imp = nil;</span><br><span class="line">    bool triedResolver = NO;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line"></span><br><span class="line">    // 省去代码...   </span><br><span class="line"></span><br><span class="line">    // 判断是否初始化过类，没有就进行初始化</span><br><span class="line">    if (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</span><br><span class="line">        runtimeLock.unlockRead();</span><br><span class="line">        </span><br><span class="line">        // 初始化操作</span><br><span class="line">        _class_initialize (_class_getNonMetaClass(cls, inst));</span><br><span class="line">        </span><br><span class="line">        runtimeLock.read();</span><br><span class="line">        // If sel == initialize, _class_initialize will send +initialize and </span><br><span class="line">        // then the messenger will send +initialize again after this </span><br><span class="line">        // procedure finishes. Of course, if this is not being called </span><br><span class="line">        // from the messenger then it won&#x27;t happen. 2778172</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>_class_initialize</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">* class_initialize.  Send the &#x27;+initialize&#x27; message on demand to any</span><br><span class="line">* uninitialized class. Force initialization of superclasses first.</span><br><span class="line">**********************************************************************/</span><br><span class="line">void _class_initialize(Class cls)</span><br><span class="line">&#123;    </span><br><span class="line">    // 省去代码...   </span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            // 调用自己的初始化方法</span><br><span class="line">            callInitialize(cls);</span><br><span class="line"></span><br><span class="line">            if (PrintInitializing) &#123;</span><br><span class="line">                _objc_inform(&quot;INITIALIZE: thread %p: finished +[%s initialize]&quot;,</span><br><span class="line">                             pthread_self(), cls-&gt;nameForLogging());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    // 省去代码...   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>callInitialize</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void callInitialize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    // 消息发送机制</span><br><span class="line">    ((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);</span><br><span class="line">    asm(&quot;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高频面试"><a href="#高频面试" class="headerlink" title="高频面试"></a>高频面试</h2><ul><li><p>Category中有load方法吗？load方法是什么时候调用的？load 方法能继承吗？</p><ul><li>有load方法</li><li>load方法在runtime加载类、分类的时候调用</li><li>load方法可以继承，但是一般情况下不会主动去调用load方法，都是让系统自动调用</li></ul></li><li><p>load、initialize方法的区别什么？它们在category中的调用的顺序？以及出现继承时他们之间的调用过程？</p><ul><li>分别在两个笔记里面顶部体现</li></ul></li><li><p>Category能否添加成员变量？如果可以，如何给Category添加成员变量？</p><ul><li>不能直接给Category添加成员变量，但是可以间接实现Category有成员变量的效果</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;initialized&quot;&gt;&lt;a href=&quot;#initialized&quot; class=&quot;headerlink&quot; title=&quot;initialized&quot;&gt;&lt;/a&gt;initialized&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;+initialized方法会在类第一次接收到消息时调用</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Objective-C" scheme="http://www.hxtec.top/tags/Objective-C/"/>
    
    <category term="底层原理" scheme="http://www.hxtec.top/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    <category term="Category" scheme="http://www.hxtec.top/tags/Category/"/>
    
  </entry>
  
  <entry>
    <title>Category - load</title>
    <link href="http://www.hxtec.top/2022/09/17/Category-load/"/>
    <id>http://www.hxtec.top/2022/09/17/Category-load/</id>
    <published>2022-09-17T09:35:26.000Z</published>
    <updated>2022-09-18T10:41:06.959Z</updated>
    
    <content type="html"><![CDATA[<h2 id="load"><a href="#load" class="headerlink" title="+load"></a>+load</h2><ul><li>+load方法会在runtime加载类、分类时调用</li><li>每个类、分类的+load，在程序运行过程中只调用一次</li><li>调用顺序<ol><li>先调用类的+load<ul><li>按照编译先后顺序调用（先编译，先调用）</li><li>调用子类+load之前会先调用父类的+load</li></ul></li><li>再调用分类的+load<ul><li>按照编译先后顺序调用（先编译，先调用）</li></ul></li></ol></li></ul><h4 id="objc4源码解读：objc-os-mm"><a href="#objc4源码解读：objc-os-mm" class="headerlink" title="objc4源码解读：objc-os.mm"></a>objc4源码解读：objc-os.mm</h4><blockquote><ul><li>_objc_init</li><li>load_images</li><li>prepare_load_methods<ul><li>schedule_class_load</li><li>add_class_to_loadable_list</li><li>add_category_to_loadable_list</li></ul></li><li>call_load_methods<ul><li>call_class_loads</li><li>call_category_loads</li></ul></li></ul></blockquote><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><blockquote><p> _objc_init</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">* _objc_init</span><br><span class="line">* Bootstrap initialization. Registers our image notifier with dyld.</span><br><span class="line">* Called by libSystem BEFORE library initialization time</span><br><span class="line">**********************************************************************/</span><br><span class="line"></span><br><span class="line">void _objc_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    static bool initialized = false;</span><br><span class="line">    if (initialized) return;</span><br><span class="line">    initialized = true;</span><br><span class="line">    </span><br><span class="line">    // fixme defer initialization until an objc-using image is found?</span><br><span class="line">    environ_init();</span><br><span class="line">    tls_init();</span><br><span class="line">    static_init();</span><br><span class="line">    lock_init();</span><br><span class="line">    exception_init();</span><br><span class="line"></span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>load_images，在objc-runtime-new.mm文件中</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">* load_images</span><br><span class="line">* Process +load in the given images which are being mapped in by dyld.</span><br><span class="line">*</span><br><span class="line">* Locking: write-locks runtimeLock and loadMethodLock</span><br><span class="line">**********************************************************************/</span><br><span class="line">extern bool hasLoadMethods(const headerType *mhdr);</span><br><span class="line">extern void prepare_load_methods(const headerType *mhdr);</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">load_images(const char *path __unused, const struct mach_header *mh)</span><br><span class="line">&#123;</span><br><span class="line">    // Return without taking locks if there are no +load methods here.</span><br><span class="line">    if (!hasLoadMethods((const headerType *)mh)) return;</span><br><span class="line"></span><br><span class="line">    recursive_mutex_locker_t lock(loadMethodLock);</span><br><span class="line"></span><br><span class="line">    // Discover load methods</span><br><span class="line">    &#123;</span><br><span class="line">        rwlock_writer_t lock2(runtimeLock);</span><br><span class="line">        </span><br><span class="line">        //准备加载方法</span><br><span class="line">        prepare_load_methods((const headerType *)mh);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Call +load methods (without runtimeLock - re-entrant)</span><br><span class="line">    // 加载方法</span><br><span class="line">    call_load_methods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>prepare_load_methods</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void prepare_load_methods(const headerType *mhdr)</span><br><span class="line">&#123;</span><br><span class="line">    size_t count, i;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line"></span><br><span class="line">    classref_t *classlist = </span><br><span class="line">        _getObjc2NonlazyClassList(mhdr, &amp;count);</span><br><span class="line">    for (i = 0; i &lt; count; i++) &#123;</span><br><span class="line">    </span><br><span class="line">        // 安排/预定类方法</span><br><span class="line">        schedule_class_load(remapClass(classlist[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    category_t **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);</span><br><span class="line">    for (i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        category_t *cat = categorylist[i];</span><br><span class="line">        Class cls = remapClass(cat-&gt;cls);</span><br><span class="line">        if (!cls) continue;  // category for ignored weak-linked class</span><br><span class="line">        realizeClass(cls);</span><br><span class="line">        assert(cls-&gt;ISA()-&gt;isRealized());</span><br><span class="line">        </span><br><span class="line">        // 添加分类到加载列表中</span><br><span class="line">        add_category_to_loadable_list(cat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>schedule_class_load</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">* prepare_load_methods</span><br><span class="line">* Schedule +load for classes in this image, any un-+load-ed </span><br><span class="line">* superclasses in other images, and any categories in this image.</span><br><span class="line">**********************************************************************/</span><br><span class="line">// Recursively schedule +load for cls and any un-+load-ed superclasses.</span><br><span class="line">// cls must already be connected.</span><br><span class="line">static void schedule_class_load(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cls) return;</span><br><span class="line">    assert(cls-&gt;isRealized());  // _read_images should realize</span><br><span class="line"></span><br><span class="line">    if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return;</span><br><span class="line"></span><br><span class="line">    // Ensure superclass-first ordering</span><br><span class="line">    schedule_class_load(cls-&gt;superclass);</span><br><span class="line"></span><br><span class="line">    // 添加类到加载列表中</span><br><span class="line">    add_class_to_loadable_list(cls);</span><br><span class="line">    cls-&gt;setInfo(RW_LOADED); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>add_class_to_loadable_list</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">* add_class_to_loadable_list</span><br><span class="line">* Class cls has just become connected. Schedule it for +load if</span><br><span class="line">* it implements a +load method.</span><br><span class="line">**********************************************************************/</span><br><span class="line">void add_class_to_loadable_list(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    IMP method;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    method = cls-&gt;getLoadMethod();</span><br><span class="line">    if (!method) return;  // Don&#x27;t bother if cls has no +load method</span><br><span class="line">    </span><br><span class="line">    if (PrintLoading) &#123;</span><br><span class="line">        _objc_inform(&quot;LOAD: class &#x27;%s&#x27; scheduled for +load&quot;, </span><br><span class="line">                     cls-&gt;nameForLogging());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (loadable_classes_used == loadable_classes_allocated) &#123;</span><br><span class="line">        loadable_classes_allocated = loadable_classes_allocated*2 + 16;</span><br><span class="line">        loadable_classes = (struct loadable_class *)</span><br><span class="line">            realloc(loadable_classes,</span><br><span class="line">                              loadable_classes_allocated *</span><br><span class="line">                              sizeof(struct loadable_class));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    loadable_classes[loadable_classes_used].cls = cls;</span><br><span class="line">    loadable_classes[loadable_classes_used].method = method;</span><br><span class="line">    loadable_classes_used++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>add_category_to_loadable_list</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">* add_category_to_loadable_list</span><br><span class="line">* Category cat&#x27;s parent class exists and the category has been attached</span><br><span class="line">* to its class. Schedule this category for +load after its parent class</span><br><span class="line">* becomes connected and has its own +load method called.</span><br><span class="line">**********************************************************************/</span><br><span class="line">void add_category_to_loadable_list(Category cat)</span><br><span class="line">&#123;</span><br><span class="line">    IMP method;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    method = _category_getLoadMethod(cat);</span><br><span class="line"></span><br><span class="line">    // Don&#x27;t bother if cat has no +load method</span><br><span class="line">    if (!method) return;</span><br><span class="line"></span><br><span class="line">    if (PrintLoading) &#123;</span><br><span class="line">        _objc_inform(&quot;LOAD: category &#x27;%s(%s)&#x27; scheduled for +load&quot;, </span><br><span class="line">                     _category_getClassName(cat), _category_getName(cat));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (loadable_categories_used == loadable_categories_allocated) &#123;</span><br><span class="line">        loadable_categories_allocated = loadable_categories_allocated*2 + 16;</span><br><span class="line">        loadable_categories = (struct loadable_category *)</span><br><span class="line">            realloc(loadable_categories,</span><br><span class="line">                              loadable_categories_allocated *</span><br><span class="line">                              sizeof(struct loadable_category));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    loadable_categories[loadable_categories_used].cat = cat;</span><br><span class="line">    loadable_categories[loadable_categories_used].method = method;</span><br><span class="line">    loadable_categories_used++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>call_load_methods</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">void call_load_methods(void)</span><br><span class="line">&#123;</span><br><span class="line">    static bool loading = NO;</span><br><span class="line">    bool more_categories;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    // Re-entrant calls do nothing; the outermost call will finish the job.</span><br><span class="line">    if (loading) return;</span><br><span class="line">    loading = YES;</span><br><span class="line"></span><br><span class="line">    void *pool = objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line">        // 1. Repeatedly call class +loads until there aren&#x27;t any more</span><br><span class="line">        while (loadable_classes_used &gt; 0) &#123;</span><br><span class="line">        </span><br><span class="line">            //调用类load方法</span><br><span class="line">            call_class_loads();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 2. Call category +loads ONCE</span><br><span class="line"></span><br><span class="line">        // 调用分类的load方法</span><br><span class="line">        more_categories = call_category_loads();</span><br><span class="line"></span><br><span class="line">        // 3. Run more +loads if there are classes OR more untried categories</span><br><span class="line">    &#125; while (loadable_classes_used &gt; 0  ||  more_categories);</span><br><span class="line"></span><br><span class="line">    objc_autoreleasePoolPop(pool);</span><br><span class="line"></span><br><span class="line">    loading = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>call_class_loads</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">* call_class_loads</span><br><span class="line">* Call all pending class +load methods.</span><br><span class="line">* If new classes become loadable, +load is NOT called for them.</span><br><span class="line">*</span><br><span class="line">* Called only by call_load_methods().</span><br><span class="line">**********************************************************************/</span><br><span class="line">static void call_class_loads(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    </span><br><span class="line">    // Detach current loadable list.</span><br><span class="line">    struct loadable_class *classes = loadable_classes;</span><br><span class="line">    int used = loadable_classes_used;</span><br><span class="line">    loadable_classes = nil;</span><br><span class="line">    loadable_classes_allocated = 0;</span><br><span class="line">    loadable_classes_used = 0;</span><br><span class="line">    </span><br><span class="line">    // Call all +loads for the detached list.</span><br><span class="line">    for (i = 0; i &lt; used; i++) &#123;</span><br><span class="line">        Class cls = classes[i].cls;</span><br><span class="line">        load_method_t load_method = (load_method_t)classes[i].method;</span><br><span class="line">        if (!cls) continue; </span><br><span class="line"></span><br><span class="line">        if (PrintLoading) &#123;</span><br><span class="line">            _objc_inform(&quot;LOAD: +[%s load]\n&quot;, cls-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line">        (*load_method)(cls, SEL_load);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Destroy the detached list.</span><br><span class="line">    if (classes) free(classes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>call_category_loads</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">* call_category_loads</span><br><span class="line">* Call some pending category +load methods.</span><br><span class="line">* The parent class of the +load-implementing categories has all of </span><br><span class="line">*   its categories attached, in case some are lazily waiting for +initalize.</span><br><span class="line">* Don&#x27;t call +load unless the parent class is connected.</span><br><span class="line">* If new categories become loadable, +load is NOT called, and they </span><br><span class="line">*   are added to the end of the loadable list, and we return TRUE.</span><br><span class="line">* Return FALSE if no new categories became loadable.</span><br><span class="line">*</span><br><span class="line">* Called only by call_load_methods().</span><br><span class="line">**********************************************************************/</span><br><span class="line">static bool call_category_loads(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i, shift;</span><br><span class="line">    bool new_categories_added = NO;</span><br><span class="line">    </span><br><span class="line">    // Detach current loadable list.</span><br><span class="line">    struct loadable_category *cats = loadable_categories;</span><br><span class="line">    int used = loadable_categories_used;</span><br><span class="line">    int allocated = loadable_categories_allocated;</span><br><span class="line">    loadable_categories = nil;</span><br><span class="line">    loadable_categories_allocated = 0;</span><br><span class="line">    loadable_categories_used = 0;</span><br><span class="line"></span><br><span class="line">    // Call all +loads for the detached list.</span><br><span class="line">    for (i = 0; i &lt; used; i++) &#123;</span><br><span class="line">        Category cat = cats[i].cat;</span><br><span class="line">        load_method_t load_method = (load_method_t)cats[i].method;</span><br><span class="line">        Class cls;</span><br><span class="line">        if (!cat) continue;</span><br><span class="line"></span><br><span class="line">        cls = _category_getClass(cat);</span><br><span class="line">        if (cls  &amp;&amp;  cls-&gt;isLoadable()) &#123;</span><br><span class="line">            if (PrintLoading) &#123;</span><br><span class="line">                _objc_inform(&quot;LOAD: +[%s(%s) load]\n&quot;, </span><br><span class="line">                             cls-&gt;nameForLogging(), </span><br><span class="line">                             _category_getName(cat));</span><br><span class="line">            &#125;</span><br><span class="line">            (*load_method)(cls, SEL_load);</span><br><span class="line">            cats[i].cat = nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Compact detached list (order-preserving)</span><br><span class="line">    shift = 0;</span><br><span class="line">    for (i = 0; i &lt; used; i++) &#123;</span><br><span class="line">        if (cats[i].cat) &#123;</span><br><span class="line">            cats[i-shift] = cats[i];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            shift++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    used -= shift;</span><br><span class="line"></span><br><span class="line">    // Copy any new +load candidates from the new list to the detached list.</span><br><span class="line">    new_categories_added = (loadable_categories_used &gt; 0);</span><br><span class="line">    for (i = 0; i &lt; loadable_categories_used; i++) &#123;</span><br><span class="line">        if (used == allocated) &#123;</span><br><span class="line">            allocated = allocated*2 + 16;</span><br><span class="line">            cats = (struct loadable_category *)</span><br><span class="line">                realloc(cats, allocated *</span><br><span class="line">                                  sizeof(struct loadable_category));</span><br><span class="line">        &#125;</span><br><span class="line">        cats[used++] = loadable_categories[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Destroy the new list.</span><br><span class="line">    if (loadable_categories) free(loadable_categories);</span><br><span class="line"></span><br><span class="line">    // Reattach the (now augmented) detached list. </span><br><span class="line">    // But if there&#x27;s nothing left to load, destroy the list.</span><br><span class="line">    if (used) &#123;</span><br><span class="line">        loadable_categories = cats;</span><br><span class="line">        loadable_categories_used = used;</span><br><span class="line">        loadable_categories_allocated = allocated;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (cats) free(cats);</span><br><span class="line">        loadable_categories = nil;</span><br><span class="line">        loadable_categories_used = 0;</span><br><span class="line">        loadable_categories_allocated = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (PrintLoading) &#123;</span><br><span class="line">        if (loadable_categories_used != 0) &#123;</span><br><span class="line">            _objc_inform(&quot;LOAD: %d categories still waiting for +load\n&quot;,</span><br><span class="line">                         loadable_categories_used);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return new_categories_added;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>note：<br>+load方法是根据方法地址直接调用，并不是经过objc_msgSend函数调用</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;load&quot;&gt;&lt;a href=&quot;#load&quot; class=&quot;headerlink&quot; title=&quot;+load&quot;&gt;&lt;/a&gt;+load&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;+load方法会在runtime加载类、分类时调用&lt;/li&gt;
&lt;li&gt;每个类、分类的+load，在程序运行过</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Objective-C" scheme="http://www.hxtec.top/tags/Objective-C/"/>
    
    <category term="底层原理" scheme="http://www.hxtec.top/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    <category term="Category" scheme="http://www.hxtec.top/tags/Category/"/>
    
  </entry>
  
  <entry>
    <title>Category - 底层结构</title>
    <link href="http://www.hxtec.top/2022/09/17/Category-%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84/"/>
    <id>http://www.hxtec.top/2022/09/17/Category-%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84/</id>
    <published>2022-09-17T09:31:45.000Z</published>
    <updated>2022-09-18T10:40:57.307Z</updated>
    
    <content type="html"><![CDATA[<h2 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct _category_t &#123;</span><br><span class="line">    const char *name;</span><br><span class="line">    struct _class_t *cls;</span><br><span class="line">    const struct _method_list_t *instance_methods;</span><br><span class="line">    const struct _method_list_t *class_methods;</span><br><span class="line">    const struct _protocol_list_t *protocols;</span><br><span class="line">    const struct _prop_list_t *properties;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="加载处理过程"><a href="#加载处理过程" class="headerlink" title="加载处理过程"></a>加载处理过程</h2><ul><li>通过Runtime某个类的所有Category数据</li><li>把所有Category的方法，属性，协议数据，合并到一个在数组中<ul><li>后面参与编译的Category数据，会在数组的前面</li></ul></li><li>将合并后的分类数据（方法，属性，协议），插入到类原来数据的前面</li><li>源码解读顺序<ul><li>objc-os.mm<ul><li>_objc_init</li><li>map_images</li><li>map_images_nolock</li></ul></li><li>objc-runtim-new.mm<ul><li>_read_images</li><li>remethodizeClass</li><li>attachCategories</li><li>attachLists<ul><li>realloc, memmove, memcpy</li></ul></li></ul></li></ul></li></ul><h3 id="部分源码分析"><a href="#部分源码分析" class="headerlink" title="部分源码分析"></a>部分源码分析</h3><h4 id="objc-os-mm文件"><a href="#objc-os-mm文件" class="headerlink" title="objc-os.mm文件"></a>objc-os.mm文件</h4><blockquote><p> _objc_init</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">***********************************************************************</span><br><span class="line">* _objc_init</span><br><span class="line">* Bootstrap initialization. Registers our image notifier with dyld.</span><br><span class="line">* Called by libSystem BEFORE library initialization time</span><br><span class="line">**********************************************************************/</span><br><span class="line"></span><br><span class="line">void _objc_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    static bool initialized = false;</span><br><span class="line">    if (initialized) return;</span><br><span class="line">    initialized = true;</span><br><span class="line">    </span><br><span class="line">    // fixme defer initialization until an objc-using image is found?</span><br><span class="line">    environ_init();</span><br><span class="line">    tls_init();</span><br><span class="line">    static_init();</span><br><span class="line">    lock_init();</span><br><span class="line">    exception_init();</span><br><span class="line"></span><br><span class="line">    // map_images</span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>map_images_nolock</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">* map_images_nolock</span><br><span class="line">* Process the given images which are being mapped in by dyld.</span><br><span class="line">* All class registration and fixups are performed (or deferred pending</span><br><span class="line">* discovery of missing superclasses etc), and +load methods are called.</span><br><span class="line">*</span><br><span class="line">* info[] is in bottom-up order i.e. libobjc will be earlier in the </span><br><span class="line">* array than any library that links to libobjc.</span><br><span class="line">*</span><br><span class="line">* Locking: loadMethodLock(old) or runtimeLock(new) acquired by map_images.</span><br><span class="line">**********************************************************************/</span><br><span class="line">#if __OBJC2__</span><br><span class="line">#include &quot;objc-file.h&quot;</span><br><span class="line">#else</span><br><span class="line">#include &quot;objc-file-old.h&quot;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">void </span><br><span class="line">map_images_nolock(unsigned mhCount, const char * const mhPaths[],</span><br><span class="line">                  const struct mach_header * const mhdrs[])</span><br><span class="line">&#123;</span><br><span class="line">// 省去其他代码...</span><br><span class="line"></span><br><span class="line">    if (hCount &gt; 0) &#123;</span><br><span class="line">    </span><br><span class="line">        //_read_images</span><br><span class="line">        _read_images(hList, hCount, totalClasses, unoptimizedTotalClasses);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 省去其他代码...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="objc-runtime-new-mm文件"><a href="#objc-runtime-new-mm文件" class="headerlink" title="objc-runtime-new.mm文件"></a>objc-runtime-new.mm文件</h4><blockquote><p>_read_images</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">* _read_images</span><br><span class="line">* Perform initial processing of the headers in the linked </span><br><span class="line">* list beginning with headerList. </span><br><span class="line">*</span><br><span class="line">* Called by: map_images_nolock</span><br><span class="line">*</span><br><span class="line">* Locking: runtimeLock acquired by map_images</span><br><span class="line">**********************************************************************/</span><br><span class="line">void _read_images(header_info **hList, uint32_t hCount, int totalClasses, int unoptimizedTotalClasses)</span><br><span class="line">&#123;</span><br><span class="line">// 省去其他代码...</span><br><span class="line"></span><br><span class="line">    // Process this category. </span><br><span class="line">    // First, register the category with its target class. </span><br><span class="line">    // Then, rebuild the class&#x27;s method lists (etc) if </span><br><span class="line">    // the class is realized. </span><br><span class="line">    bool classExists = NO;</span><br><span class="line">    if (cat-&gt;instanceMethods ||  cat-&gt;protocols  </span><br><span class="line">        ||  cat-&gt;instanceProperties) </span><br><span class="line">    &#123;</span><br><span class="line">        addUnattachedCategoryForClass(cat, cls, hi);</span><br><span class="line">        if (cls-&gt;isRealized()) &#123;</span><br><span class="line">        </span><br><span class="line">            //重新组织类的方法</span><br><span class="line">            remethodizeClass(cls);</span><br><span class="line">            classExists = YES;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        if (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(&quot;CLASS: found category -%s(%s) %s&quot;, </span><br><span class="line">                         cls-&gt;nameForLogging(), cat-&gt;name, </span><br><span class="line">                         classExists ? &quot;on existing class&quot; : &quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (cat-&gt;classMethods  ||  cat-&gt;protocols  </span><br><span class="line">        ||  (hasClassProperties &amp;&amp; cat-&gt;_classProperties)) </span><br><span class="line">    &#123;</span><br><span class="line">        addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi);</span><br><span class="line">        if (cls-&gt;ISA()-&gt;isRealized()) &#123;</span><br><span class="line">        </span><br><span class="line">            //重新组织类的方法</span><br><span class="line">            remethodizeClass(cls-&gt;ISA());</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        if (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(&quot;CLASS: found category +%s(%s)&quot;, </span><br><span class="line">                         cls-&gt;nameForLogging(), cat-&gt;name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">// 省去其他代码...</span><br></pre></td></tr></table></figure><blockquote><p>remethodizeClass</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">* remethodizeClass</span><br><span class="line">* Attach outstanding categories to an existing class.</span><br><span class="line">* Fixes up cls&#x27;s method list, protocol list, and property list.</span><br><span class="line">* Updates method caches for cls and its subclasses.</span><br><span class="line">* Locking: runtimeLock must be held by the caller</span><br><span class="line">**********************************************************************/</span><br><span class="line">static void remethodizeClass(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    category_list *cats;</span><br><span class="line">    bool isMeta;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line"></span><br><span class="line">    isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    // Re-methodizing: check for more categories</span><br><span class="line">    if ((cats = unattachedCategoriesForClass(cls, false/*not realizing*/))) &#123;</span><br><span class="line">        if (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(&quot;CLASS: attaching categories to class &#x27;%s&#x27; %s&quot;, </span><br><span class="line">                         cls-&gt;nameForLogging(), isMeta ? &quot;(meta)&quot; : &quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // </span><br><span class="line">        attachCategories(cls, cats, true /*flush caches*/);        </span><br><span class="line">        free(cats);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>attachCategories</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">attachCategories(Class cls, category_list *cats, bool flush_caches)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cats) return;</span><br><span class="line">    if (PrintReplacedMethods) printReplacements(cls, cats);</span><br><span class="line"></span><br><span class="line">    bool isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    // fixme rearrange to remove these intermediate allocations</span><br><span class="line">    // 方法数组，二维数组</span><br><span class="line">    /*</span><br><span class="line">    [</span><br><span class="line">        [method_t, method_t],</span><br><span class="line">        [method_t, method_t]</span><br><span class="line">    ]</span><br><span class="line">     */</span><br><span class="line">    method_list_t **mlists = (method_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*mlists));</span><br><span class="line">    // 属性数组</span><br><span class="line">    property_list_t **proplists = (property_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*proplists));</span><br><span class="line">    // 协议数组</span><br><span class="line">    protocol_list_t **protolists = (protocol_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*protolists));</span><br><span class="line"></span><br><span class="line">    // Count backwards through cats to get newest categories first</span><br><span class="line">    int mcount = 0;</span><br><span class="line">    int propcount = 0;</span><br><span class="line">    int protocount = 0;</span><br><span class="line">    int i = cats-&gt;count;</span><br><span class="line">    bool fromBundle = NO;</span><br><span class="line">    while (i--) &#123;</span><br><span class="line">        //取出某个分类</span><br><span class="line">        auto&amp; entry = cats-&gt;list[i];</span><br><span class="line"></span><br><span class="line">        // 取出分类中的对象/类方法</span><br><span class="line">        method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);</span><br><span class="line">        if (mlist) &#123;</span><br><span class="line">            mlists[mcount++] = mlist;</span><br><span class="line">            fromBundle |= entry.hi-&gt;isBundle();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        property_list_t *proplist = </span><br><span class="line">            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</span><br><span class="line">        if (proplist) &#123;</span><br><span class="line">            proplists[propcount++] = proplist;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protocol_list_t *protolist = entry.cat-&gt;protocols;</span><br><span class="line">        if (protolist) &#123;</span><br><span class="line">            protolists[protocount++] = protolist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    auto rw = cls-&gt;data();</span><br><span class="line"></span><br><span class="line">    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</span><br><span class="line">    // 将所有分类的对象/类方法，附加到类对象的方法列表中</span><br><span class="line">    rw-&gt;methods.attachLists(mlists, mcount);</span><br><span class="line">    free(mlists);</span><br><span class="line">    if (flush_caches  &amp;&amp;  mcount &gt; 0) flushCaches(cls);</span><br><span class="line">    </span><br><span class="line">    // 将所有分类的属性，附加到类对象的属性列表中</span><br><span class="line">    rw-&gt;properties.attachLists(proplists, propcount);</span><br><span class="line">    free(proplists);</span><br><span class="line">    </span><br><span class="line">    // 将所有分类的协议，附加到类对象的协议列表中</span><br><span class="line">    rw-&gt;protocols.attachLists(protolists, protocount);</span><br><span class="line">    free(protolists);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="objc-runtime-new-h"><a href="#objc-runtime-new-h" class="headerlink" title="objc-runtime-new.h"></a>objc-runtime-new.h</h4><blockquote><p>attachLists</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">void attachLists(List* const * addedLists, uint32_t addedCount) &#123;</span><br><span class="line">    if (addedCount == 0) return;</span><br><span class="line"></span><br><span class="line">    if (hasArray()) &#123;</span><br><span class="line">        // many lists -&gt; many lists</span><br><span class="line">        uint32_t oldCount = array()-&gt;count;</span><br><span class="line">        uint32_t newCount = oldCount + addedCount;</span><br><span class="line">        setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));</span><br><span class="line">        array()-&gt;count = newCount;</span><br><span class="line">        </span><br><span class="line">        //先进行内存挪动，array()-&gt;lists，原来的方法列表</span><br><span class="line">        memmove(array()-&gt;lists + addedCount, </span><br><span class="line">                         array()-&gt;lists, </span><br><span class="line">                         oldCount * sizeof(array()-&gt;lists[0]));</span><br><span class="line">        </span><br><span class="line">        //再进行，copy操作到挪动后腾出的位置，addedLists,原有分类的方法列表</span><br><span class="line">        memcpy(array()-&gt;lists, </span><br><span class="line">                        addedLists, </span><br><span class="line">                        addedCount * sizeof(array()-&gt;lists[0]));</span><br><span class="line">    &#125;</span><br><span class="line">    else if (!list  &amp;&amp;  addedCount == 1) &#123;</span><br><span class="line">        // 0 lists -&gt; 1 list</span><br><span class="line">        list = addedLists[0];</span><br><span class="line">    &#125; </span><br><span class="line">    else &#123;</span><br><span class="line">        // 1 list -&gt; many lists</span><br><span class="line">        List* oldList = list;</span><br><span class="line">        uint32_t oldCount = oldList ? 1 : 0;</span><br><span class="line">        uint32_t newCount = oldCount + addedCount;</span><br><span class="line">        setArray((array_t *)malloc(array_t::byteSize(newCount)));</span><br><span class="line">        array()-&gt;count = newCount;</span><br><span class="line">        if (oldList) array()-&gt;lists[addedCount] = oldList;</span><br><span class="line">        memcpy(array()-&gt;lists, addedLists, </span><br><span class="line">               addedCount * sizeof(array()-&gt;lists[0]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高频试题"><a href="#高频试题" class="headerlink" title="高频试题"></a>高频试题</h2><ul><li>Category的使用场景？<ul><li>为原有类添加对象方法和类方法</li><li>拆分模块，将原来一个大的模块，拆分成多个小模块，方便维护和管理</li><li>添加关联对象</li></ul></li><li>Cateory的实现原理<ul><li>Category编译之后的底层结构是 struct category_t，里面存储着分类 的对象方法，属性，协议信息</li><li>在程序运行的时候，runtime会将Category的数据，合并到类信息中（类对象，元类对象）</li></ul></li><li>Cateogyr和Class Extension的区别是什么？<ul><li>Class Extension在编译的时候，它的数据就已经包含在类信息中</li><li>Category是在运行时，才会将数据合并到类信息中</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;底层结构&quot;&gt;&lt;a href=&quot;#底层结构&quot; class=&quot;headerlink&quot; title=&quot;底层结构&quot;&gt;&lt;/a&gt;底层结构&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Objective-C" scheme="http://www.hxtec.top/tags/Objective-C/"/>
    
    <category term="底层原理" scheme="http://www.hxtec.top/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>KVO &amp; KVC</title>
    <link href="http://www.hxtec.top/2022/09/17/KVO-KVC/"/>
    <id>http://www.hxtec.top/2022/09/17/KVO-KVC/</id>
    <published>2022-09-17T09:29:35.000Z</published>
    <updated>2022-09-18T10:41:09.876Z</updated>
    
    <content type="html"><![CDATA[<h2 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h2><ul><li><p>KVO的全称是Key-Value Observing，俗称“键值监听”，可以用于监听某个对象属性值的改变</p></li><li><p>添加KVO方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">self.person = [[Person alloc] init];</span><br><span class="line"></span><br><span class="line">// 给person对象添加KVO监听</span><br><span class="line">NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;</span><br><span class="line">[self.person addObserver:self forKeyPath:@&quot;age&quot; options:options context:@&quot;123&quot;];</span><br><span class="line"></span><br><span class="line">// observeValueForKeyPath:ofObject:change:context:</span><br><span class="line">// 当监听对象的属性值发生改变时，就会调用</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;监听到%@的%@属性值改变了 - %@ - %@&quot;, object, keyPath, change, context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//移除监听</span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    [self.person1 removeObserver:self forKeyPath:@&quot;age&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>获取类的所有方法</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (void)printMethodNamesOfClass:(Class)cls</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int count;</span><br><span class="line">    // 获得方法数组</span><br><span class="line">    Method *methodList = class_copyMethodList(cls, &amp;count);</span><br><span class="line">    </span><br><span class="line">    // 存储方法名</span><br><span class="line">    NSMutableString *methodNames = [NSMutableString string];</span><br><span class="line">    </span><br><span class="line">    // 遍历所有的方法</span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        // 获得方法</span><br><span class="line">        Method method = methodList[i];</span><br><span class="line">        // 获得方法名</span><br><span class="line">        NSString *methodName = NSStringFromSelector(method_getName(method));</span><br><span class="line">        // 拼接方法名</span><br><span class="line">        [methodNames appendString:methodName];</span><br><span class="line">        [methodNames appendString:@&quot;, &quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 释放</span><br><span class="line">    free(methodList);</span><br><span class="line">    </span><br><span class="line">    // 打印方法名</span><br><span class="line">    NSLog(@&quot;%@ %@&quot;, cls, methodNames);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用</span><br><span class="line">[self printMethodNamesOfClass:object_getClass(self.person)];</span><br><span class="line"></span><br><span class="line">//打印结果，即为中间派生类的方法</span><br><span class="line">NSKVONotifying_Person setAge:, class, dealloc, _isKVOA,</span><br></pre></td></tr></table></figure><h2 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h2><ul><li>KVC的全称是Key-Value Coding，俗称“键值编码”，可以通过一个key来访问某个属性</li><li>常见的API有<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)setValue:(id)value forKeyPath:(NSString *)keyPath;</span><br><span class="line">- (void)setValue:(id)value forKey:(NSString *)key;</span><br><span class="line"></span><br><span class="line">- (id)valueForKeyPath:(NSString *)keyPath;</span><br><span class="line">- (id)valueForKey:(NSString *)key; </span><br></pre></td></tr></table></figure><blockquote><p>示例：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@interface Cat : NSObject</span><br><span class="line">@property (assign, nonatomic) int weight;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface Person : NSObject</span><br><span class="line">@property (assign, nonatomic) int age;</span><br><span class="line"></span><br><span class="line">@property (assign, nonatomic) Cat *cat;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">Person *person = [[Person alloc] init];</span><br><span class="line">// 进行赋值</span><br><span class="line">//[person setValue:[NSNumber numberWithInt:10] forKey:@&quot;age&quot;];</span><br><span class="line">[person setValue:@10 forKey:@&quot;age&quot;];</span><br><span class="line"></span><br><span class="line">//通过keyPath，进行赋值</span><br><span class="line">person.cat = [[Cat alloc] init];</span><br><span class="line">[person setValue:@10 forKeyPath:@&quot;cat.weight&quot;];</span><br></pre></td></tr></table></figure></li></ul><h3 id="setValue-forKey-的原理"><a href="#setValue-forKey-的原理" class="headerlink" title="setValue:forKey:的原理"></a>setValue:forKey:的原理</h3><blockquote><ul><li>setValue:forKey: </li><li>按照setKey: _setKey: 顺序查找方法</li><li>找到方法 -&gt; 传递参数，调用方法</li><li>没有找到方法 -&gt; 查看 &#x3D;&#x3D;accessInstanceVariablesDirectly&#x3D;&#x3D; 方法的返回值</li><li>返回 YES -&gt; 按照 _key、_isKey、key、isKey 顺序查找&#x3D;&#x3D;成员变量&#x3D;&#x3D;，直接赋值，如果还是没有找到，走下一步</li><li>返回NO -&gt; 调用 &#x3D;&#x3D;setValue:forUndefinedKey:&#x3D;&#x3D; 并抛出异常NSUnknownKeyException</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">&#123;</span><br><span class="line">    @public</span><br><span class="line">// 按钮 _key、_isKey、key、isKey 顺序查找</span><br><span class="line">//    int _age;</span><br><span class="line">//    int _isAge;</span><br><span class="line">//    int age;</span><br><span class="line">//    int isAge;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MJPerson</span><br><span class="line">//先找setAge方法，进行赋值</span><br><span class="line">//- (void)setAge:(int)age</span><br><span class="line">//&#123;</span><br><span class="line">//    NSLog(@&quot;setAge: - %d&quot;, age);</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">//再找_setAge方法，进行赋值</span><br><span class="line">//- (void)_setAge:(int)age</span><br><span class="line">//&#123;</span><br><span class="line">//    NSLog(@&quot;_setAge: - %d&quot;, age);</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">// 默认的返回值就是YES</span><br><span class="line">//+ (BOOL)accessInstanceVariablesDirectly</span><br><span class="line">//&#123;</span><br><span class="line">//    return YES;//默认的返回值就是YES</span><br><span class="line">//    return NO;//抛出异常NSUnknownKeyException, setValue:forUndefinedKey:</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="valueForKey-的原理"><a href="#valueForKey-的原理" class="headerlink" title="valueForKey:的原理"></a>valueForKey:的原理</h3><blockquote><ul><li>valueForKey:</li><li>按照 getKey、key、 isKey、_key 顺序查找方</li><li>找到方法 -&gt; 调用方法，返回值</li><li>没有找到方法 -&gt; 查看 &#x3D;&#x3D;accessInstanceVariablesDirectly&#x3D;&#x3D; 方法的返回值</li><li>返回 YES -&gt; 按照 _key、_isKey、key、isKey 顺序查找成员变量，直接赋值，如果还是没有找到成员变量，走下一步</li><li>返回NO -&gt; 调用 调用 &#x3D;&#x3D;valueForUndefinedKey:&#x3D;&#x3D; 并抛出异常NSUnknownKeyException</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">&#123;</span><br><span class="line">    @public</span><br><span class="line">// 按照 _key、_isKey、key、isKey 顺序查找</span><br><span class="line">//    int _age;</span><br><span class="line">//    int _isAge;</span><br><span class="line">//    int age;</span><br><span class="line">//    int isAge;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MJPerson</span><br><span class="line">//- (int)getAge</span><br><span class="line">//&#123;</span><br><span class="line">//    return 11;</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">//- (int)age</span><br><span class="line">//&#123;</span><br><span class="line">//    return 12;</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">//- (int)isAge</span><br><span class="line">//&#123;</span><br><span class="line">//    return 13;</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">//- (int)_age</span><br><span class="line">//&#123;</span><br><span class="line">//    return 14;</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">// 默认的返回值就是YES</span><br><span class="line">//+ (BOOL)accessInstanceVariablesDirectly</span><br><span class="line">//&#123;</span><br><span class="line">//    return YES;//默认的返回值就是YES</span><br><span class="line">//    return NO;//抛出异常NSUnknownKeyException, setValue:forUndefinedKey:</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><blockquote><p>通过KVC修改属性是否会触发KVO？</p><ul><li>会触发KVO</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Observer *observer = [[Observer alloc] init];</span><br><span class="line">Person *person = [[Person alloc] init];</span><br><span class="line"></span><br><span class="line">// 添加KVO监听</span><br><span class="line">[person addObserver:observer forKeyPath:@&quot;age&quot; options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:NULL];</span><br><span class="line"></span><br><span class="line">// 通过KVC修改age属性</span><br><span class="line">[person setValue:@10 forKey:@&quot;age&quot;];</span><br><span class="line"></span><br><span class="line">// 也可手动触发KVO</span><br><span class="line">// [person willChangeValueForKey:@&quot;age&quot;];</span><br><span class="line">// person-&gt;_age = 10;</span><br><span class="line">// [person didChangeValueForKey:@&quot;age&quot;];</span><br><span class="line"></span><br><span class="line">// 移除KVO监听</span><br><span class="line">[person removeObserver:observer forKeyPath:@&quot;age&quot;];</span><br></pre></td></tr></table></figure><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><ul><li>利用RuntimeAPI动态生成一个子类，并且让instance对象的isa指向这个全新的子类</li><li>当修改instance对象的属性时，会调用Foundation的_NSSetXXXValueAndNotify函数<ul><li>willChangeValueForKey:</li><li>父类原来的setter</li><li>didChangeValueForKey:<ul><li>内部会触发监听器（Oberser）的监听方法( observeValueForKeyPath:ofObject:change:context:）</li></ul></li></ul></li></ul><h4 id="手动触发KVO"><a href="#手动触发KVO" class="headerlink" title="手动触发KVO"></a>手动触发KVO</h4><ul><li>手动调用willChangeValueForKey:和didChangeValueForKey:</li></ul><h4 id="直接修改成员变量会触发KVO么？"><a href="#直接修改成员变量会触发KVO么？" class="headerlink" title="直接修改成员变量会触发KVO么？"></a>直接修改成员变量会触发KVO么？</h4><ul><li>不会触发KVO</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;KVO&quot;&gt;&lt;a href=&quot;#KVO&quot; class=&quot;headerlink&quot; title=&quot;KVO&quot;&gt;&lt;/a&gt;KVO&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;KVO的全称是Key-Value Observing，俗称“键值监听”，可以用于监听某个对象属性值的改变&lt;/p&gt;
</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Objective-C" scheme="http://www.hxtec.top/tags/Objective-C/"/>
    
    <category term="底层原理" scheme="http://www.hxtec.top/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>OC语法</title>
    <link href="http://www.hxtec.top/2022/09/17/OC%E8%AF%AD%E6%B3%95/"/>
    <id>http://www.hxtec.top/2022/09/17/OC%E8%AF%AD%E6%B3%95/</id>
    <published>2022-09-17T08:58:57.000Z</published>
    <updated>2022-09-18T10:41:19.868Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Objective-c语法"><a href="#Objective-c语法" class="headerlink" title="Objective-c语法"></a>Objective-c语法</h2><h3 id="Objective-C的本质"><a href="#Objective-C的本质" class="headerlink" title="Objective-C的本质"></a>Objective-C的本质</h3><ul><li>平时编写的OC代码，底层实现其实都是C&#x2F;C++代码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Objective-C -&gt; C/C++ -&gt; 汇编语言 -&gt; 机器语言</span><br></pre></td></tr></table></figure><ul><li>OC的面向对象都是基于C&#x2F;C++的数据结构实现的，即 <strong>结构体</strong></li></ul><h3 id="NSObject的底层实现"><a href="#NSObject的底层实现" class="headerlink" title="NSObject的底层实现"></a>NSObject的底层实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@interface NSObject &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">底层结构体形式：</span><br><span class="line">struct NSObject_IMPL &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>创建一个实例对象，至少需要多少内存？</p><ul><li>至少需要8个字节<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line">class_getInstanceSize([NSObjcet class]);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>创建一个实例对象，实际上分配了多少内存？</p><ul><li>实际分配了16个字节   </li><li>底层是Buckets size, 16, 32, 48, 64…. 都是16的位数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line">malloc_size((__bridge const void *)obj)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="OC对象的分类"><a href="#OC对象的分类" class="headerlink" title="OC对象的分类"></a>OC对象的分类</h3><ul><li><p>instance对象（实例对象）</p><ul><li>alloc出来的对象，在内存中存储的信息包括：<ol><li>isa指针</li><li>其他成员变量</li></ol></li></ul></li><li><p>class对象（类对象）</p><ul><li>每个类在内存中有且只有一个class对象</li><li>class对象在内存中存储的信息主要包括：<ol><li>isa指针</li><li>superClass指针</li><li>类的属性信息(property)、类的对象方法信息(instance method)</li><li>类的协议信息(protocol)、类的成员变量信息(ivar)</li><li>……</li></ol></li></ul></li><li><p>meta-class对象（元类对象）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class objectMetaClass = objc_getClass([NSObject class]);//Runtime API</span><br></pre></td></tr></table></figure><blockquote><p>小结：</p><ul><li>objectMetaClass是NSObject的meta-class对象(元类对象)</li><li>每个类在内存中只有一个meta-class对象</li><li>meta-class对象和class对象的内存结构是一样的，但是用途不一样<br>主要包括：<br>    1. isa指针<br>    2. superclass指针<br>    3. 类的方法信息(class method)<br>    4. ……</li></ul></blockquote></li><li><p>查看Class是否为meta-class，方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bool result = class_isMetaClass([NSObjce class]);</span><br></pre></td></tr></table></figure></li></ul><h3 id="isa指针"><a href="#isa指针" class="headerlink" title="isa指针"></a>isa指针</h3><p><img src="http://rfshxohrg.hn-bkt.clouddn.com/WX20220730-105146.png" alt="image"></p><ul><li>instance的 <code>isa </code>指向class<ul><li>当调用 <code>对象方法 </code>时，通过instance的 <code>isa </code>找到class，最后找到 <code>对象方法 </code>的实现进行调用</li></ul></li><li>class的 <code>isa </code>指向meta-class<ul><li>当调用 <code>类方法 </code>时，通过class的 <code>isa </code>找到meta-class，最后找到 <code>类方法 </code>的实现进行调用<br><img src="http://rfshxohrg.hn-bkt.clouddn.com/WX20220730-112038.png" alt="image"></li></ul></li></ul><p>** <code>note: </code>** 从64位开始，isa需要进行一次位运算，才能计算出真实地址</p><h3 id="class对象的superclass指针"><a href="#class对象的superclass指针" class="headerlink" title="class对象的superclass指针"></a>class对象的superclass指针</h3><p><img src="http://rfshxohrg.hn-bkt.clouddn.com/WX20220730-110416.png" alt="image"></p><p>** <code>note: </code>** 当student的instance对象要调用Person的对象方法时，会先通过 <code>isa </code>找到Student的class，然后通过 <code>superclass </code>找到Person的class，最后找到对象方法的实现进行调用</p><h3 id="meta-class对象的superclass指针"><a href="#meta-class对象的superclass指针" class="headerlink" title="meta-class对象的superclass指针"></a>meta-class对象的superclass指针</h3><p><img src="http://rfshxohrg.hn-bkt.clouddn.com/WX20220730-111359.png" alt="image"></p><p>** <code>note: </code>** 当Student的class要调用Person的类方法时，会先通过 <code>isa </code>找到Student的meta-class，然后通过 <code>superclass </code>找到Person的meta-class，最后找到类方法的实现进行调用</p><h2 id="isa、superclass总结"><a href="#isa、superclass总结" class="headerlink" title="isa、superclass总结"></a>isa、superclass总结</h2><p><img src="http://rfshxohrg.hn-bkt.clouddn.com/%E5%9B%BE%E7%89%871.png" alt="image"></p><blockquote><ol><li>instance的isa指向class</li><li>class的isa指向meta-class</li><li>meta-class的isa指向基类的meta-class</li><li>class的superclass指向父类的class<br>如果没有父类，superclass指针为nil</li><li>meta-class的superclass指向父类的meta-class<br>基类的meta-class的superclass指向基类的class</li><li>instance调用对象方法的轨迹<br>isa找到class，方法不存在，就通过superclass找父类</li><li>class调用类方法的轨迹<br>isa找meta-class，方法不存在，就通过superclass找父类</li></ol></blockquote><h2 id="64位isa指针"><a href="#64位isa指针" class="headerlink" title="64位isa指针"></a>64位isa指针</h2><ul><li>从64bit开始，isa需要进行一次位运算(isa地址 &amp; ISA_MASK)，才能计算出真实地址<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># if __arm64__</span><br><span class="line">#   define ISA_MASK        0x0000000ffffffff8ULL</span><br><span class="line"># elif __x86_64__</span><br><span class="line">#   define ISA_MASK        0x00007ffffffffff8ULL</span><br><span class="line"># endif</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>struct objc_class的结构</p></blockquote><ul><li>class、meta-class对象的本质结构都是struct objc_class<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">struct class_ro_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t instanceStart;</span><br><span class="line">    uint32_t instanceSize;  // instance对象占用的内存空间</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    uint32_t reserved;</span><br><span class="line">#endif</span><br><span class="line">    const uint8_t * ivarLayout;</span><br><span class="line">    const char * name;  // 类名</span><br><span class="line">    method_list_t * baseMethodList;</span><br><span class="line">    protocol_list_t * baseProtocols;</span><br><span class="line">    const ivar_list_t * ivars;  // 成员变量列表</span><br><span class="line">    const uint8_t * weakIvarLayout;</span><br><span class="line">    property_list_t *baseProperties;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct class_rw_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t version;</span><br><span class="line">    const class_ro_t *ro;</span><br><span class="line">    method_list_t * methods;    // 方法列表</span><br><span class="line">    property_list_t *properties;    // 属性列表</span><br><span class="line">    const protocol_list_t * protocols;  // 协议列表</span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line">    char *demangledName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#define FAST_DATA_MASK          0x00007ffffffffff8UL</span><br><span class="line">struct class_data_bits_t &#123;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">public:</span><br><span class="line">    class_rw_t* data() &#123;</span><br><span class="line">        return (class_rw_t *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* OC对象 */</span><br><span class="line">struct hx_objc_object &#123;</span><br><span class="line">    void *isa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* 类对象 */</span><br><span class="line">struct hx_objc_class : hx_objc_object &#123;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;</span><br><span class="line">    class_data_bits_t bits;</span><br><span class="line">public:</span><br><span class="line">    class_rw_t* data() &#123;</span><br><span class="line">        return bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    hx_objc_class* metaClass() &#123;</span><br><span class="line">        return (hx_objc_class *)((long long)isa &amp; ISA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>用如下方法进行断点查看，内部结构内容<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//实例对象</span><br><span class="line">hx_objc_class *studentClass = (__bridge hx_objc_class *)([Student class]);</span><br><span class="line">hx_objc_class *personClass = (__bridge hx_objc_class *)([Person class]);</span><br><span class="line"></span><br><span class="line">//类对象</span><br><span class="line">class_rw_t *studentClassData = studentClass-&gt;data();</span><br><span class="line">class_rw_t *personClassData = personClass-&gt;data();</span><br><span class="line"></span><br><span class="line">//元类对象</span><br><span class="line">class_rw_t *studentMetaClassData = studentClass-&gt;metaClass()-&gt;data();</span><br><span class="line">class_rw_t *personMetaClassData = personClass-&gt;metaClass()-&gt;data();</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Objective-c语法&quot;&gt;&lt;a href=&quot;#Objective-c语法&quot; class=&quot;headerlink&quot; title=&quot;Objective-c语法&quot;&gt;&lt;/a&gt;Objective-c语法&lt;/h2&gt;&lt;h3 id=&quot;Objective-C的本质&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Objective-C" scheme="http://www.hxtec.top/tags/Objective-C/"/>
    
    <category term="底层原理" scheme="http://www.hxtec.top/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
</feed>
