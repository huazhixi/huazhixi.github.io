<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ivan&#39;s Blog</title>
  
  <subtitle>华曦之家</subtitle>
  <link href="http://www.hxtec.top/atom.xml" rel="self"/>
  
  <link href="http://www.hxtec.top/"/>
  <updated>2022-09-25T16:52:29.473Z</updated>
  <id>http://www.hxtec.top/</id>
  
  <author>
    <name>ivan_华之曦</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>多线程 - 同步文案二</title>
    <link href="http://www.hxtec.top/2022/09/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%90%8C%E6%AD%A5%E6%96%87%E6%A1%88%E4%BA%8C/"/>
    <id>http://www.hxtec.top/2022/09/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%90%8C%E6%AD%A5%E6%96%87%E6%A1%88%E4%BA%8C/</id>
    <published>2022-09-25T16:47:36.000Z</published>
    <updated>2022-09-25T16:52:29.473Z</updated>
    
    <content type="html"><![CDATA[<h2 id="iOS中的线程同步方案"><a href="#iOS中的线程同步方案" class="headerlink" title="iOS中的线程同步方案"></a>iOS中的线程同步方案</h2><h3 id="NSCondition"><a href="#NSCondition" class="headerlink" title="NSCondition"></a>NSCondition</h3><ul><li>NSCondition是对mutex和cond的封装</li></ul><blockquote><p>用法</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface NSCondition: NSObject&lt;NSLocking&gt; &#123;</span><br><span class="line">- (void)wait;</span><br><span class="line">- (BOOL)waitUntilDate:(NSDate *)limit;</span><br><span class="line">- (void)signal;</span><br><span class="line">- (void)broadcast;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><blockquote><p>示例：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;NSConditionDemo.h&quot;</span><br><span class="line"></span><br><span class="line">@interface NSConditionDemo()</span><br><span class="line">@property (strong, nonatomic) NSCondition *condition;</span><br><span class="line">@property (strong, nonatomic) NSMutableArray *data;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation NSConditionDemo</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        self.condition = [[NSCondition alloc] init];</span><br><span class="line">        self.data = [NSMutableArray array];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)otherTest &#123;</span><br><span class="line">    [[[NSThread alloc] initWithTarget:self selector:@selector(__remove) object:nil] start];</span><br><span class="line">    </span><br><span class="line">    [[[NSThread alloc] initWithTarget:self selector:@selector(__add) object:nil] start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 生产者-消费者模式</span><br><span class="line"></span><br><span class="line">// 线程1</span><br><span class="line">// 删除数组中的元素</span><br><span class="line">- (void)__remove &#123;</span><br><span class="line">    [self.condition lock];</span><br><span class="line">    NSLog(@&quot;__remove - begin&quot;);</span><br><span class="line">    </span><br><span class="line">    if (self.data.count == 0) &#123;</span><br><span class="line">        // 等待</span><br><span class="line">        [self.condition wait];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [self.data removeLastObject];</span><br><span class="line">    NSLog(@&quot;删除了元素&quot;);</span><br><span class="line">    </span><br><span class="line">    [self.condition unlock];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 线程2</span><br><span class="line">// 往数组中添加元素</span><br><span class="line">- (void)__add &#123;</span><br><span class="line">    [self.condition lock];</span><br><span class="line">    </span><br><span class="line">    sleep(1);</span><br><span class="line">    </span><br><span class="line">    [self.data addObject:@&quot;Test&quot;];</span><br><span class="line">    NSLog(@&quot;添加了元素&quot;);</span><br><span class="line">    </span><br><span class="line">    // 信号</span><br><span class="line">    [self.condition signal];</span><br><span class="line">    // 广播</span><br><span class="line">    //[self.condition broadcast];</span><br><span class="line">    </span><br><span class="line">    sleep(2);</span><br><span class="line">    </span><br><span class="line">    [self.condition unlock];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="NSConditionLock"><a href="#NSConditionLock" class="headerlink" title="NSConditionLock"></a>NSConditionLock</h3><ul><li>NSConditionLock是对NSCondition的进一步封装，可以设置具体的条件值</li><li>线程之间的依赖</li></ul><blockquote><p>用法</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@interface NSConditionLock: NSObject&lt;NSLocking&gt; &#123;</span><br><span class="line">@property (readonly) NSInteger condition;</span><br><span class="line">- (instancetype)initWithCondition:(NSInteger)condition;</span><br><span class="line">- (void)lockWhenCondition:(NSInteger)condition;</span><br><span class="line">- (BOOL)tryLock;</span><br><span class="line">- (BOOL)tryLockWhenCondition:(NSInteger)condition;</span><br><span class="line">- (void)unLockWhenCondition:(NSInteger)condition;</span><br><span class="line">- (BOOL)lockBeforeDate:(NSDate *)limit;</span><br><span class="line">- (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><blockquote><p>示例：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;NSConditionLockDemo.h&quot;</span><br><span class="line"></span><br><span class="line">@interface NSConditionLockDemo()</span><br><span class="line">@property (strong, nonatomic) NSConditionLock *conditionLock;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation NSConditionLockDemo</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        //condition默认是从0开始</span><br><span class="line">        self.conditionLock = [[NSConditionLock alloc] initWithCondition:1];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)otherTest &#123;</span><br><span class="line">    [[[NSThread alloc] initWithTarget:self selector:@selector(__one) object:nil] start];</span><br><span class="line">    </span><br><span class="line">    [[[NSThread alloc] initWithTarget:self selector:@selector(__two) object:nil] start];</span><br><span class="line">    </span><br><span class="line">    [[[NSThread alloc] initWithTarget:self selector:@selector(__three) object:nil] start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)__one &#123;</span><br><span class="line">    [self.conditionLock lock];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;__one&quot;);</span><br><span class="line">    sleep(1);</span><br><span class="line">    </span><br><span class="line">    [self.conditionLock unlockWithCondition:2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)__two &#123;</span><br><span class="line">    [self.conditionLock lockWhenCondition:2];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;__two&quot;);</span><br><span class="line">    sleep(1);</span><br><span class="line">    </span><br><span class="line">    [self.conditionLock unlockWithCondition:3];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)__three &#123;</span><br><span class="line">    [self.conditionLock lockWhenCondition:3];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;__three&quot;);</span><br><span class="line">    </span><br><span class="line">    [self.conditionLock unlock];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="dispatch-semaphore"><a href="#dispatch-semaphore" class="headerlink" title="dispatch_semaphore"></a>dispatch_semaphore</h3><ul><li>semaphore叫做”信号量”</li><li>信号量的初始值，可以用来控制线程并发访问的最大数量</li><li>信号量的初始值为1，代表同时只允许1条线程访问资源，保证线程同步</li></ul><blockquote><p>用法</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 信号量的初始值</span><br><span class="line">int value = 1;</span><br><span class="line">// 初始化信号量</span><br><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(value);</span><br><span class="line">// 如果信号量的值&lt;0，当前线程就会进入休眠等待（直到信号量的值&gt;0）</span><br><span class="line">// 如果信号量的值&gt;0，就减1，然后往下执行后面的代码</span><br><span class="line">dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">// 让信号是的值加1</span><br><span class="line">dispatch_semaphore_signal(semaphore);</span><br></pre></td></tr></table></figure><blockquote><p>示例：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;SemaphoreDemo.h&quot;</span><br><span class="line"></span><br><span class="line">@interface SemaphoreDemo()</span><br><span class="line">@property (strong, nonatomic) dispatch_semaphore_t semaphore;</span><br><span class="line">@property (strong, nonatomic) dispatch_semaphore_t ticketSemaphore;</span><br><span class="line">@property (strong, nonatomic) dispatch_semaphore_t moneySemaphore;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation SemaphoreDemo</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        self.semaphore = dispatch_semaphore_create(5);</span><br><span class="line">        self.ticketSemaphore = dispatch_semaphore_create(1);</span><br><span class="line">        self.moneySemaphore = dispatch_semaphore_create(1);</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)__drawMoney &#123;</span><br><span class="line">    dispatch_semaphore_wait(self.moneySemaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    </span><br><span class="line">    [super __drawMoney];</span><br><span class="line">    </span><br><span class="line">    dispatch_semaphore_signal(self.moneySemaphore);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)__saveMoney &#123;</span><br><span class="line">    dispatch_semaphore_wait(self.moneySemaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    </span><br><span class="line">    [super __saveMoney];</span><br><span class="line">    </span><br><span class="line">    dispatch_semaphore_signal(self.moneySemaphore);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)__saleTicket &#123;</span><br><span class="line">    dispatch_semaphore_wait(self.ticketSemaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    </span><br><span class="line">    [super __saleTicket];</span><br><span class="line">    </span><br><span class="line">    dispatch_semaphore_signal(self.ticketSemaphore);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)otherTest &#123;</span><br><span class="line">    for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">        [[[NSThread alloc] initWithTarget:self selector:@selector(test) object:nil] start];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 线程10、7、6、9、8</span><br><span class="line">- (void)test &#123;</span><br><span class="line">    // 如果信号量的值 &gt; 0，就让信号量的值减1，然后继续往下执行代码</span><br><span class="line">    // 如果信号量的值 &lt;= 0，就会休眠等待，直到信号量的值变成&gt;0，就让信号量的值减1，然后继续往下执行代码</span><br><span class="line">    dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    </span><br><span class="line">    sleep(2);</span><br><span class="line">    NSLog(@&quot;test - %@&quot;, [NSThread currentThread]);</span><br><span class="line">    </span><br><span class="line">    // 让信号量的值+1</span><br><span class="line">    dispatch_semaphore_signal(self.semaphore);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="dispatch-queue"><a href="#dispatch-queue" class="headerlink" title="dispatch_queue"></a>dispatch_queue</h3><ul><li>直接使用GCD的串行队列，也是可以实现线程同步的</li></ul><blockquote><p>用法</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t = dispatch_queue_create(&quot;lock_queue&quot;, DISPATCH_QUEEU_SERIAL);</span><br><span class="line">dispatch_sync(queue, ^&#123;</span><br><span class="line">    //任务...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>示例：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;SerialQueueDemo.h&quot;</span><br><span class="line"></span><br><span class="line">@interface SerialQueueDemo()</span><br><span class="line">@property (strong, nonatomic) dispatch_queue_t ticketQueue;</span><br><span class="line">@property (strong, nonatomic) dispatch_queue_t moneyQueue;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation SerialQueueDemo</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        self.ticketQueue = dispatch_queue_create(&quot;ticketQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">        self.moneyQueue = dispatch_queue_create(&quot;moneyQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)__drawMoney &#123;</span><br><span class="line">    dispatch_sync(self.moneyQueue, ^&#123;</span><br><span class="line">        [super __drawMoney];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)__saveMoney &#123;</span><br><span class="line">    dispatch_sync(self.moneyQueue, ^&#123;</span><br><span class="line">        [super __saveMoney];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)__saleTicket &#123;</span><br><span class="line">    dispatch_sync(self.ticketQueue, ^&#123;</span><br><span class="line">        [super __saleTicket];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="@synchronized"></a>@synchronized</h3><ul><li>@synchronized是对mutex递归锁的封装</li><li>源码查看：objc4中的objc-sync.mm文件</li><li>@synchronized(obj)内部会生成obj对应的递归锁，然后进行加锁、解锁操作</li></ul><blockquote><p>用法</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@synchronized(obj) &#123;</span><br><span class="line">    //任务</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>示例：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;SynchronizedDemo.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation SynchronizedDemo</span><br><span class="line"></span><br><span class="line">- (void)__drawMoney &#123;</span><br><span class="line">    @synchronized([self class]) &#123;</span><br><span class="line">        [super __drawMoney];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)__saveMoney &#123;</span><br><span class="line">    @synchronized([self class]) &#123; // objc_sync_enter</span><br><span class="line">        [super __saveMoney];</span><br><span class="line">    &#125; // objc_sync_exit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)__saleTicket &#123;</span><br><span class="line">    static NSObject *lock;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        lock = [[NSObject alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    @synchronized(lock) &#123;</span><br><span class="line">        [super __saleTicket];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)otherTest &#123;</span><br><span class="line">    @synchronized([self class]) &#123;</span><br><span class="line">        NSLog(@&quot;123&quot;);</span><br><span class="line">        [self otherTest];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h2 id="iOS中的读写安全方案"><a href="#iOS中的读写安全方案" class="headerlink" title="iOS中的读写安全方案"></a>iOS中的读写安全方案</h2><ul><li>思考如何实现以下场景<ul><li>同一时间，只能有1个线程进行写的操作</li><li>同一时间，允许有多个线程进行读的操作</li><li>同一时间，不允许既有写的操作，又有读的操作</li></ul></li></ul><blockquote><p>上面的场景就是典型的“多读单写”，经常用于文件等数据的读写操作，iOS中的实现方案有</p><ul><li>pthread_rwlock：读写锁</li><li>dispatch_barrier_async：异步栅栏调用</li></ul></blockquote><h3 id="pthread-rwlock"><a href="#pthread-rwlock" class="headerlink" title="pthread_rwlock"></a>pthread_rwlock</h3><ul><li>等待锁的线程会进入休眠</li></ul><blockquote><p>用法</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 初始化锁</span><br><span class="line">pthread_rwlock lock;</span><br><span class="line">pthread_rwlock_init(&amp;lock, NULL);</span><br><span class="line">// 读 - 加锁</span><br><span class="line">pthread_rwlock_rdlock(&amp;lock);</span><br><span class="line">// 读 - 尝试加锁</span><br><span class="line">pthread_rwlock_tryrdlock(&amp;lock);</span><br><span class="line">// 写 - 加锁</span><br><span class="line">pthread_rwlock_wrlock(&amp;lock);</span><br><span class="line">// 写 - 尝试加锁</span><br><span class="line">pthread_rwlock_trywrlock(&amp;lock);</span><br><span class="line">// 解锁</span><br><span class="line">pthread_rwlock_unlock(&amp;lock):</span><br><span class="line">// 销毁</span><br><span class="line">pthread_rwlock_destroy(&amp;lock):</span><br></pre></td></tr></table></figure><blockquote><p>示例：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line">@property (assign, nonatomic) pthread_rwlock_t lock;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    // 初始化锁</span><br><span class="line">    pthread_rwlock_init(&amp;_lock, NULL);</span><br><span class="line">    </span><br><span class="line">    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        dispatch_async(queue, ^&#123;</span><br><span class="line">            [self read];</span><br><span class="line">        &#125;);</span><br><span class="line">        dispatch_async(queue, ^&#123;</span><br><span class="line">            [self write];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)read &#123;</span><br><span class="line">    pthread_rwlock_rdlock(&amp;_lock);</span><br><span class="line">    </span><br><span class="line">    sleep(1);</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">    </span><br><span class="line">    pthread_rwlock_unlock(&amp;_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)write &#123;</span><br><span class="line">    pthread_rwlock_wrlock(&amp;_lock);</span><br><span class="line">    </span><br><span class="line">    sleep(1);</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">    </span><br><span class="line">    pthread_rwlock_unlock(&amp;_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    pthread_rwlock_destroy(&amp;_lock);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="dispatch-barrier-async"><a href="#dispatch-barrier-async" class="headerlink" title="dispatch_barrier_async"></a>dispatch_barrier_async</h3><ul><li>这个函数传入的并发队列必须是自己通过dispatch_queue_cretate创建的</li><li>如果传入的是一个串行或是一个全局的并发队列，那这个函数便等同于dispatch_async函数的效果</li></ul><blockquote><p>用法</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 初始化队列</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;rw_queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">// 读</span><br><span class="line">dispatch_async(self.queue, ^&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">// 写</span><br><span class="line">dispatch_barrier_async(self.queue, ^&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>示例：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line">@property (strong, nonatomic) dispatch_queue_t queue;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">//    NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class="line">//    queue.maxConcurrentOperationCount = 5;</span><br><span class="line">    </span><br><span class="line">//    dispatch_semaphore_create(5);</span><br><span class="line">    </span><br><span class="line">    self.queue = dispatch_queue_create(&quot;rw_queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        dispatch_async(self.queue, ^&#123;</span><br><span class="line">            [self read];</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        dispatch_async(self.queue, ^&#123;</span><br><span class="line">            [self read];</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        dispatch_async(self.queue, ^&#123;</span><br><span class="line">            [self read];</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        //添加栅栏锁</span><br><span class="line">        dispatch_barrier_async(self.queue, ^&#123;</span><br><span class="line">            [self write];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)read &#123;</span><br><span class="line">    sleep(1);</span><br><span class="line">    NSLog(@&quot;read&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)write &#123;</span><br><span class="line">    sleep(1);</span><br><span class="line">    NSLog(@&quot;write&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h2 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h2><ul><li>atomic用于保证属性setter、getter的原子性操作，相当于在getter和setter内部加了线程同步的锁</li><li>可以参考源码objc4的objc-accessors.mm</li><li>它并不能保证使用属性的过程是线程安全的</li></ul><h2 id="iOS线程同步方案性能比较"><a href="#iOS线程同步方案性能比较" class="headerlink" title="iOS线程同步方案性能比较"></a>iOS线程同步方案性能比较</h2><blockquote><p>性能从高到低排序</p><ul><li>os_unfair_lock</li><li>OSSpinLock</li><li>dispatch_semaphore</li><li>pthread_mutex</li><li>dispatch_queue(DISPATCH_QUEUE_SERIAL)</li><li>NSLock</li><li>NSCondition</li><li>pthread_mutex(recursive)</li><li>NSRecursiveLock</li><li>NSConditionLock</li><li>@synchronized</li></ul></blockquote><h2 id="自旋锁、互斥锁比较"><a href="#自旋锁、互斥锁比较" class="headerlink" title="自旋锁、互斥锁比较"></a>自旋锁、互斥锁比较</h2><blockquote><p>什么情况使用自旋锁比较划算？</p><ul><li>预计线程等待锁的时间很短</li><li>加锁的代码（临界区）经常被调用，但竞争情况很少发生</li><li>CPU资源不紧张</li><li>多核处理器</li></ul></blockquote><blockquote><p>什么情况使用互斥锁比较划算？</p><ul><li>预计线程等待锁的时间较长</li><li>单核处理器</li><li>临界区有IO操作</li><li>临界区代码复杂或者循环量大</li><li>临界区竞争非常激烈</li></ul></blockquote><h2 id="高频面试题"><a href="#高频面试题" class="headerlink" title="高频面试题"></a>高频面试题</h2><ul><li>你理解的多线程？</li><li>iOS的多线程方案有哪几种？你更倾向于哪一种？</li><li>你在项目中用过 GCD 吗？</li><li>GCD 的队列类型</li><li>说一下 OperationQueue 和 GCD 的区别，以及各自的优势</li><li>线程安全的处理手段有哪些？</li><li>OC你了解的锁有哪些？在你回答基础上进行二次提问；<ul><li>追问一：自旋和互斥对比？</li><li>追问二：使用以上锁需要注意哪些？</li><li>追问三：用C&#x2F;OC&#x2F;C++，任选其一，实现自旋或互斥？口述即可！</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;iOS中的线程同步方案&quot;&gt;&lt;a href=&quot;#iOS中的线程同步方案&quot; class=&quot;headerlink&quot; title=&quot;iOS中的线程同步方案&quot;&gt;&lt;/a&gt;iOS中的线程同步方案&lt;/h2&gt;&lt;h3 id=&quot;NSCondition&quot;&gt;&lt;a href=&quot;#NSCond</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Objective-C" scheme="http://www.hxtec.top/tags/Objective-C/"/>
    
    <category term="底层原理" scheme="http://www.hxtec.top/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    <category term="多线程" scheme="http://www.hxtec.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>多线程 - 同步方案一</title>
    <link href="http://www.hxtec.top/2022/09/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88%E4%B8%80/"/>
    <id>http://www.hxtec.top/2022/09/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88%E4%B8%80/</id>
    <published>2022-09-25T16:09:11.962Z</published>
    <updated>2022-09-25T17:00:10.850Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多线程的安全隐患"><a href="#多线程的安全隐患" class="headerlink" title="多线程的安全隐患"></a>多线程的安全隐患</h2><ul><li>资源共享<ul><li>1块资源可能会被多个线程共享，也就是<code>多个线程可能会访问同一块资源</code></li><li>比如多个线程访问同一个对象、同一个变量、同一个文件</li></ul></li><li>当多个线程访问同一块资源时，很容易引发<code>数据错乱和数据安全</code>问题</li></ul><h2 id="多线程的安全隐患的解决方案"><a href="#多线程的安全隐患的解决方案" class="headerlink" title="多线程的安全隐患的解决方案"></a>多线程的安全隐患的解决方案</h2><ul><li>解决方案：使用<code>线程同步</code>技术（同步，就是协同步调，按预定的先后次序进行）</li><li>常见的线程同步技术是：<code>加锁</code></li></ul><h2 id="iOS中的线程同步方案"><a href="#iOS中的线程同步方案" class="headerlink" title="iOS中的线程同步方案"></a>iOS中的线程同步方案</h2><ul><li>OSSpinLock</li><li>os_unfair_lock</li><li>pthread_mutex</li><li>dispatch_semaphore</li><li>dispatch_queue(DISPATCH_QUEUE_SERIAL)</li><li>NSLock</li><li>NSRecursiveLock</li><li>NSCondition</li><li>NSConditionLock</li><li>@synchronized</li></ul><h3 id="OSSpinLock"><a href="#OSSpinLock" class="headerlink" title="OSSpinLock"></a>OSSpinLock</h3><ul><li>OSSpinLock叫做”自旋锁”，等待锁的线程会处于忙等（busy-wait）状态，一直占用着CPU资源</li><li>目前已经不再安全，可能会出现优先级反转问题<ul><li>如果等待锁的线程优先级较高，它会一直占用着CPU资源，优先级低的线程就无法释放锁</li><li>需要导入头文件#import &lt;libkern&#x2F;OSAtomic.h&gt;</li></ul></li></ul><blockquote><p>用法：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//初始化</span><br><span class="line">OSSpinLock lock = OS_SPINLOCK_INIT;</span><br><span class="line">//尝试加锁（如果需要等待就不加锁，直接返回false；如果不需要等待就加锁，返回true）</span><br><span class="line">bool result = OSSpinLockTry(&amp;lock);</span><br><span class="line">//加锁</span><br><span class="line">OSSpinLockLock(&amp;lock);</span><br><span class="line">//解锁</span><br><span class="line">OSSpineLockUnlock(&amp;lock);</span><br></pre></td></tr></table></figure><blockquote><p>示例：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;OSSpinLockDemo.h&quot;</span><br><span class="line">#import &lt;libkern/OSAtomic.h&gt;</span><br><span class="line"></span><br><span class="line">@interface OSSpinLockDemo()</span><br><span class="line">// High-level lock</span><br><span class="line">@property (assign, nonatomic) OSSpinLock moneyLock;</span><br><span class="line">@property (assign, nonatomic) OSSpinLock ticketLock;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation OSSpinLockDemo</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        self.moneyLock = OS_SPINLOCK_INIT;</span><br><span class="line">        self.ticketLock = OS_SPINLOCK_INIT;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">- (void)__drawMoney &#123;</span><br><span class="line">    OSSpinLockLock(&amp;_moneyLock);</span><br><span class="line">    [super __drawMoney];</span><br><span class="line">    OSSpinLockUnlock(&amp;_moneyLock);</span><br><span class="line">&#125;</span><br><span class="line">- (void)__saveMoney &#123;</span><br><span class="line">    OSSpinLockLock(&amp;_moneyLock);</span><br><span class="line">    [super __saveMoney];</span><br><span class="line">    OSSpinLockUnlock(&amp;_moneyLock);</span><br><span class="line">&#125;</span><br><span class="line">- (void)__saleTicket &#123;</span><br><span class="line">    OSSpinLockLock(&amp;_ticketLock);</span><br><span class="line">    [super __saleTicket];</span><br><span class="line">    OSSpinLockUnlock(&amp;_ticketLock);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="os-unfair-lock"><a href="#os-unfair-lock" class="headerlink" title="os_unfair_lock"></a>os_unfair_lock</h3><ul><li>os_unfair_lock用于取代不安全的OSSpinLock ，从iOS10开始才支持</li><li>从底层调用看，等待os_unfair_lock锁的线程会处于休眠状态，并非忙等</li><li>需要导入头文件#import &lt;os&#x2F;lock.h&gt;</li></ul><blockquote><p>用法</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//初始化</span><br><span class="line">os_unfair_lock lock = OS_UNFAIR_LOCK_INIT;</span><br><span class="line">//尝试加锁</span><br><span class="line">os_unfair_lock_trylock(&amp;lock);</span><br><span class="line">//加锁</span><br><span class="line">os_unfair_lock_lock(&amp;lock);</span><br><span class="line">// 解锁</span><br><span class="line">os_unfair_lock_unlock(&amp;lock);</span><br></pre></td></tr></table></figure><blockquote><p>示例：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;OSUnfairLockDemo.h&quot;</span><br><span class="line">#import &lt;os/lock.h&gt;</span><br><span class="line"></span><br><span class="line">@interface OSUnfairLockDemo()</span><br><span class="line">// Low-level lock</span><br><span class="line">// ll lock</span><br><span class="line">// lll</span><br><span class="line">// Low-level lock的特点等不到锁就休眠</span><br><span class="line">@property (assign, nonatomic) os_unfair_lock moneyLock;</span><br><span class="line">@property (assign, nonatomic) os_unfair_lock ticketLock;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation OSUnfairLockDemo</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        self.moneyLock = OS_UNFAIR_LOCK_INIT;</span><br><span class="line">        self.ticketLock = OS_UNFAIR_LOCK_INIT;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 死锁：永远拿不到锁</span><br><span class="line">- (void)__saleTicket &#123;</span><br><span class="line">    os_unfair_lock_lock(&amp;_ticketLock);</span><br><span class="line">    [super __saleTicket];</span><br><span class="line">    os_unfair_lock_unlock(&amp;_ticketLock);</span><br><span class="line">&#125;</span><br><span class="line">- (void)__saveMoney &#123;</span><br><span class="line">    os_unfair_lock_lock(&amp;_moneyLock);</span><br><span class="line">    [super __saveMoney];</span><br><span class="line">    os_unfair_lock_unlock(&amp;_moneyLock);</span><br><span class="line">&#125;</span><br><span class="line">- (void)__drawMoney &#123;</span><br><span class="line">    os_unfair_lock_lock(&amp;_moneyLock);</span><br><span class="line">    [super __drawMoney];</span><br><span class="line">    os_unfair_lock_unlock(&amp;_moneyLock);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="pthread-mutex"><a href="#pthread-mutex" class="headerlink" title="pthread_mutex"></a>pthread_mutex</h3><ul><li>mutex叫做”互斥锁”，等待锁的线程会处于休眠状态</li><li>需要导入头文件#import &lt;pthread.h&gt;</li></ul><blockquote><p>用法</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 初始化锁属性</span><br><span class="line">pthread_mutexattr_t attr;</span><br><span class="line">pthread_mutexattr_init(&amp;attr);</span><br><span class="line">pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_DEFAULT);</span><br><span class="line">// 初始化锁</span><br><span class="line">pthread_mutex_t mutex;</span><br><span class="line">pthread_mutex_init(&amp;mutex, &amp;attr);</span><br><span class="line">// 尝试加锁</span><br><span class="line">pthread_mutex_trylock(&amp;mutex);</span><br><span class="line">// 加锁</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line">// 解锁</span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">// 销毁相关资源</span><br><span class="line">pthread_mutexattr_destroy(&amp;attr);    pthread_mutex_destroy(&amp;mutex);</span><br></pre></td></tr></table></figure><blockquote><p>示例：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;MutexDemo.h&quot;</span><br><span class="line">#import &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">@interface MutexDemo()</span><br><span class="line">@property (assign, nonatomic) pthread_mutex_t ticketMutex;</span><br><span class="line">@property (assign, nonatomic) pthread_mutex_t moneyMutex;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MutexDemo</span><br><span class="line"></span><br><span class="line">- (void)__initMutex:(pthread_mutex_t *)mutex &#123;</span><br><span class="line">// 静态初始化</span><br><span class="line">//        pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">    </span><br><span class="line">//    // 初始化属性</span><br><span class="line">//    pthread_mutexattr_t attr;</span><br><span class="line">//    pthread_mutexattr_init(&amp;attr);</span><br><span class="line">//    pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_DEFAULT);</span><br><span class="line">//    // 初始化锁</span><br><span class="line">//    pthread_mutex_init(mutex, &amp;attr);</span><br><span class="line">//    // 销毁属性</span><br><span class="line">//    pthread_mutexattr_destroy(&amp;attr);</span><br><span class="line">    </span><br><span class="line">    // 初始化属性</span><br><span class="line">//    pthread_mutexattr_t attr;</span><br><span class="line">//    pthread_mutexattr_init(&amp;attr);</span><br><span class="line">//    pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_DEFAULT)</span><br><span class="line">//    //初始化锁</span><br><span class="line">//    pthread_mutex_init(mutex, attr);</span><br><span class="line">//    // 销毁属性</span><br><span class="line">//    pthread_mutexattr_destroy(&amp;attr);</span><br><span class="line"></span><br><span class="line">    // 初始化锁，第二个参数传NULL时，属性可以不用设置</span><br><span class="line">    pthread_mutex_init(mutex, NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        [self __initMutex:&amp;_ticketMutex];</span><br><span class="line">        [self __initMutex:&amp;_moneyMutex];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 死锁：永远拿不到锁</span><br><span class="line">- (void)__saleTicket &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;_ticketMutex);</span><br><span class="line">    [super __saleTicket];</span><br><span class="line">    pthread_mutex_unlock(&amp;_ticketMutex);</span><br><span class="line">&#125;</span><br><span class="line">- (void)__saveMoney &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;_moneyMutex);</span><br><span class="line">    [super __saveMoney];</span><br><span class="line">    pthread_mutex_unlock(&amp;_moneyMutex);</span><br><span class="line">&#125;</span><br><span class="line">- (void)__drawMoney &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;_moneyMutex);</span><br><span class="line">    [super __drawMoney];</span><br><span class="line">    pthread_mutex_unlock(&amp;_moneyMutex);</span><br><span class="line">&#125;</span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    pthread_mutex_destroy(&amp;_moneyMutex);</span><br><span class="line">    pthread_mutex_destroy(&amp;_ticketMutex);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="pthread-mutex-–-递归锁"><a href="#pthread-mutex-–-递归锁" class="headerlink" title="pthread_mutex – 递归锁"></a>pthread_mutex – 递归锁</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Mutex type attributes</span><br><span class="line">*/</span><br><span class="line">#define PTHREAD_MUTEX_NORMAL        0</span><br><span class="line">#define PTHREAD_MUTEX_ERRORCHECK    1</span><br><span class="line">#define PTHREAD_MUTEX_RECURSIVE     2   //递归属性</span><br><span class="line">#define PTHREAD_MUTEX_DEFAULT       PTHREAD_MUTEX_NORMAL</span><br></pre></td></tr></table></figure><blockquote><p>示例：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;MutexDemo2.h&quot;</span><br><span class="line">#import &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">@interface MutexDemo2()</span><br><span class="line">@property (assign, nonatomic) pthread_mutex_t mutex;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MutexDemo2</span><br><span class="line"></span><br><span class="line">- (void)__initMutex:(pthread_mutex_t *)mutex &#123;</span><br><span class="line">    // 递归锁：允许同一个线程对一把锁进行重复加锁</span><br><span class="line">    </span><br><span class="line">    // 初始化属性</span><br><span class="line">    pthread_mutexattr_t attr;</span><br><span class="line">    pthread_mutexattr_init(&amp;attr);</span><br><span class="line">    pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line">    // 初始化锁</span><br><span class="line">    pthread_mutex_init(mutex, &amp;attr);</span><br><span class="line">    // 销毁属性</span><br><span class="line">    pthread_mutexattr_destroy(&amp;attr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        [self __initMutex:&amp;_mutex];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 线程1：otherTest（+-）</span><br><span class="line">        otherTest（+-）</span><br><span class="line">         otherTest（+-）</span><br><span class="line"> </span><br><span class="line"> 线程2：otherTest（等待）</span><br><span class="line"> */</span><br><span class="line">- (void)otherTest &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">    static int count = 0;</span><br><span class="line">    if (count &lt; 10) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        [self otherTest];</span><br><span class="line">        //[self otherTest];</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//- (void)otherTest2</span><br><span class="line">//&#123;</span><br><span class="line">//    pthread_mutex_lock(&amp;_mutex2);</span><br><span class="line">//    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">//    pthread_mutex_unlock(&amp;_mutex2);</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    pthread_mutex_destroy(&amp;_mutex);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="pthread-mutex-–-条件"><a href="#pthread-mutex-–-条件" class="headerlink" title="pthread_mutex – 条件"></a>pthread_mutex – 条件</h3><blockquote><p>用法</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 初始化锁</span><br><span class="line">pthread_mutex_t mutex;</span><br><span class="line">// 初始化锁属性，NULL代表使用默认属性</span><br><span class="line">pthread_mutex_init(&amp;mutex, NULL);</span><br><span class="line">// 初始化条件</span><br><span class="line">pthread_cond_t condition;</span><br><span class="line">pthread_cont_init(&amp;condition, NULL);</span><br><span class="line">// 等待条件（进入休眠，放开mutext锁；被唤醒后，会再次对mutex加锁）</span><br><span class="line">pthread_cond_wait(&amp;condition, &amp;mutex);</span><br><span class="line">// 激活一个等待该条件的线程</span><br><span class="line">pthread_cond_signal(&amp;condition);</span><br><span class="line">// 激活所有等待该条件的线程</span><br><span class="line">pthread_cond_broadcast(&amp;condition);</span><br><span class="line">// 销毁相关资源</span><br><span class="line">pthread_mutexattr_destroy(&amp;attr);    pthread_mutex_destroy(&amp;mutex);</span><br></pre></td></tr></table></figure><blockquote><p>示例：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;MutexDemo3.h&quot;</span><br><span class="line">#import &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">@interface MutexDemo3()</span><br><span class="line">@property (assign, nonatomic) pthread_mutex_t mutex;</span><br><span class="line">@property (assign, nonatomic) pthread_cond_t cond;</span><br><span class="line">@property (strong, nonatomic) NSMutableArray *data;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MutexDemo3</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        // 初始化属性</span><br><span class="line">        pthread_mutexattr_t attr;</span><br><span class="line">        pthread_mutexattr_init(&amp;attr);</span><br><span class="line">        pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line">        // 初始化锁</span><br><span class="line">        pthread_mutex_init(&amp;_mutex, &amp;attr);</span><br><span class="line">        // 销毁属性</span><br><span class="line">        pthread_mutexattr_destroy(&amp;attr);</span><br><span class="line">        </span><br><span class="line">        // 初始化条件</span><br><span class="line">        pthread_cond_init(&amp;_cond, NULL);</span><br><span class="line">        </span><br><span class="line">        self.data = [NSMutableArray array];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)otherTest &#123;</span><br><span class="line">    [[[NSThread alloc] initWithTarget:self selector:@selector(__remove) object:nil] start];</span><br><span class="line">    </span><br><span class="line">    [[[NSThread alloc] initWithTarget:self selector:@selector(__add) object:nil] start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 生产者-消费者模式</span><br><span class="line"></span><br><span class="line">// 线程1</span><br><span class="line">// 删除数组中的元素</span><br><span class="line">- (void)__remove &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">    NSLog(@&quot;__remove - begin&quot;);</span><br><span class="line">    </span><br><span class="line">    if (self.data.count == 0) &#123;</span><br><span class="line">        // 等待</span><br><span class="line">        pthread_cond_wait(&amp;_cond, &amp;_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [self.data removeLastObject];</span><br><span class="line">    NSLog(@&quot;删除了元素&quot;);</span><br><span class="line">    </span><br><span class="line">    pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 线程2</span><br><span class="line">// 往数组中添加元素</span><br><span class="line">- (void)__add &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">    </span><br><span class="line">    sleep(1);</span><br><span class="line">    </span><br><span class="line">    [self.data addObject:@&quot;Test&quot;];</span><br><span class="line">    NSLog(@&quot;添加了元素&quot;);</span><br><span class="line"></span><br><span class="line">    // 信号</span><br><span class="line">    pthread_cond_signal(&amp;_cond);</span><br><span class="line">    // 广播</span><br><span class="line">//    pthread_cond_broadcast(&amp;_cond);</span><br><span class="line">    pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc&#123;</span><br><span class="line">    pthread_mutex_destroy(&amp;_mutex);</span><br><span class="line">    pthread_cond_destroy(&amp;_cond);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="NSLock、NSRecursiveLock"><a href="#NSLock、NSRecursiveLock" class="headerlink" title="NSLock、NSRecursiveLock"></a>NSLock、NSRecursiveLock</h3><ul><li><code>NSLock</code>是对<code>mutex</code>普通锁的封装</li><li><code>NSRecursiveLock</code>也是对<code>mutex递归锁</code>的封装，API跟NSLock基本一致</li></ul><blockquote><p>用法</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@interface NSLock: NSObject&lt;NSLocking&gt; &#123;</span><br><span class="line">- (BOOL)tryLock;</span><br><span class="line">- (BOOL)lockBeforeDate:(NSDate *)limit;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@protocol NSLocking</span><br><span class="line">- (void)lock;</span><br><span class="line">- (void)unlock;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// 初始化锁</span><br><span class="line">NSLock *lock = [[NSLock alloc] init];</span><br></pre></td></tr></table></figure><blockquote><p>示例：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;NSLockDemo.h&quot;</span><br><span class="line"></span><br><span class="line">@interface NSLockDemo()</span><br><span class="line">@property (strong, nonatomic) NSLock *ticketLock;</span><br><span class="line">@property (strong, nonatomic) NSLock *moneyLock;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation NSLockDemo</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        self.ticketLock = [[NSLock alloc] init];</span><br><span class="line">        self.moneyLock = [[NSLock alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 死锁：永远拿不到锁</span><br><span class="line">- (void)__saleTicket &#123;</span><br><span class="line">    [self.ticketLock lock];</span><br><span class="line">    [super __saleTicket];</span><br><span class="line">    [self.ticketLock unlock];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)__saveMoney &#123;</span><br><span class="line">    [self.moneyLock lock];</span><br><span class="line">    [super __saveMoney];</span><br><span class="line">    [self.moneyLock unlock];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)__drawMoney &#123;</span><br><span class="line">    [self.moneyLock lock];</span><br><span class="line">    [super __drawMoney];</span><br><span class="line">    [self.moneyLock unlock];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;多线程的安全隐患&quot;&gt;&lt;a href=&quot;#多线程的安全隐患&quot; class=&quot;headerlink&quot; title=&quot;多线程的安全隐患&quot;&gt;&lt;/a&gt;多线程的安全隐患&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;资源共享&lt;ul&gt;
&lt;li&gt;1块资源可能会被多个线程共享，也就是&lt;code&gt;多个线</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Objective-C" scheme="http://www.hxtec.top/tags/Objective-C/"/>
    
    <category term="底层原理" scheme="http://www.hxtec.top/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    <category term="多线程" scheme="http://www.hxtec.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>多线程 - 原理机制</title>
    <link href="http://www.hxtec.top/2022/09/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B%20-%20%E5%8E%9F%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    <id>http://www.hxtec.top/2022/09/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B%20-%20%E5%8E%9F%E7%90%86%E6%9C%BA%E5%88%B6/</id>
    <published>2022-09-25T13:45:51.000Z</published>
    <updated>2022-09-25T16:11:19.819Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h2><h3 id="线程定义"><a href="#线程定义" class="headerlink" title="线程定义"></a>线程定义</h3><ul><li>线程是进程的基本执行单元，一个进程的所有任务都是在线程中执行</li><li>进行要执行任务，必须得有线程，进行至少有一条线程</li><li>程序启动会默认开启一条线程，这条线程被称为主线程&#x2F;UI线程</li></ul><h3 id="进程定义"><a href="#进程定义" class="headerlink" title="进程定义"></a>进程定义</h3><ul><li>进程是系统进行资源和高度的基本单位</li><li>在移动端进程是指在系统中正在运行的一个程序</li><li>每个进程之间是独立的，每个进程均运行在专用的且受保护的内存中</li></ul><h3 id="进程与线程的关系"><a href="#进程与线程的关系" class="headerlink" title="进程与线程的关系"></a>进程与线程的关系</h3><ul><li>地址空间：同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间</li><li>资源拥有：同一进程内的线程共享本进程的资源内存、I&#x2F;O、CPU等，但是进程之间的资源是独立的</li><li>相互影响：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃后整个进程就死掉了，所以多进程要比多线程健壮</li><li>资源占用：进程切换时资源消耗大，效率高；所以涉及到频繁切换时，使用线程要好于进程，同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程</li><li>执行过程：每个独立的进程有一个程序入口、顺序执行序列和程序出口。但是线程不能独立执行，必须存在应用程序中（进程），有应用程序提供多个线程执行控制（多线程开发）</li><li>线程是处理器调试的基本单位，但进程不是，线程也是进行执行的基本单元</li></ul><h3 id="线程与进程的关系"><a href="#线程与进程的关系" class="headerlink" title="线程与进程的关系"></a>线程与进程的关系</h3><ul><li>多线程中的队列有：串行队列，并发队列，全局队列，主队列</li><li>队列可以理解为一种数据结构，以某种方式，等待线程去执行</li></ul><h3 id="iOS线程与RunLoop的关系"><a href="#iOS线程与RunLoop的关系" class="headerlink" title="iOS线程与RunLoop的关系"></a>iOS线程与RunLoop的关系</h3><ul><li>线程与RunLoop是一一对应的，一个RunLoop对应一个核心线程，为什么说是核心线程，因为RunLoop是可以嵌套的，但是核心只有一个，他们的对应关系保存在一个全局字典里</li><li>RunLoop是用来管理线程的，线程执行完任务时会进入休眠状态，有任务进来时会被唤醒，开始执行任务，所以说RunLoop是事件驱动的</li><li>RunLoop在第一次获取时被创建，线程结束时被销毁，主线程的RunLoop在程序启动的时候就会被创建</li><li>子线程的RunLoop是懒加载的，只有在使用的时候才会被创建</li></ul><blockquote><p>注：在子线程使用NSTimer时要注意确保子线程的RunLoop已经创建，否则NSTimer不会生效</p></blockquote><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>多线程是一个进程中并发多个线程同时执行各自的任务，就是由单核CPU通过时间片不断地切换执行任务</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li>同一时间，CPU只能处理一条线程，只有一条线程在执行（工作）</li><li>多线程并发（同时）执行，其实是CPU快速地在多条线程之间切换（调度）</li><li>如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象</li></ul><h3 id="多线程的优缺点"><a href="#多线程的优缺点" class="headerlink" title="多线程的优缺点"></a>多线程的优缺点</h3><blockquote><p>优点：</p><ul><li>减少应用程序的堵塞，增加程序的执行效率</li><li>适应提高CPU和内存的利用率</li><li>线程上的任务执行完成后，线程自动销毁</li></ul></blockquote><blockquote><p>缺点：</p><ul><li>线程的开启需要占用一定的内存空间，默认是512kb&#x2F;线程</li><li>线程开启的越多内存占用越大，会降低程序的性能</li><li>线程越多CPU在调用线程上的开销就越大</li><li>程序设计更加复杂，需要考虑线程间的通信，多线程的数据共享问题</li></ul></blockquote><h2 id="iOS多线程常见的技术方案"><a href="#iOS多线程常见的技术方案" class="headerlink" title="iOS多线程常见的技术方案"></a>iOS多线程常见的技术方案</h2><table><thead><tr><th>方案</th><th>简介</th><th>语言</th><th>线程生命周期</th><th>使用频率</th></tr></thead><tbody><tr><td>pthread</td><td>一套通用的多线程API 适用于Unix&#x2F;Linux&#x2F;Windows等系统 跨平台、可移植 使用难度大</td><td>C</td><td>程序员管理</td><td>几乎不用</td></tr><tr><td>NSThread</td><td>使用更加面向对象</td><td>简单易用、可直接操作线程对象</td><td>OC</td><td>程序员管理</td></tr><tr><td>GCD</td><td>旨在替代NSThread等线程计数 充分利用设备的多核</td><td>C</td><td>自动管理</td><td>经常使用</td></tr><tr><td>NSOperation</td><td>基于GCD（底层实现是GCD） 比GCD多了一些更简单实用的功能 使用更加面向对象</td><td>OC</td><td>自动管理</td><td>经常使用</td></tr></tbody></table><h2 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h2><blockquote><p>全称<code>Grand Central Dispatch</code>，由C语言实现，是苹果为多核的并行运算提出的解决方案，GCD会自动利用更多的CPU内核，自动管理线程的声明周期，程序员只需要告诉GCD需要执行的任务，无需编写任何管理线程的代码。GCD也是iOS使用频率最高的多线程技术。</p></blockquote><blockquote><p>优点：</p><ul><li>GCD 可用于多核的并行运算</li><li>GCD 会自动利用更多的CPU内核（比如双核，四核）</li><li>GCD 会自动管理线程的生命周期（创建线程、调度任务、销毁线程）</li><li>程序员只需要告诉GCD想要执行什么任务，不需要编写任何线程管理代码</li></ul></blockquote><h3 id="GCD任务和队列"><a href="#GCD任务和队列" class="headerlink" title="GCD任务和队列"></a>GCD任务和队列</h3><h4 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h4><p>任务就是执行操作的意思，也就是在线程中执行的那段代码。<br>在GCD中是放在block中的。</p><ul><li>执行任务有两种方式：[同步执行]和[异步执行]</li><li>两者的区别：是否等待队列的任务执行结束，以及是是否具备开启新线程的能力</li></ul><blockquote><p>同步执行（sync）:</p><ul><li>同步添加任务到指定的队列中，在添加的任务执行结束之前，会一直等待，直到队列里面的任务完成之后再继续执行</li><li>只能在当前线程中执行任务，<code>不具备开启新线程的能力</code></li></ul></blockquote><blockquote><p>异步执行（async）：</p><ul><li>异步添加任务到指定的队列中，它不会做任何等待，可以继续执行任务</li><li>可以在新的线程中执行任务，<code>具备开启新线程的能力</code></li></ul></blockquote><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>队列是一种特殊的线性表，采用<code>FIFO(先进先出)</code>的原则。</p><ul><li>GCD中有两种队列：[串行队列]和[并发队列]，两者都符合FIFO原则</li><li>两者的区别：执行顺序不同，以及开启线程数不同</li></ul><blockquote><p>串行队列（Serial Dispatch Queue）:</p><ul><li>每次只有一个任务被执行，让任务一个接着一个地执行。（只开启一个线程，一个任务执行完毕后，再执行下一个任务）</li></ul></blockquote><blockquote><p>并发队列（Concurrent Dispatch Queue）：</p><ul><li>可以让多个任务并发（同时）执行，（可以开启多个线程，并且同时执行任务）</li></ul></blockquote><blockquote><p>注：并发队列的并发功能只有在异步（dispatch _async）方法下才有效</p></blockquote><h3 id="GCD的常用函数"><a href="#GCD的常用函数" class="headerlink" title="GCD的常用函数"></a>GCD的常用函数</h3><ul><li>GCD中有2个用来执行任务的函数<ul><li>用同步的方式执行任务  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);</span><br><span class="line">queue：队列</span><br><span class="line">block：任务</span><br></pre></td></tr></table></figure></li><li>用异步的方式执行任务  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_queue_t queue, dispatch_block_t block);</span><br></pre></td></tr></table></figure></li></ul></li></ul><blockquote><p>GCD源码：<a href="https://github.com/apple/swift-corelibs-libdispatch">https://github.com/apple/swift-corelibs-libdispatch</a></p></blockquote><h3 id="各种队列的执行效果"><a href="#各种队列的执行效果" class="headerlink" title="各种队列的执行效果"></a>各种队列的执行效果</h3><table><thead><tr><th></th><th>并发队列</th><th>手动创建的串行队列</th><th>主队列</th></tr></thead><tbody><tr><td>同步（sync）</td><td>没有开启新线程 <code>串行</code>执行任务</td><td>没有开启新线程 <code>串行</code>执行任务</td><td>没有开启新线程 <code>串行</code>执行任务</td></tr><tr><td>异步（async）</td><td><code>有开启</code>新线程 <code>并发</code>执行任务</td><td><code>有开启</code>新线程 <code>串行</code>执行任务</td><td>没有开启新线程 <code>串行</code>执行任务</td></tr></tbody></table><blockquote><p>使用sync函数往当前串行队列中添加任务，会卡住当前的串行队列（产生死锁）</p></blockquote><h3 id="GCD队列组的使用"><a href="#GCD队列组的使用" class="headerlink" title="GCD队列组的使用"></a>GCD队列组的使用</h3><ul><li>异步并发执行任务1，任务2</li><li>待任务1，任务2都执行完毕后，再回到主线程执行任务3</li><li>待任务1，任务2都执行完毕后，回到子线程，并发执行任务5和任务6</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> // 创建队列组</span><br><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line">// 创建并发队列</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;my_queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">// 添加异步任务</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">        NSLog(@&quot;任务1-%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">        NSLog(@&quot;任务2-%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line">// 等前面的任务执行完毕后，会自动回到主线程执行这个任务</span><br><span class="line">//    dispatch_group_notify(group, queue, ^&#123;</span><br><span class="line">//        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">//            for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">//                NSLog(@&quot;任务3-%@&quot;, [NSThread currentThread]);</span><br><span class="line">//            &#125;</span><br><span class="line">//        &#125;);</span><br><span class="line">//    &#125;);</span><br><span class="line">// 等前面的任务执行完毕后，会自动回到主线程执行这个任务，此方法更加简单粗暴，</span><br><span class="line">//    dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">//        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">//            NSLog(@&quot;任务4-%@&quot;, [NSThread currentThread]);</span><br><span class="line">//        &#125;</span><br><span class="line">//    &#125;);</span><br><span class="line"></span><br><span class="line">// 回到子线程，并发执行任务3和任务4</span><br><span class="line">dispatch_group_notify(group, queue, ^&#123;</span><br><span class="line">    for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">        NSLog(@&quot;任务5-%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_notify(group, queue, ^&#123;</span><br><span class="line">    for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">        NSLog(@&quot;任务6-%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;线程与进程&quot;&gt;&lt;a href=&quot;#线程与进程&quot; class=&quot;headerlink&quot; title=&quot;线程与进程&quot;&gt;&lt;/a&gt;线程与进程&lt;/h2&gt;&lt;h3 id=&quot;线程定义&quot;&gt;&lt;a href=&quot;#线程定义&quot; class=&quot;headerlink&quot; title=&quot;线程定义&quot;</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Objective-C" scheme="http://www.hxtec.top/tags/Objective-C/"/>
    
    <category term="底层原理" scheme="http://www.hxtec.top/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    <category term="多线程" scheme="http://www.hxtec.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Runloop原理机制</title>
    <link href="http://www.hxtec.top/2022/09/24/Runloop%E5%8E%9F%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    <id>http://www.hxtec.top/2022/09/24/Runloop%E5%8E%9F%E7%90%86%E6%9C%BA%E5%88%B6/</id>
    <published>2022-09-24T03:40:51.000Z</published>
    <updated>2022-09-24T05:46:54.841Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>顾名思义<ul><li>运行循环</li><li>在程序运行过程中循环做一些事情</li></ul></li><li>应用范畴<ul><li>定时器（Timer），PerformSelector</li><li>GCD Async Main Queue</li><li>事件响应，手势识别，界面刷新</li><li>网络请求</li><li>AutoreleasePool</li></ul></li></ul><blockquote><p>如果没有RunLoop，执行完13行代码之后，会退出程序</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char* argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSLog(@&quot;Hello World！&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果有了RunLoop</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//伪代码</span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        int retVal = 0;</span><br><span class="line">        do &#123;</span><br><span class="line">            // 睡眠中等待消息</span><br><span class="line">            int message = sleep_and_wait();</span><br><span class="line">            // 处理消息</span><br><span class="line">            retVal = process_message(message);</span><br><span class="line">        &#125; while (0 == retVal);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>程序并不会马上退出，而是保持运行状态<br>RunLoop的基本作用</p><ul><li>保持程序的持续运行</li><li>处理App中的各种事件（比如触摸事件、定时器事件）</li><li>节省CPU资源，提高程序性能：该做事时做事，该休息时休息</li></ul></blockquote><h2 id="RunLoop对象"><a href="#RunLoop对象" class="headerlink" title="RunLoop对象"></a>RunLoop对象</h2><ul><li>iOS中有2套API来访问和使用RunLoop<ul><li>Foundation: NSRunLoop</li><li>Core Foundation: CFRunLoopRef</li></ul></li><li>NSRunLoop和CFRunLoop都代表着RunLoop对象<ul><li>NSRunLoop是基于CFRunLoopRef的一层OC包装</li><li>CFRunLoopRef是开源的：<a href="https://opensource.apple.com/tarballs/CF/">https://opensource.apple.com/tarballs/CF/</a></li></ul></li></ul><h3 id="获取RunnLoop对象"><a href="#获取RunnLoop对象" class="headerlink" title="获取RunnLoop对象"></a>获取RunnLoop对象</h3><blockquote><p>Foundation</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[NSRunLoop currentRunLoop]; // 获得当前线程的RunLoop对象</span><br><span class="line">[NSRunLoop mainRunLoop]; // 获得主线程的RunLoop对象</span><br></pre></td></tr></table></figure><blockquote><p>Core Foundation</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopGetCurrent(); // 获得当前线程的RunLoop对象</span><br><span class="line">CFRunLoopGetMain(); // 获得主线程的RunLoop对象</span><br></pre></td></tr></table></figure><h2 id="RunLoop与线程"><a href="#RunLoop与线程" class="headerlink" title="RunLoop与线程"></a>RunLoop与线程</h2><ul><li>每条线程都有唯一的一个与之对应的RunLoop对象</li><li>RunLoop保存在一个全局的Dictionary里，线程作为key，RunLoop作为value</li><li>线程刚创建时并没有RunLoop对象，RunLoop会在第一次获取它时创建</li><li>RunLoop会在线程结束时销毁</li><li>主线程的RunLoop已经自动获取（创建），子线程默认没有开启RunLoop</li></ul><h2 id="RunLoop相关的类"><a href="#RunLoop相关的类" class="headerlink" title="RunLoop相关的类"></a>RunLoop相关的类</h2><ul><li>Core Foundation中关于RunLoop的5个类<ul><li>CFRunLoopRef</li><li>CFRunLoopModeRef</li><li>CFRunLoopSourceRef</li><li>CFRunLoopTimerRef</li><li>CFRunLoopObserverRef</li></ul></li></ul><blockquote><p>CFRunLoopRef</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct __CFRunLoop * CFRunLoopRef:</span><br><span class="line">struct __CFRunLoop &#123;</span><br><span class="line">    pthread_t _pthread;</span><br><span class="line">    CFMutableSetRef _commonModes;</span><br><span class="line">    CFMutableSetRef _commonModesItems;</span><br><span class="line">    CFMutableModeRef _currentMode;</span><br><span class="line">    CFMutableSetRef _modes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>CFRunLoopModeRef</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct __CFRunLoopMode * CFRunLoopModeRef:</span><br><span class="line">struct __CFRunLoopMode &#123;</span><br><span class="line">    CFStringRef _name;</span><br><span class="line">    CFMutableSetRef _sources0;</span><br><span class="line">    CFMutableSetRef _sources1;</span><br><span class="line">    CFMutableArrayRef _observers;</span><br><span class="line">    CFMutableArrayRef _timers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CFRunLoopModeRef"><a href="#CFRunLoopModeRef" class="headerlink" title="CFRunLoopModeRef"></a>CFRunLoopModeRef</h3><ul><li>CFRunLoopModeRef代表RunLoop的运行模式</li><li>一个RunLoop包含若干个Mode，每个Mode又包含若干个Source0&#x2F;Source1&#x2F;Timer&#x2F;Observer</li><li>RunLoop启动时只能选择其中一个Mode，作为currentMode</li><li>如果需要切换Mode，只能退出当前Loop，再重新选择一个Mode进入<ul><li>不同组的Source0&#x2F;Source1&#x2F;Timer&#x2F;Observer能分隔开来，互不影响</li></ul></li><li>如果Mode里没有任何Source0&#x2F;Source1&#x2F;Timer&#x2F;Observer，RunLoop会立马退出</li></ul><blockquote><p>常见的2种Mode</p><ul><li><code>kCFRunLoopDefaultMode（NSDefaultRunLoopMode）</code>：App的默认Mode，通常主线程是在这个Mode下运行 </li><li><code>UITrackingRunLoopMode</code>：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响</li></ul></blockquote><h3 id="CFRunLoopObserverRef"><a href="#CFRunLoopObserverRef" class="headerlink" title="CFRunLoopObserverRef"></a>CFRunLoopObserverRef</h3><blockquote><p>observer的各个状态：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* Run Loop Observer Activities */</span><br><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry = (1UL &lt;&lt; 0),           //即将进入Loop</span><br><span class="line">    kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),    //即将处理Timer</span><br><span class="line">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),   //即将处理Source</span><br><span class="line">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),   //即将进入休眠</span><br><span class="line">    kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),    //刚从休眠中唤醒</span><br><span class="line">    kCFRunLoopExit = (1UL &lt;&lt; 7),            //即将退出Loop</span><br><span class="line">    kCFRunLoopAllActivities = 0x0FFFFFFFU</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>基本使用： </p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 创建Observer</span><br><span class="line">CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, observeRunLoopActicities, NULL);</span><br><span class="line">// 添加Observer到RunLoop中</span><br><span class="line">CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);</span><br><span class="line">// 释放</span><br><span class="line">CFRelease(observer);</span><br></pre></td></tr></table></figure><h4 id="添加Observer监听RunLoop的所有状态"><a href="#添加Observer监听RunLoop的所有状态" class="headerlink" title="添加Observer监听RunLoop的所有状态"></a>添加Observer监听RunLoop的所有状态</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 创建Observer</span><br><span class="line">CFRunLoopObserverRef ob = CFRunLoopObserverCreateWithHandler(kCFAllocatorNull, kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;</span><br><span class="line">    switch (activity) &#123;</span><br><span class="line">        case kCFRunLoopEntry:</span><br><span class="line">            NSLog(@&quot;kCFRunLoopEntry&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case kCFRunLoopBeforeTimers:</span><br><span class="line">            NSLog(@&quot;kCFRunLoopBeforeTimers&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case kCFRunLoopBeforeSources:</span><br><span class="line">            NSLog(@&quot;kCFRunLoopBeforeSources&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case kCFRunLoopBeforeWaiting:</span><br><span class="line">            NSLog(@&quot;kCFRunLoopBeforeWaiting&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case kCFRunLoopAfterWaiting:</span><br><span class="line">            NSLog(@&quot;kCFRunLoopAfterWaiting&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case kCFRunLoopExit:</span><br><span class="line">            NSLog(@&quot;kCFRunLoopExit&quot;);</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">// 添加Observer到RunLoop中</span><br><span class="line">CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);</span><br><span class="line">// 释放</span><br><span class="line">CFRelease(observer);</span><br></pre></td></tr></table></figure><h2 id="RunLoop的运行逻辑"><a href="#RunLoop的运行逻辑" class="headerlink" title="RunLoop的运行逻辑"></a>RunLoop的运行逻辑</h2><ul><li>Source0<ul><li>触摸事件处理</li><li>performSelector:onThread:</li></ul></li><li>Source1<ul><li>基于Port的线程间通信</li><li>系统事件捕捉</li></ul></li><li>Timers<ul><li>NSTimer</li><li>performSelector:withObject:afterDelay:</li></ul></li><li>Observers<ul><li>用于监听RunLoop的状态</li><li>UI刷新（BeforeWaiting）</li><li>Autorelease pool（BeforeWaiting）</li></ul></li></ul><blockquote><p>底层逻辑</p></blockquote><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><blockquote><p>CFRunLoop.h文件<br>CFRunLoopRunSpecific（精简源码）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SInt32 CFRunLoopRunSpecific(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) &#123;     /* DOES CALLOUT */</span><br><span class="line">    __CFRunLoopLock(rl);</span><br><span class="line">    </span><br><span class="line">    // 通知Observers：进入Loop</span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</span><br><span class="line">    </span><br><span class="line">    // 具体要做的事情</span><br><span class="line">    result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</span><br><span class="line">    </span><br><span class="line">    //通知Observers：退出Loop</span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">    </span><br><span class="line">    __CFRunLoopUnlock(rl);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>__CFRunLoopRun（精简源码）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123;</span><br><span class="line">    int32_t retVal = 0;</span><br><span class="line">    do &#123;</span><br><span class="line">        // 通知Observers: 即将处理Timers</span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class="line">        // 通知Observers: 即将处理Sources</span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</span><br><span class="line">        </span><br><span class="line">        //处理Blocks</span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line"></span><br><span class="line">        //处理Source0</span><br><span class="line">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br><span class="line">        if (sourceHandledThisLoop) &#123;</span><br><span class="line">            //处理Blocks</span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断有无Source1</span><br><span class="line">    if (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg_buffer), &amp;livePort, 0, &amp;voucherState, NULL)) &#123;</span><br><span class="line">    </span><br><span class="line">        //如果有Source1,就跳转handle_msg</span><br><span class="line">        goto handle_msg;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    // 通知Observers: 即将休眠</span><br><span class="line">    __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class="line">    // 通知Observers: 开始休眠</span><br><span class="line">    __CFRunLoopSetSleeping(rl);</span><br><span class="line">        </span><br><span class="line">    // 等待别的消息来唤醒当前线程</span><br><span class="line">    __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</span><br><span class="line">    </span><br><span class="line">    __CFRunLoopUnsetSleeping(rl);</span><br><span class="line">    // 通知Observers: 结束休眠</span><br><span class="line">    __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</span><br><span class="line"></span><br><span class="line">handle_msg:;</span><br><span class="line">    if (被timers唤醒) &#123;</span><br><span class="line">        // 处理Timers</span><br><span class="line">        __CFRunLoopDoTimers(rl, rlm, mach_absolute_time()))</span><br><span class="line">    &#125; else if (livePort == dispatchPort) &#123;//被gcd唤醒</span><br><span class="line">        // 处理GCD</span><br><span class="line">        __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">    &#125; else &#123;//被Source1唤醒</span><br><span class="line">        // 处理Source1</span><br><span class="line">        __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</span><br><span class="line">    &#125;</span><br><span class="line">    //处理Blocks</span><br><span class="line">    __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">    // 设置返回值</span><br><span class="line">    if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">        retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">        &#125; else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">    &#125; else if (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">            __CFRunLoopUnsetStopped(rl);</span><br><span class="line">        retVal = kCFRunLoopRunStopped;</span><br><span class="line">    &#125; else if (rlm-&gt;_stopped) &#123;</span><br><span class="line">        rlm-&gt;_stopped = false;</span><br><span class="line">        retVal = kCFRunLoopRunStopped;</span><br><span class="line">    &#125; else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</span><br><span class="line">        retVal = kCFRunLoopRunFinished;</span><br><span class="line">    &#125;</span><br><span class="line">        voucher_mach_msg_revert(voucherState);</span><br><span class="line">        os_release(voucherCopy);</span><br><span class="line"></span><br><span class="line">    &#125; while (0 == retVal);</span><br><span class="line"></span><br><span class="line">    return retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>流程描述：</p><ul><li>01、通知Observers：进入Loop</li><li>02、通知Observers：即将处理Timers</li><li>03、通知Observers：即将处理Sources</li><li>04、处理Blocks</li><li>05、处理Source0（可能会再次处理Blocks）</li><li>06、如果存在Source1，就跳转到第8步</li><li>07、通知Observers：开始休眠（等待消息唤醒）</li><li>08、通知Observers：结束休眠（被某个消息唤醒）<ul><li>01 处理Timer</li><li>02 处理GCD Async To Main Queue</li><li>03 处理Source1</li></ul></li><li>09、处理Blocks</li><li>10、根据前面的执行结果，决定如何操作<ul><li>01 回到第02步</li><li>02 退出Loop</li></ul></li><li>11、通知Observers：退出Loop</li></ul></blockquote><h2 id="RunLoop在实际开中的应用"><a href="#RunLoop在实际开中的应用" class="headerlink" title="RunLoop在实际开中的应用"></a>RunLoop在实际开中的应用</h2><ul><li>控制线程生命周期（线程保活）</li><li>解决NSTimer在滑动时停止工作的问题</li><li>监控应用卡顿</li><li>性能优化</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;顾名思义&lt;ul&gt;
&lt;li&gt;运行循环&lt;/li&gt;
&lt;li&gt;在程序运行过程中循环做一些事情&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Objective-C" scheme="http://www.hxtec.top/tags/Objective-C/"/>
    
    <category term="底层原理" scheme="http://www.hxtec.top/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    <category term="Runloop" scheme="http://www.hxtec.top/tags/Runloop/"/>
    
  </entry>
  
  <entry>
    <title>Runtime - API及应用</title>
    <link href="http://www.hxtec.top/2022/09/22/Runtime-API%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    <id>http://www.hxtec.top/2022/09/22/Runtime-API%E5%8F%8A%E5%BA%94%E7%94%A8/</id>
    <published>2022-09-22T11:35:53.000Z</published>
    <updated>2022-09-22T14:25:40.649Z</updated>
    
    <content type="html"><![CDATA[<h2 id="API-01-类"><a href="#API-01-类" class="headerlink" title="API-01-类"></a>API-01-类</h2><blockquote><p>动态创建一个类（参数：父类，类名，额外的内存空间）<br>Class objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)</p></blockquote><blockquote><p>注册一个类（要在类注册之前添加成员变量）<br>void objc_registerClassPair(Class cls)</p></blockquote><blockquote><p>销毁一个类<br>void objc_disposeClassPair(Class cls)</p></blockquote><blockquote><p>获取isa指向的Class<br>Class object_getClass(id obj)</p></blockquote><blockquote><p>设置isa指向的Class<br>Class object_setClass(id obj, Class cls)</p></blockquote><blockquote><p>判断一个OC对象是否为Class<br>BOOL object_isClass(id obj)</p></blockquote><blockquote><p>判断一个Class是否为元类<br>BOOL class_isMetaClass(Class cls)</p></blockquote><blockquote><p>获取父类<br>Class class_getSuperclass(Class cls)</p></blockquote><blockquote><p>示例：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 创建类</span><br><span class="line">Class newClass = objc_allocateClassPair([NSObject class], &quot;Dog&quot;, 0);</span><br><span class="line"></span><br><span class="line">//添加成员变量</span><br><span class="line">class_addIvar(newClass, &quot;_age&quot;, 4, 1, @encode(int));</span><br><span class="line">class_addIvar(newClass, &quot;_weight&quot;, 4, 1, @encode(int));</span><br><span class="line"></span><br><span class="line">//添加方法</span><br><span class="line">class_addMethod(newClass, @selector(run), (IMP)run, &quot;v@:&quot;);</span><br><span class="line"></span><br><span class="line">// 注册类</span><br><span class="line">objc_registerClassPair(newClass);</span><br><span class="line"></span><br><span class="line">// 在不需要这个类时释放</span><br><span class="line">objc_disposeClassPair(newClass);</span><br><span class="line"></span><br><span class="line">Person *person = [[Person alloc] init];</span><br><span class="line">[person run];</span><br><span class="line">//设置isa指向的Class</span><br><span class="line">object_setClass(person, [Car class]);</span><br><span class="line">[person run];</span><br><span class="line"></span><br><span class="line">//判断一个OC对象是否为Class</span><br><span class="line">NSLog(@&quot;%d %d %d&quot;,</span><br><span class="line">      object_isClass(person),</span><br><span class="line">      object_isClass([Person class]),</span><br><span class="line">      object_isClass(object_getClass([Person class]))</span><br><span class="line">      );</span><br></pre></td></tr></table></figure><h2 id="API-02-成员变量"><a href="#API-02-成员变量" class="headerlink" title="API-02-成员变量"></a>API-02-成员变量</h2><blockquote><p>获取一个实例变量信息<br>Ivar class_getInstanceVariable(Class cls, const char *name)</p></blockquote><blockquote><p>拷贝实例变量列表（最后需要调用free释放）<br>Ivar *class_copyIvarList(Class cls, unsigned int *outCount)</p></blockquote><blockquote><p>设置和获取成员变量的值<br>void object_setIvar(id obj, Ivar ivar, id value)<br>id object_getIvar(id obj, Ivar ivar)</p></blockquote><blockquote><p>动态添加成员变量（已经注册的类是不能动态添加成员变量的）<br>BOOL class_addIvar(Class cls, const char * name, size_t size, uint8_t alignment, const char * types)</p></blockquote><blockquote><p>获取成员变量的相关信息<br>const char *ivar_getName(Ivar v)<br>const char *ivar_getTypeEncoding(Ivar v)</p></blockquote><blockquote><p>示例：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//获取成员变量信息</span><br><span class="line">var ageIvar = class_getInstanceVariable([Person class], &quot;_age&quot;);</span><br><span class="line">NSLog(@&quot;%s %s&quot;, ivar_getName(ageIvar), ivar_getTypeEncoding(ageIvar));</span><br><span class="line"></span><br><span class="line">// 设置和获取成员变量的值</span><br><span class="line">Ivar nameIvar = class_getInstanceVariable([Person class], &quot;_name&quot;);</span><br><span class="line"></span><br><span class="line">Person *person = [[Person alloc] init];</span><br><span class="line">object_setIvar(person, nameIvar, @&quot;123&quot;);</span><br><span class="line">object_setIvar(person, ageIvar, (__bridge id)(void *)10);</span><br><span class="line">NSLog(@&quot;%@ %d&quot;, person.name, person.age);</span><br><span class="line"></span><br><span class="line">// 成员变量的数量</span><br><span class="line">unsigned int count;</span><br><span class="line">Ivar *ivars = class_copyIvarList([Person class], &amp;count);</span><br><span class="line">for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">    // 取出i位置的成员变量</span><br><span class="line">    Ivar ivar = ivars[i];</span><br><span class="line">    NSLog(@&quot;%s %s&quot;, ivar_getName(ivar), ivar_getTypeEncoding(ivar));</span><br><span class="line">&#125;</span><br><span class="line">free(ivars);</span><br></pre></td></tr></table></figure><h2 id="API-03-属性"><a href="#API-03-属性" class="headerlink" title="API-03-属性"></a>API-03-属性</h2><blockquote><p>获取一个属性<br>objc_property_t class_getProperty(Class cls, const char *name)</p></blockquote><blockquote><p>拷贝属性列表（最后需要调用free释放）<br>objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount)</p></blockquote><blockquote><p>动态添加属性<br>BOOL class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attributes,<br>                  unsigned int attributeCount)</p></blockquote><blockquote><p>动态替换属性<br>void class_replaceProperty(Class cls, const char *name, const objc_property_attribute_t *attributes,<br>                      unsigned int attributeCount)</p></blockquote><blockquote><p>获取属性的一些信息<br>const char *property_getName(objc_property_t property)<br>const char *property_getAttributes(objc_property_t property)</p></blockquote><blockquote><p>示例：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">unsigned int count;</span><br><span class="line">Ivar *ivars = class_copyIvarList([UITextField class], &amp;count);</span><br><span class="line">for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">    // 取出i位置的成员变量</span><br><span class="line">    Ivar ivar = ivars[i];</span><br><span class="line">    NSLog(@&quot;%s %s&quot;, ivar_getName(ivar), ivar_getTypeEncoding(ivar));</span><br><span class="line">&#125;</span><br><span class="line">free(ivars);</span><br><span class="line"></span><br><span class="line">//下面的使用方法已经废弃，仅供参考</span><br><span class="line">self.textField.placeholder = @&quot;请输入用户名&quot;;</span><br><span class="line">[self.textField setValue:[UIColor redColor] forKeyPath:@&quot;_placeholderLabel.textColor&quot;];</span><br></pre></td></tr></table></figure><h2 id="API-04-方法"><a href="#API-04-方法" class="headerlink" title="API-04-方法"></a>API-04-方法</h2><blockquote><p>获得一个实例方法、类方法<br>Method class_getInstanceMethod(Class cls, SEL name)<br>Method class_getClassMethod(Class cls, SEL name)</p></blockquote><blockquote><p>方法实现相关操作<br>IMP class_getMethodImplementation(Class cls, SEL name)<br>IMP method_setImplementation(Method m, IMP imp)<br>void method_exchangeImplementations(Method m1, Method m2) </p></blockquote><blockquote><p>拷贝方法列表（最后需要调用free释放）<br>Method *class_copyMethodList(Class cls, unsigned int *outCount)</p></blockquote><blockquote><p>动态添加方法<br>BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)</p></blockquote><blockquote><p>动态替换方法<br>IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types)</p></blockquote><blockquote><p>获取方法的相关信息（带有copy的需要调用free去释放）<br>SEL method_getName(Method m)<br>IMP method_getImplementation(Method m)<br>const char *method_getTypeEncoding(Method m)<br>unsigned int method_getNumberOfArguments(Method m)<br>char *method_copyReturnType(Method m)<br>char *method_copyArgumentType(Method m, unsigned int index)</p></blockquote><blockquote><p>选择器相关<br>const char *sel_getName(SEL sel)<br>SEL sel_registerName(const char *str)</p></blockquote><blockquote><p>用block作为方法实现<br>IMP imp_implementationWithBlock(id block)<br>id imp_getBlock(IMP anImp)<br>BOOL imp_removeBlock(IMP anImp)</p></blockquote><blockquote><p>示例：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Person *person = [[Person alloc] init];</span><br><span class="line">//    class_replaceMethod([MJPerson class], @selector(run), (IMP)myrun, &quot;v&quot;);</span><br><span class="line">//block的形式</span><br><span class="line">class_replaceMethod([Person class], @selector(run), imp_implementationWithBlock(^&#123;</span><br><span class="line">    NSLog(@&quot;123&quot;);</span><br><span class="line">&#125;), &quot;v&quot;);</span><br><span class="line">[person run];</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>示例：方法交换</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Person *person = [[Person alloc] init];</span><br><span class="line"></span><br><span class="line">Method runMethod = class_getInstanceMethod([MJPerson class], @selector(run));</span><br><span class="line">Method testMethod = class_getInstanceMethod([MJPerson class], @selector(test));</span><br><span class="line">method_exchangeImplementations(runMethod, testMethod);</span><br><span class="line"></span><br><span class="line">[person run];</span><br></pre></td></tr></table></figure><h2 id="高频面试题"><a href="#高频面试题" class="headerlink" title="高频面试题"></a>高频面试题</h2><blockquote><p>讲一下 OC 的消息机制<br>OC中的方法调用其实都是转成了objc_msgSend函数的调用，给receiver（方法调用者）发送了一条消息（selector方法名）<br>objc_msgSend底层有3大阶段<br>消息发送（当前类、父类中查找）、动态方法解析、消息转发</p></blockquote><blockquote><p>什么是Runtime？平时项目中有用过么？<br>OC是一门动态性比较强的编程语言，允许很多操作推迟到程序运行时再进行<br>OC的动态性就是由Runtime来支撑和实现的，Runtime是一套C语言的API，封装了很多动态性相关的函数<br>平时编写的OC代码，底层都是转换成了Runtime API进行调用<br>具体应用<br>利用关联对象（AssociatedObject）给分类添加属性<br>遍历类的所有成员变量（修改textfield的占位文字颜色、字典转模型、自动归档解档）<br>交换方法实现（交换系统的方法）<br>利用消息转发机制解决方法找不到的异常问题<br>……</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;API-01-类&quot;&gt;&lt;a href=&quot;#API-01-类&quot; class=&quot;headerlink&quot; title=&quot;API-01-类&quot;&gt;&lt;/a&gt;API-01-类&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;动态创建一个类（参数：父类，类名，额外的内存空间）&lt;br&gt;Clas</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Objective-C" scheme="http://www.hxtec.top/tags/Objective-C/"/>
    
    <category term="底层原理" scheme="http://www.hxtec.top/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    <category term="Runtime" scheme="http://www.hxtec.top/tags/Runtime/"/>
    
  </entry>
  
  <entry>
    <title>Runtime - 消息发送机制</title>
    <link href="http://www.hxtec.top/2022/09/22/Runtime-%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E6%9C%BA%E5%88%B6/"/>
    <id>http://www.hxtec.top/2022/09/22/Runtime-%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E6%9C%BA%E5%88%B6/</id>
    <published>2022-09-22T10:38:49.000Z</published>
    <updated>2022-09-22T11:33:51.210Z</updated>
    
    <content type="html"><![CDATA[<h2 id="objc-msgSend执行流程"><a href="#objc-msgSend执行流程" class="headerlink" title="objc_msgSend执行流程"></a>objc_msgSend执行流程</h2><ul><li>OC中的方法调用，其实都是转换为objc_msgSend函数的调用</li><li>objc_msgSend的执行流程可以分为3大阶段<ul><li>消息发送</li><li>动态方法解析</li><li>消息转发</li></ul></li></ul><h3 id="源码跟读"><a href="#源码跟读" class="headerlink" title="源码跟读"></a>源码跟读</h3><blockquote><p>objc-msg-arm64.s</p><ul><li>ENTRY _objc_msgSend</li><li>b.le    LNilOrTagged</li><li>CacheLookup NORMAL</li><li>.macro CacheLookup</li><li>.macro CheckMiss</li><li>STATIC_ENTRY __objc_msgSend_uncached</li><li>.macro MethodTableLookup</li><li>__class_lookupMethodAndLoadCache3</li></ul></blockquote><blockquote><p>objc-runtime-new.mm</p><ul><li>_class_lookupMethodAndLoadCache3</li><li>lookUpImpOrForward</li><li>getMethodNoSuper_nolock、search_method_list、log_and_fill_cache</li><li>cache_getImp、log_and_fill_cache、getMethodNoSuper_nolock、log_and_fill_cache</li><li>_class_resolveInstanceMethod</li><li>_objc_msgForward_impcache</li></ul></blockquote><blockquote><p>objc-msg-arm64.s</p><ul><li>STATIC_ENTRY __objc_msgForward_impcache</li><li>ENTRY __objc_msgForward</li></ul></blockquote><blockquote><p>Core Foundation</p><ul><li>__forwarding__（不开源）</li></ul></blockquote><h3 id="消息发送-objc-msgSend执行流程1"><a href="#消息发送-objc-msgSend执行流程1" class="headerlink" title="消息发送 - objc_msgSend执行流程1"></a>消息发送 - objc_msgSend执行流程1</h3><ul><li>receiver是否为nil<ul><li>是，退出</li><li>否<ul><li>从receiverClass的cache中查找方法<ul><li>找到方法 -&gt; 调用方法结束查找</li><li>没有找到方法<ul><li>从receiverClass的<code>class_rw_t</code>中查找方法<ul><li>找到方法 -&gt; 调用方法结束查找，并将方法缓存到receiverClass的cache中</li><li>未找到方法<ul><li>从superClass的<code>cache</code>中查找方法<ul><li>找到方法 -&gt; 调用方法结束查找，并将方法缓存到receiverClass的cache中</li><li>未找到方法<ul><li>从<code>superClass</code>的cache中查找方法<ul><li>找到方法 -&gt; 调用方法结束查找，并将方法缓存到receiverClass的cache中</li><li>未找到方法<ul><li>上层是否还有<code>superClass</code><ul><li>是，继续 从superClass的cache中查找方法</li><li>否，进入 <code>动态方法解析</code> 阶段</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li>如果是从class_rw_t中查找方法<ul><li>已经排序的，二分查找</li><li>没有排序的，遍历查找</li></ul></li><li>receiver通过isa指针找到receiverClass</li><li>receiverClass通过superClass指针找到superClass</li></ul><h3 id="动态方法解析-objc-msgSend执行流程2"><a href="#动态方法解析-objc-msgSend执行流程2" class="headerlink" title="动态方法解析 - objc_msgSend执行流程2"></a>动态方法解析 - objc_msgSend执行流程2</h3><ul><li>是否曾经有动态解析<ul><li>是，进入 <code>消息转发</code> 阶段</li><li>否<ul><li>调用+resolveInstanceMethod:或者+resolveClassMethod:方法来动态解析方法</li><li>标记为已经动态解析</li><li>消息发送</li></ul></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void other(id self, SEL _cmd) &#123;</span><br><span class="line">    NSLog(@&quot;%@ - %s - %@&quot;, self, sel_getName(_cmd), __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    if (sel == @selector(test)) &#123;</span><br><span class="line">        Method method = class_getInstanceMethod(self, @selector(other));</span><br><span class="line">        class_addMethod(self,</span><br><span class="line">                        sel,</span><br><span class="line">                        method_getImplementation(method),</span><br><span class="line">                        method_getTypeEncoding(method));</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>开发者可以实现以下方法，来动态添加方法实现</p><ul><li>+resolveInstanceMethod:</li><li>+resolveClassMethod:</li></ul></blockquote><blockquote><p>动态解析过后，会重新走“消息发送”的流程<br>“从<code>receiverClass的cache</code>中查找方法”这一步开始执行</p></blockquote><h3 id="消息转发-objc-msgSend执行流程3"><a href="#消息转发-objc-msgSend执行流程3" class="headerlink" title="消息转发 - objc_msgSend执行流程3"></a>消息转发 - objc_msgSend执行流程3</h3><ul><li>调用 <code>forwardingTargetForSelector:</code> 方法<ul><li>返回值不为nil -&gt; objc_msgSend(返回值， SEL)</li><li>返回值为nil<ul><li>调用 <code>methodSignatureForSelector:</code> 方法<ul><li>返回值不为nil 调用 <code>forwardInvocation:</code> 方法</li><li>返回值为nil<ul><li>调用<code>doesNotRecognizedSelector:</code>方法（常见的方法找不到错误）</li></ul></li></ul></li></ul></li></ul></li></ul><blockquote><p>示例：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    if (aSelector == @selector(test)) return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];</span><br><span class="line">    return [super methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class="line">    NSLog(&quot;可以作任何处理...&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>开发者可以在<code>forwardInvocation:</code>方法中自定义任何逻辑<br>且：以上方法都有对象方法、类方法2个版本（前面可以是加号+，也可以是减号-）</p></blockquote><blockquote><p>补充：<br><code>@dynamic</code>是告诉编译器不用自动生成getter和setter的实现，等到运行时再添加方法实现</p></blockquote><h2 id="Super的本质"><a href="#Super的本质" class="headerlink" title="Super的本质"></a>Super的本质</h2><ul><li>super调用，底层会转换为objc_msgSendSuper2函数的调用，接收2个参数<ul><li>struct objc_super2</li><li>SEL</li></ul></li></ul><blockquote><p>结构体如下：</p><ul><li>receiver是消息接收者</li><li>current_class是recevier的class对象</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct objc_super2 &#123;</span><br><span class="line">    id receiver;</span><br><span class="line">    Class current_class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LLVM的中间代码（IR）"><a href="#LLVM的中间代码（IR）" class="headerlink" title="LLVM的中间代码（IR）"></a>LLVM的中间代码（IR）</h2><ul><li>Objective-C在变为机器代码之前，会被LLVM编译器转换为中间代码（Intermediate Representation）</li></ul><blockquote><p>可以使用以下命令行指令生成中间代码</p><ul><li>clang -emit-llvm -S main.m</li></ul></blockquote><blockquote><p>语法简介<br>@ - 全局变量<br>% - 局部变量<br>alloca - 在当前执行的函数的堆栈帧中分配内存，当该函数返回到其调用者时，将自动释放内存<br>i32 - 32位4字节的整数<br>align - 对齐<br>load - 读出，store 写入<br>icmp - 两个整数值比较，返回布尔值<br>br - 选择分支，根据条件来转向label，不根据条件跳转的话类似 goto<br>label - 代码标签<br>call - 调用函数</p></blockquote><ul><li>具体可以参考官方文档：<a href="https://llvm.org/docs/LangRef.html">https://llvm.org/docs/LangRef.html</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;objc-msgSend执行流程&quot;&gt;&lt;a href=&quot;#objc-msgSend执行流程&quot; class=&quot;headerlink&quot; title=&quot;objc_msgSend执行流程&quot;&gt;&lt;/a&gt;objc_msgSend执行流程&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;OC中的方法调用</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Objective-C" scheme="http://www.hxtec.top/tags/Objective-C/"/>
    
    <category term="底层原理" scheme="http://www.hxtec.top/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    <category term="Runtime" scheme="http://www.hxtec.top/tags/Runtime/"/>
    
  </entry>
  
  <entry>
    <title>Runtime理解</title>
    <link href="http://www.hxtec.top/2022/09/22/Runtime%E7%90%86%E8%A7%A3/"/>
    <id>http://www.hxtec.top/2022/09/22/Runtime%E7%90%86%E8%A7%A3/</id>
    <published>2022-09-22T09:26:52.000Z</published>
    <updated>2022-09-22T10:39:22.937Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>Object-C是一门动态性比较强的编程语言，跟C，C++等语言有着很大的不同</li><li>Object-C的动态性是由Runtime API来支撑的</li><li>Runtime API提供的接口基本都是C语言的，源码由C&#x2F;C++&#x2F;汇编编写</li></ul><h2 id="isa详解"><a href="#isa详解" class="headerlink" title="isa详解"></a>isa详解</h2><ul><li>学习Runtime，首先了解底层的常用数据结构，比如<code>iso</code>指针</li><li>在arm64架构之前，isa就是一个普通的指针，存储着Class，Meta-Class对象的内存地址</li><li>从arm64架构开始，对isa进行了优化，变成了一个共用体（union）结构，还使用位域来存储更多的信息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">union isa_t &#123;</span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">    struct &#123;</span><br><span class="line">        uintptr_t nonpointer                : 1;</span><br><span class="line">        uintptr_t has_assoc                 : 1;</span><br><span class="line">        uintptr_t has_cxx_dtor              : 1;</span><br><span class="line">        uintptr_t shiftcls                  : 33;</span><br><span class="line">        uintptr_t magic                     : 6;</span><br><span class="line">        uintptr_t weakly_referenced         : 1;</span><br><span class="line">        uintptr_t deallocating              : 1;</span><br><span class="line">        uintptr_t has_sidetable_rc          : 1;</span><br><span class="line">        uintptr_t extra_rc                  : 19;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="isa详解-位域"><a href="#isa详解-位域" class="headerlink" title="isa详解 - 位域"></a>isa详解 - 位域</h3><ul><li>nonpointer<ul><li>0，代表普通的指针，存储着Class、Meta-Class对象的内存地址</li><li>1，代表优化过，使用位域存储更多的信息</li></ul></li><li>has_assoc<ul><li>是否有设置过关联对象，如果没有，释放时会更快</li></ul></li><li>has_cxx_dtor<ul><li>是否有C++的析构函数（.cxx_destruct），如果没有，释放时会更快</li></ul></li><li>shiftcls<ul><li>存储着Class、Meta-Class对象的内存地址信息</li></ul></li><li>magic<ul><li>用于在调试时分辨对象是否未完成初始化</li></ul></li><li>weakly_referenced<ul><li>是否有被弱引用指向过，如果没有，释放时会更快</li></ul></li><li>deallocating<ul><li>对象是否正在释放</li></ul></li><li>extra_rc<ul><li>里面存储的值是引用计数器减1</li></ul></li><li>has_sidetable_rc<ul><li>引用计数器是否过大无法存储在isa中</li><li>如果为1，那么引用计数会存储在一个叫SideTable的类的属性中</li></ul></li></ul><h2 id="Class的结构"><a href="#Class的结构" class="headerlink" title="Class的结构"></a>Class的结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct objc_object &#123;</span><br><span class="line">private:</span><br><span class="line">    isa_t isa;</span><br><span class="line">public:</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">&#125;</span><br><span class="line">struct objc_class : objc_object &#123;</span><br><span class="line">    // Class ISA;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;            // 方法缓存</span><br><span class="line">    class_data_bits_t bits;  // 用于获取具体的类信息  &amp;FAST_DATA_MASK</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>bits &amp;FAST_DATA_MASK，可以得到class_rw_t</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct class_rw_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t version;</span><br><span class="line">    const class_ro_t *ro;</span><br><span class="line">    method_array_t methods;      //方法列表</span><br><span class="line">    property_array_t properties; //属性列表</span><br><span class="line">    protocol_array_t protocols;  //协议列表</span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line">    char *demangledName;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>class_ro_t的内容如下：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct class_ro_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t instanceStart;</span><br><span class="line">    uint32_t instanceSize;  // instance对象占用的内存空间</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    uint32_t reserved;</span><br><span class="line">#endif</span><br><span class="line">    const uint8_t * ivarLayout;</span><br><span class="line">    const char * name;// 类名</span><br><span class="line">    method_list_t * baseMethodList;</span><br><span class="line">    protocol_list_t * baseProtocols;</span><br><span class="line">    const ivar_list_t * ivars;//成员变量列表</span><br><span class="line">    const uint8_t * weakIvarLayout;</span><br><span class="line">    property_list_t *baseProperties;</span><br><span class="line">    method_list_t *baseMethods() const &#123;</span><br><span class="line">        return baseMethodList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="class-rw-t"><a href="#class-rw-t" class="headerlink" title="class_rw_t"></a>class_rw_t</h3><blockquote><p>class_rw_t里面的methos, properties, protocols是二维数组，是可读可写的，包含了类的初始内容、分类的内容</p><ul><li>methods里面包含多个method_list_t</li><li>method_list_t里面包含多个method_t</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method_array_t methods; -&gt; method_list_t -&gt; method_t</span><br></pre></td></tr></table></figure><h3 id="class-ro-t"><a href="#class-ro-t" class="headerlink" title="class_ro_t"></a>class_ro_t</h3><blockquote><p>class_ro_t里面的baseMethodList，baseProtocols，ivars，baseProperties是一维数组，是只读的，包含了类的初始内容</p><ul><li>baseMethodList里面包含多个method_t</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method_list_t * baseMethodList; -&gt; method_t</span><br></pre></td></tr></table></figure><h3 id="method-t"><a href="#method-t" class="headerlink" title="method_t"></a>method_t</h3><blockquote><p>method_t是对方法&#x2F;函数的封装</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct method_t &#123;</span><br><span class="line">    SEL name;   //函数名</span><br><span class="line">    const char *types;  //编码（返回值类型、参数类型）</span><br><span class="line">    IMP imp;    //指向函数的指针（函数地址）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>IMP代表函数的具体表现</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...);</span><br></pre></td></tr></table></figure><blockquote><p>SEL代表方法&#x2F;函数名，一般叫做选择器，底层结构跟char*类似</p><ul><li>可以通过@selector()和sel_registerName()获得</li><li>可以通过sel_getName()和NSStringFromSelector()转成字符串</li><li>不同类中相同名字的方法，所对应的方法选择器是相同的</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_selector *SEL;</span><br></pre></td></tr></table></figure><blockquote><p>types包含了函数返回值、参数编码的字符串</p></blockquote><h3 id="cache-t-方法缓存"><a href="#cache-t-方法缓存" class="headerlink" title="cache_t - 方法缓存"></a>cache_t - 方法缓存</h3><blockquote><p>Class内部结构中有个方法缓存（cache_t），用散列表（哈希表）来缓存曾经调用过的方法，可以提高方法的查找速度</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct cache_t &#123;</span><br><span class="line">    struct bucket_t *_buckets;//散列表</span><br><span class="line">    mask_t _mask;//散列表的长度 -1</span><br><span class="line">    mask_t _occupied;//已经缓存的方法数量</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    struct bucket_t *buckets();</span><br><span class="line">    mask_t mask();</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>_buckets里面存放着许多bucket_t，bucket_t结构如下：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct bucket_t &#123;</span><br><span class="line">private:</span><br><span class="line">    cache_key_t _key;// SEL作为key</span><br><span class="line">    IMP _imp;//函数的内存地址</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    inline cache_key_t key() const &#123; return _key; &#125;</span><br><span class="line">    inline IMP imp() const &#123; return (IMP)_imp; &#125;</span><br><span class="line">    inline void setKey(cache_key_t newKey) &#123; _key = newKey; &#125;</span><br><span class="line">    inline void setImp(IMP newImp) &#123; _imp = newImp; &#125;</span><br><span class="line"></span><br><span class="line">    void set(cache_key_t newKey, IMP newImp);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>缓存查找，利用空间换时间的缓存机制<br>objc-cache.mm文件<br>bucket_t * cache_t::find(cache_key_t k, id receiver)</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">bucket_t * cache_t::find(cache_key_t k, id receiver)</span><br><span class="line">&#123;</span><br><span class="line">    assert(k != 0);</span><br><span class="line"></span><br><span class="line">    bucket_t *b = buckets();</span><br><span class="line">    mask_t m = mask();</span><br><span class="line">    mask_t begin = cache_hash(k, m);</span><br><span class="line">    mask_t i = begin;</span><br><span class="line">    do &#123;</span><br><span class="line">        if (b[i].key() == 0  ||  b[i].key() == k) &#123;</span><br><span class="line">            return &amp;b[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while ((i = cache_next(i, m)) != begin);</span><br><span class="line"></span><br><span class="line">    // hack</span><br><span class="line">    Class cls = (Class)((uintptr_t)this - offsetof(objc_class, cache));</span><br><span class="line">    cache_t::bad_cache(receiver, (SEL)k, cls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Object-C是一门动态性比较强的编程语言，跟C，C++等语言有着很大的不同&lt;/li&gt;
&lt;li&gt;Object-C的动态性是由R</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Objective-C" scheme="http://www.hxtec.top/tags/Objective-C/"/>
    
    <category term="底层原理" scheme="http://www.hxtec.top/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    <category term="Runtime" scheme="http://www.hxtec.top/tags/Runtime/"/>
    
  </entry>
  
  <entry>
    <title>Swift-响应式编程</title>
    <link href="http://www.hxtec.top/2022/09/19/Swift-%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>http://www.hxtec.top/2022/09/19/Swift-%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/</id>
    <published>2022-09-19T03:05:44.000Z</published>
    <updated>2022-09-19T04:09:18.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>响应式编程（Reactive Programming, 简称RP）<ul><li>一种编程范式，于1997年提出，可以简化异步编程，提供更优雅的数据绑定</li><li>一般与函数式融合在一起，所以也会叫做：函数响应式编程（Functional Reactive Programming, 简称FRP）</li></ul></li><li>比较著名的、成熟的响应式编程<ul><li>ReactiveCocoa，简称RAC，有OC，Swift版本<ul><li>官网： <a href="http://reactivecocoa.io/">http://reactivecocoa.io/</a></li><li>github：<a href="https://github.com/ReactiveCocoa">https://github.com/ReactiveCocoa</a></li></ul></li><li>ReactiveX，简称Rx，有众多编程语言版本，比如：RxJava, RxKotlin, RxJS, RxCpp, RxPHP, RxGo, RxSwift等等.<ul><li>官网：<a href="http://reactivex.io/">http://reactivex.io/</a></li><li>github： <a href="https://github.com/ReactiveX">https://github.com/ReactiveX</a></li></ul></li></ul></li></ul><h3 id="RxSwift"><a href="#RxSwift" class="headerlink" title="RxSwift"></a>RxSwift</h3><ul><li>RxSwift(ReactiveX for Swift)，ReactiveX的Swift版本<ul><li>源码：<a href="https://github.com/ReactiveX/RxSwift">https://github.com/ReactiveX/RxSwift</a></li><li>中文文档： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/">https://beeth0ven.github.io/RxSwift-Chinese-Documentation/</a></li></ul></li><li>模块说明<ul><li>RxSwift：Rx标准API的Swift实现，不包括任何iOS相关的内容</li><li>RxCocoa：基于RxSwift，给iOS UI控件扩展了很多Rx特性</li></ul></li></ul><h3 id="RxSwift的核心角色"><a href="#RxSwift的核心角色" class="headerlink" title="RxSwift的核心角色"></a>RxSwift的核心角色</h3><ul><li>Observable：负责发送事件（Event）</li><li>Observer：负责订阅Observable，监听Observable发送的事件（Event）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public enum Event&lt;Element&gt; &#123;</span><br><span class="line">    /// Next element is produced.</span><br><span class="line">    case next(Element)</span><br><span class="line">    </span><br><span class="line">    /// Sequence terminated with an error.</span><br><span class="line">    case error(Swift.Error)</span><br><span class="line">    </span><br><span class="line">    /// Sequence completed successfully.</span><br><span class="line">    case completed</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li>Event有3种 <ul><li>next：携带具体数据</li><li>error：携带错误信息，表明Observable终止，不会再发出事件</li><li>completed：表明Observable终止，不会再发出事件</li></ul></li></ul><blockquote><p>创建、订阅Observable示例1</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">var observable = Observable&lt;Int&gt;.create &#123; observer in</span><br><span class="line">    observer.onNext(1)</span><br><span class="line">    observer.onCompleted()</span><br><span class="line">    return Disposables.create()</span><br><span class="line">&#125;</span><br><span class="line">// 等价于</span><br><span class="line">observable = Observable.just(1)</span><br><span class="line">observable = Observable.of(1)</span><br><span class="line">observable = Observable.from([1])</span><br><span class="line"></span><br><span class="line">var observable = Observable&lt;Int&gt;.create &#123; observer in</span><br><span class="line">    observer.onNext(1)</span><br><span class="line">    observer.onNext(2)</span><br><span class="line">    observer.onNext(3)</span><br><span class="line">    observer.onCompleted()</span><br><span class="line">    return Disposables.create()</span><br><span class="line">&#125;</span><br><span class="line">// 等价于</span><br><span class="line">observable = Observable.of(1, 2, 3)</span><br><span class="line">observable = Observable.from([1, 2, 3])</span><br><span class="line"></span><br><span class="line">observable.subscribe &#123; event in</span><br><span class="line">    print(event)</span><br><span class="line">&#125;.dispose()</span><br><span class="line"></span><br><span class="line">observable.subscribe(onNext: &#123;</span><br><span class="line">    print(&quot;next&quot;, $0)</span><br><span class="line">&#125;, onError: &#123;</span><br><span class="line">    print(&quot;error&quot;, $0)</span><br><span class="line">&#125;, onCompleted: &#123;</span><br><span class="line">    print(&quot;completed&quot;)</span><br><span class="line">&#125;, onDisposed: &#123;</span><br><span class="line">    print(&quot;dispose&quot;)</span><br><span class="line">&#125;).dispose()</span><br></pre></td></tr></table></figure><blockquote><p>创建、订阅Observable示例1</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let observable = Observable&lt;Int&gt;.timer(.seconds(3),</span><br><span class="line">                                       period: .seconds(1),</span><br><span class="line">                                       scheduler: MainScheduler.instance)</span><br><span class="line">                                       </span><br><span class="line">observable.map &#123; &quot;数值是\($0)&quot; &#125; </span><br><span class="line">          .bind(to: label.rx.text) </span><br><span class="line">          .disposed(by: bag)</span><br></pre></td></tr></table></figure><h3 id="创建Observer"><a href="#创建Observer" class="headerlink" title="创建Observer"></a>创建Observer</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let observer = AnyObserver&lt;Int&gt;.init &#123; event in</span><br><span class="line">    switch event &#123;</span><br><span class="line">    case .next(let data):</span><br><span class="line">        print(data)</span><br><span class="line">    case .completed:</span><br><span class="line">        print(&quot;completed&quot;)</span><br><span class="line">    case .error(let error):</span><br><span class="line">        print(&quot;error&quot;, error)</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">Observable.just(1).subscribe(observer).dispose()</span><br><span class="line"></span><br><span class="line">let binder = Binder&lt;String&gt;(label) &#123; label, text in</span><br><span class="line">    label.text = text</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Observable.just(1).map &#123; &quot;数值是\($0)&quot; &#125;.subscribe(binder).dispose()</span><br><span class="line">//Observable.just(1).map &#123; &quot;数值是\($0)&quot; &#125;.bind(to: binder).dispose()</span><br></pre></td></tr></table></figure><h3 id="扩展Binder属性"><a href="#扩展Binder属性" class="headerlink" title="扩展Binder属性"></a>扩展Binder属性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">extension Reactive where Base: UIView &#123;</span><br><span class="line">    var hidden: Binder&lt;Bool&gt; &#123;</span><br><span class="line">        Binder&lt;Bool&gt;(base) &#123; view, value in</span><br><span class="line">        view.isHidden = value</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let observable = Observable&lt;Int&gt;.interval(.seconds(1),</span><br><span class="line">                                          scheduler: MainScheduler.instance)</span><br><span class="line">observable.map &#123; $0 % 2 == 0 &#125;.bind(to: button.rx.hidden).disposed(by: bag)</span><br></pre></td></tr></table></figure><h3 id="传统的状态监听"><a href="#传统的状态监听" class="headerlink" title="传统的状态监听"></a>传统的状态监听</h3><ul><li>在开发中经常要对各种状态进行监听，传统的常见监听方案有：<ul><li>KVO</li><li>Target-Action</li><li>Notification</li><li>Delegate</li><li>Block Callback</li></ul></li><li>传统文字经常会出现错综复杂的依赖关系、耦合性较高，还需要编写重复的非业务代码</li></ul><blockquote><p>RxSwift的状态监听示例1：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//按钮点击</span><br><span class="line">button.rx.tap.subscribe(onNext: &#123;</span><br><span class="line">    print(&quot;按钮被点击了1&quot;)</span><br><span class="line">&#125;).disposed(by: bag)</span><br><span class="line"></span><br><span class="line">//数据绑定到Cell</span><br><span class="line">let data = Observable.just([</span><br><span class="line">    Person(name: &quot;Jack&quot;, age: 10),</span><br><span class="line">    Person(name: &quot;Rose&quot;, age: 20)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">data.bind(to: tableView.rx.items(cellIdentifier: &quot;cell&quot;)) &#123; row, person, cell in</span><br><span class="line">    cell.textLabel?.text = person.name</span><br><span class="line">    cell.detailTextLabel?.text = &quot;\(person.age)&quot;</span><br><span class="line">&#125;.disposed(by: bag)</span><br><span class="line"></span><br><span class="line">tableView.rx.modelSelected(Person.self) .subscribe(onNext: &#123; person in</span><br><span class="line">    print(&quot;点击了&quot;, person.name)</span><br><span class="line">&#125;).disposed(by: bag)</span><br></pre></td></tr></table></figure><blockquote><p>RxSwift的状态监听示例2：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Dog: NSObject &#123;</span><br><span class="line">    @objc dynamic var name: String? </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dog.rx.observe(String.self, &quot;name&quot;) .subscribe(onNext: &#123; name in</span><br><span class="line">    print(&quot;name is&quot;, name ?? &quot;nil&quot;)</span><br><span class="line">&#125;).disposed(by: bag)</span><br><span class="line"></span><br><span class="line">dog.name = &quot;larry&quot;</span><br><span class="line">dog.name = &quot;wangwang&quot;</span><br><span class="line"></span><br><span class="line">NotificationCenter.default.rx.notification(UIApplication.didEnterBackgroundNotification).subscribe(onNext: &#123; notification in</span><br><span class="line">    print(&quot;APP进入后台&quot;, notification)</span><br><span class="line">&#125;).disposed(by: bag)</span><br></pre></td></tr></table></figure><h3 id="既是Observable，又是Observer"><a href="#既是Observable，又是Observer" class="headerlink" title="既是Observable，又是Observer"></a>既是Observable，又是Observer</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(0.8).bind(to: slider.rx.value).dispose()</span><br><span class="line"></span><br><span class="line">slider.rx.value.map &#123; </span><br><span class="line">    &quot;当前数值是：\($0)&quot;</span><br><span class="line">&#125;.bind(to: textField.rx.text).disposed(by: bag)</span><br><span class="line"></span><br><span class="line">textField.rx.text.subscribe(onNext: &#123; text in</span><br><span class="line">    print(&quot;text is&quot;, text ?? &quot;nil&quot;)</span><br><span class="line">&#125;).disposed(by: bag)</span><br></pre></td></tr></table></figure><ul><li>诸如UISlider.rx.value、UTextField.rx.text这类属性值，既是Observable，又是Observer<ul><li>它们是RxCocoa.ControlProperty类型</li></ul></li></ul><h3 id="Disposable"><a href="#Disposable" class="headerlink" title="Disposable"></a>Disposable</h3><ul><li>每当Observable被订阅时，都会返回一个Disposable实例，当调用Disposable的dispose，就相当于取消订阅</li><li>在不需要再接收事件时，建议取消订阅，释放资源。有3种常见方式取消订阅<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 立即取消订阅（一次性订阅）</span><br><span class="line">observable.subscribe &#123; event in</span><br><span class="line">    print(event)</span><br><span class="line">&#125;.dispose()</span><br><span class="line"></span><br><span class="line">// 当bag销毁（deinit）时，会自动调用Disposable实例的dispose</span><br><span class="line">observable.subscribe &#123; event in</span><br><span class="line">    print(event)</span><br><span class="line">&#125;.disposed(by: bag)</span><br><span class="line"></span><br><span class="line">// self销毁时（deinit）时，会自动调用Disposable实例的dispose</span><br><span class="line">let _ = observable.takeUntil(self.rx.deallocated).subscribe &#123; event in</span><br><span class="line">    print(event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;响应式编程（Reactive Programming, 简称RP）&lt;ul&gt;
&lt;li&gt;一种编程范式，于1997年提出，可以简化异步</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Swift" scheme="http://www.hxtec.top/tags/Swift/"/>
    
    <category term="语法" scheme="http://www.hxtec.top/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Swift-面向协议编程</title>
    <link href="http://www.hxtec.top/2022/09/19/Swift-%E9%9D%A2%E5%90%91%E5%8D%8F%E8%AE%AE%E7%BC%96%E7%A8%8B/"/>
    <id>http://www.hxtec.top/2022/09/19/Swift-%E9%9D%A2%E5%90%91%E5%8D%8F%E8%AE%AE%E7%BC%96%E7%A8%8B/</id>
    <published>2022-09-19T03:05:34.000Z</published>
    <updated>2022-09-19T04:10:34.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>面向协议编程（Protocol Oriented Programming, 简称POP）<ul><li>是Swift的一种编程范式，Apple于2015年WWDC提出</li><li>在Swift标准库中，能见到大量POP的影子</li></ul></li><li>同时，Swift也是一门面向对象的编程语言（Object Oriented Programming, 简称OOP）</li><li>在Swift开发中，OOP和POP是相辅相成的，任何一方并不能取代另一方</li><li>POP能弥补OOP一些设计上的不足</li></ul><h3 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h3><ul><li>OOP的三大特性：封装，继承，多态</li><li>继承的经典使用场合：</li><li>当多个类（比如A, B, C类）具有很多共性时，可以将这些共性抽取到一个父类中（比如D类），最后A, B, C类继承D类</li></ul><h3 id="OOP的缺点"><a href="#OOP的缺点" class="headerlink" title="OOP的缺点"></a>OOP的缺点</h3><ul><li>比如，如何将下面BVC, DVC的公共方法run抽取出来？<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class BVC: UIViewController &#123;</span><br><span class="line">    func run() &#123;</span><br><span class="line">        print(&quot;run&quot;) </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DVC: UITableViewController &#123;</span><br><span class="line">    func run() &#123;</span><br><span class="line">        print(&quot;run&quot;) </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>基于OOP想到的一些解决方案：<ol><li>将run方法放到另一个对象A中，然后BVC, DVC拥有对象A的属性，此时，多了一些额外的依赖关系</li><li>将run方法增加到UIViewController分类中，不过UIViewController会越来越臃肿，而且会影响它的其他所有子类</li><li>将run方法抽取到新的父类，采用多继承，会增加程序设计复杂度，产生菱形继承等问题，需要开发者额外解决</li></ol></li></ul><blockquote><p>解决方案：通过协议的方式</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protocol Runnable &#123;</span><br><span class="line">    func run()</span><br><span class="line">&#125;</span><br><span class="line">extension Runnable &#123;</span><br><span class="line">    func run() &#123;</span><br><span class="line">        print(&quot;run&quot;) </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BVC: UIViewController, Runnable &#123;&#125;</span><br><span class="line">class DVC: UITableViewController, Runnable &#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>POP的注意点</p><ul><li>优先考虑创建协议，而不是父类（基类）</li><li>优先考虑值类型（struct, enum），而不是引用类型（class）</li><li>巧用协议的扩展功能</li><li>不要为了面向协议而使用协议</li></ul></blockquote><h3 id="利用协议实现前辍效果"><a href="#利用协议实现前辍效果" class="headerlink" title="利用协议实现前辍效果"></a>利用协议实现前辍效果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">struct HX&lt;Base&gt; &#123;</span><br><span class="line">    let base: Base</span><br><span class="line">    init(_ base: Base) &#123;</span><br><span class="line">        self.base = base</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol HXCompatible &#123;&#125;</span><br><span class="line">extension HXCompatible &#123;</span><br><span class="line">    static var hx: HX&lt;Self&gt;.Type &#123;</span><br><span class="line">        get &#123; HX&lt;Self&gt;.self &#125;</span><br><span class="line">        set &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var hx: HX&lt;Self&gt; &#123;</span><br><span class="line">        get &#123; HX(self) &#125;</span><br><span class="line">        set &#123;&#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//对系统库进行扩展</span><br><span class="line">extension String: HXCompatible &#123;&#125;</span><br><span class="line">extension HX where Base == String &#123;</span><br><span class="line">    func numberCount() -&gt; Int &#123;</span><br><span class="line">        var count = 0</span><br><span class="line">        for c in base where (&quot;0&quot;...&quot;9&quot;).contains(c) &#123;</span><br><span class="line">            count += 1 </span><br><span class="line">        &#125;</span><br><span class="line">    return count</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用</span><br><span class="line">var string = &quot;123fdsf434&quot;</span><br><span class="line">print(string.hx.numberCount())</span><br></pre></td></tr></table></figure><blockquote><p>示例1：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;&#125;</span><br><span class="line">class Student: Person &#123;&#125;</span><br><span class="line"></span><br><span class="line">extension Person: HXCompatible &#123;&#125;</span><br><span class="line">extension HX where Base: Person &#123;</span><br><span class="line">    func run() &#123;&#125;</span><br><span class="line">    static func test() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.hx.test()</span><br><span class="line">Student.hx.test()</span><br><span class="line"></span><br><span class="line">let p = Person()</span><br><span class="line">p.hx.run()</span><br><span class="line"></span><br><span class="line">let s = Student()</span><br><span class="line">s.hx.run()</span><br></pre></td></tr></table></figure><blockquote><p>示例2：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//对Sting, NSString进行扩展</span><br><span class="line">extension String: HXCompatible &#123;&#125;</span><br><span class="line">extension NSString: HXCompatible &#123;&#125;</span><br><span class="line">extension HX where Base: ExpressibleByStringLiteral &#123;</span><br><span class="line">    func numberCount() -&gt; Int &#123;</span><br><span class="line">        let string = base as! String</span><br><span class="line">        var count = 0</span><br><span class="line">        for c in string where (&quot;0&quot;...&quot;9&quot;).contains(c) &#123;</span><br><span class="line">            count += 1 </span><br><span class="line">        &#125;</span><br><span class="line">        return count</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var s1: String = &quot;123fdsf434&quot;</span><br><span class="line">var s2: NSString = &quot;123fdsf434&quot;</span><br><span class="line">var s3: NSMutableString = &quot;123fdsf434&quot;</span><br><span class="line">print(s1.hx.numberCount())</span><br><span class="line">print(s2.hx.numberCount())</span><br><span class="line">print(s3.hx.numberCount())</span><br></pre></td></tr></table></figure><h3 id="利用协议实现类型判断"><a href="#利用协议实现类型判断" class="headerlink" title="利用协议实现类型判断"></a>利用协议实现类型判断</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//普通判断数组方法</span><br><span class="line">func isArray(_ value: Any) -&gt; Bool &#123; value is [Any] &#125;</span><br><span class="line">isArray( [1, 2] )</span><br><span class="line">isArray( [&quot;1&quot;, 2] )</span><br><span class="line">isArray( NSArray() )</span><br><span class="line">isArray( NSMutableArray() )</span><br><span class="line"></span><br><span class="line">//对Array, NSArray进行扩展方法</span><br><span class="line">protocol ArrayType &#123;&#125;</span><br><span class="line">extension Array: ArrayType &#123;&#125;</span><br><span class="line">extension NSArray: ArrayType &#123;&#125;</span><br><span class="line">func isArrayType(_ type: Any.Type) -&gt; Bool &#123; type is ArrayType.Type &#125;</span><br><span class="line"></span><br><span class="line">isArrayType([Int].self)</span><br><span class="line">isArrayType([Any].self)</span><br><span class="line">isArrayType(NSArray.self)</span><br><span class="line">isArrayType(NSMutableArray.self)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;面向协议编程（Protocol Oriented Programming, 简称POP）&lt;ul&gt;
&lt;li&gt;是Swift的一种编程</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Swift" scheme="http://www.hxtec.top/tags/Swift/"/>
    
    <category term="语法" scheme="http://www.hxtec.top/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Swift-函数式编程</title>
    <link href="http://www.hxtec.top/2022/09/19/Swift-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>http://www.hxtec.top/2022/09/19/Swift-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</id>
    <published>2022-09-19T03:05:24.000Z</published>
    <updated>2022-09-19T04:05:53.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>函数式编程（Funtional Programming，简称FP）是一种编程范式，也就是如何编写程序的方法论<ul><li>主要思想：把计算过程尽量分解成一系列可复用函数的调用</li><li>主要特征：函数是“第一等公民”</li><li>函数与其他数据类型一样的地位，可以赋值给其他变量，也可以作为函数参数、函数返回值</li></ul></li><li>函数式编程最早出现在LISP语言，绝大部分的现代编程语言也对函数式编程做了不同程序的支持，比如：<ul><li>Haskkell, JavaScript, Python, Swift, Kotlin, Scale等</li></ul></li><li>函数式编程中几个常用的概念：<ul><li>Higher-Order Function, Function Curring</li><li>Functor, Applicative Functor, Monad</li></ul></li></ul><h3 id="FP实践"><a href="#FP实践" class="headerlink" title="FP实践"></a>FP实践</h3><blockquote><p>传统写法</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 假设要实现以下功能：[(num + 3) * 5 - 1] % 10 / 2</span><br><span class="line">var num = 1</span><br><span class="line"></span><br><span class="line">func add(_ v1: Int, _ v2: Int) -&gt; Int &#123; v1 + v2 &#125;</span><br><span class="line">func sub(_ v1: Int, _ v2: Int) -&gt; Int &#123; v1 - v2 &#125;</span><br><span class="line">func multiple(_ v1: Int, _ v2: Int) -&gt; Int &#123; v1 * v2 &#125;</span><br><span class="line">func divide(_ v1: Int, _ v2: Int) -&gt; Int &#123; v1 / v2 &#125;</span><br><span class="line">func mod(_ v1: Int, _ v2: Int) -&gt; Int &#123; v1 % v2 &#125;</span><br><span class="line"></span><br><span class="line">divide(mod(sub(multiple(add(num, 3), 5), 1), 10), 2)</span><br></pre></td></tr></table></figure><blockquote><p>函数式写法</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 假设要实现以下功能：[(num + 3) * 5 - 1] % 10 / 2</span><br><span class="line"></span><br><span class="line">func add(_ v: Int) -&gt; (Int) -&gt; Int &#123; &#123; $0 + v &#125; &#125;</span><br><span class="line">func sub(_ v: Int) -&gt; (Int) -&gt; Int &#123; &#123; $0 - v &#125; &#125;</span><br><span class="line">func multiple(_ v: Int) -&gt; (Int) -&gt; Int &#123; &#123; $0 * v &#125; &#125;</span><br><span class="line">func divide(_ v: Int) -&gt; (Int) -&gt; Int &#123; &#123; $0 / v &#125; &#125;</span><br><span class="line">func mod(_ v: Int) -&gt; (Int) -&gt; Int &#123; &#123; $0 % v &#125; &#125;</span><br><span class="line"></span><br><span class="line">infix operator &gt;&gt;&gt; : AdditionPrecedence</span><br><span class="line"></span><br><span class="line">func &gt;&gt;&gt;&lt;A, B, C&gt;(_ f1: @escaping (A) -&gt; B, </span><br><span class="line">                  _ f2: @escaping (B) -&gt; C) -&gt; (A) -&gt; C &#123; &#123; f2(f1($0)) &#125; &#125;</span><br><span class="line">                  </span><br><span class="line">var fn = add(3) &gt;&gt;&gt; multiple(5) &gt;&gt;&gt; sub(1) &gt;&gt;&gt; mod(10) &gt;&gt;&gt; divide(2)</span><br><span class="line"></span><br><span class="line">fn(num)</span><br></pre></td></tr></table></figure><h3 id="高阶函数（Higher-Order-Function）"><a href="#高阶函数（Higher-Order-Function）" class="headerlink" title="高阶函数（Higher-Order-Function）"></a>高阶函数（Higher-Order-Function）</h3><ul><li>高阶函数是至少满足下列一个条件的函数：<ul><li>接受一个或多个函数作为输入（map, filter, reduce等）</li><li>返回一个函数</li></ul></li><li>FP中到处都是高阶函数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func add(_ v: Int) -&gt; (Int) -&gt; Int &#123; &#123; $0 + v &#125; &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="柯里化（Curring）"><a href="#柯里化（Curring）" class="headerlink" title="柯里化（Curring）"></a>柯里化（Curring）</h3><ul><li>定义</li><li>将一个接受多个参数的函数变换为一系列只接受单个参数的函数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func add(_ v1: Int, _ v2: Int) -&gt; Int &#123; v1 + v2 &#125;</span><br><span class="line">add(10, 20)</span><br><span class="line"></span><br><span class="line">-&gt; 变换为下面</span><br><span class="line">func add(_ v: Int) -&gt; (Int) -&gt; Int &#123; &#123; $0 + v &#125; &#125;</span><br><span class="line">add(10)(20)</span><br></pre></td></tr></table></figure></li><li>Array, Optional的map方法接收的参数就是一个柯里化函数<blockquote><p>示例1</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func add1(_ v1: Int, _ v2: Int) -&gt; Int &#123; v1 + v2 &#125;</span><br><span class="line">func add2(_ v1: Int, _ v2: Int, _ v3: Int) -&gt; Int &#123; v1 + v2 + v3 &#125;</span><br><span class="line"></span><br><span class="line">func currying&lt;A, B, C&gt;(_ fn: @escaping (A, B) -&gt; C) -&gt; (B) -&gt; (A) -&gt; C &#123;</span><br><span class="line">    &#123; b in &#123; a in fn(a, b) &#125; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func currying&lt;A, B, C, D&gt;(_ fn: @escaping (A, B, C) -&gt; D) -&gt; (C) -&gt; (B) -&gt; (A) -&gt; D &#123;</span><br><span class="line">    &#123; c in &#123; b in &#123; a in fn(a, b, c) &#125; &#125; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let curriedAdd1 = currying(add1)</span><br><span class="line">print(curriedAdd1(10)(20))</span><br><span class="line"></span><br><span class="line">let curriedAdd2 = currying(add2)</span><br><span class="line">print(curriedAdd2(10)(20)(30))</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>示例2</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 假设要实现以下功能：[(num + 3) * 5 - 1] % 10 / 2</span><br><span class="line"></span><br><span class="line">func add(_ v1: Int, _ v2: Int) -&gt; Int &#123; v1 + v2 &#125;</span><br><span class="line">func sub(_ v1: Int, _ v2: Int) -&gt; Int &#123; v1 - v2 &#125;</span><br><span class="line">func multiple(_ v1: Int, _ v2: Int) -&gt; Int &#123; v1 * v2 &#125;</span><br><span class="line">func divide(_ v1: Int, _ v2: Int) -&gt; Int &#123; v1 / v2 &#125;</span><br><span class="line">func mod(_ v1: Int, _ v2: Int) -&gt; Int &#123; v1 % v2 &#125;</span><br><span class="line"></span><br><span class="line">//柯里化函数</span><br><span class="line">prefix func ~&lt;A, B, C&gt;(_ fn: @escaping (A, B) -&gt; C) -&gt; (B) -&gt; (A) -&gt; C &#123; &#123; b in &#123; a in fn(a, b) &#125; &#125; &#125;</span><br><span class="line"></span><br><span class="line">//自定义运算符</span><br><span class="line">infix operator &gt;&gt;&gt; : AdditionPrecedence</span><br><span class="line">func &gt;&gt;&gt;&lt;A, B, C&gt;(_ f1: @escaping (A) -&gt; B,</span><br><span class="line">                  _ f2: @escaping (B) -&gt; C) -&gt; (A) -&gt; C &#123; &#123; f2(f1($0)) &#125; &#125;</span><br><span class="line"></span><br><span class="line">var num = 1</span><br><span class="line">var fn = (~add)(3) &gt;&gt;&gt; (~multiple)(5) &gt;&gt;&gt; (~sub)(1) &gt;&gt;&gt; (~mod)(10) &gt;&gt;&gt; (~divide)(2)</span><br><span class="line">fn(num)</span><br></pre></td></tr></table></figure><h3 id="函子（Functor）"><a href="#函子（Functor）" class="headerlink" title="函子（Functor）"></a>函子（Functor）</h3><ul><li>像Array, Optional这样支持map运算的类型，称为函子（Functor）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Array&lt;Element&gt;</span><br><span class="line">public func map&lt;T&gt;(_ transform: (Element) -&gt; T) -&gt; Array&lt;T&gt;</span><br><span class="line"></span><br><span class="line">// Optional&lt;Wrapped&gt;</span><br><span class="line">public func map&lt;U&gt;(_ transform: (Wrapped) -&gt; U) -&gt; Optional&lt;U&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="适用函子（Applicative-Functor"><a href="#适用函子（Applicative-Functor" class="headerlink" title="适用函子（Applicative Functor"></a>适用函子（Applicative Functor</h3><ul><li><p>对任意一个函子 F，如果能支持以下运算，该函子就是一个适用函子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func pure&lt;A&gt;(_ value: A) -&gt; F&lt;A&gt;</span><br><span class="line">func &lt;*&gt;&lt;A, B&gt;(fn: F&lt;(A) -&gt; B&gt;, value: F&lt;A&gt;) -&gt; F&lt;B&gt;</span><br></pre></td></tr></table></figure></li><li><p>Optional可以成为适用函子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func pure&lt;A&gt;(_ value: A) -&gt; A? &#123; value &#125;</span><br><span class="line">infix operator &lt;*&gt; : AdditionPrecedence</span><br><span class="line">func &lt;*&gt;&lt;A, B&gt;(fn: ((A) -&gt; B)?, value: A?) -&gt; B? &#123;</span><br><span class="line">    guard let f = fn, let v = value else &#123; return nil &#125;</span><br><span class="line">    return f(v)</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">var value: Int? = 10</span><br><span class="line">var fn: ((Int) -&gt; Int)? = &#123; $0 * 2&#125;</span><br><span class="line">// Optional(20)</span><br><span class="line">print(fn &lt;*&gt; value as Any)</span><br></pre></td></tr></table></figure></li><li><p>Array可以成为适用函子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func pure&lt;A&gt;(_ value: A) -&gt; [A] &#123; [value] &#125;</span><br><span class="line">infix operator &lt;*&gt; : AdditionPrecedence</span><br><span class="line">func &lt;*&gt;&lt;A, B&gt;(fn: [(A) -&gt; B], value: [A]) -&gt; [B] &#123;</span><br><span class="line">    var arr: [B] = []</span><br><span class="line">    if fn.count == value.count &#123;</span><br><span class="line">        for i in fn.startIndex..&lt;fn.endIndex &#123;</span><br><span class="line">            arr.append(fn[i](value[i]))</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// [10]</span><br><span class="line">print(pure(10))</span><br><span class="line">var arr = [&#123; $0 * 2&#125;, &#123; $0 + 10 &#125;, &#123; $0 - 5 &#125;] &lt;*&gt; [1, 2, 3]</span><br><span class="line">// [2, 12, -2]</span><br><span class="line">print(arr)</span><br></pre></td></tr></table></figure></li></ul><h3 id="单子（Monad）"><a href="#单子（Monad）" class="headerlink" title="单子（Monad）"></a>单子（Monad）</h3><ul><li>对任意一个类型 F，如果能支持以下运算，那么就可以称为是一个单子（Monad）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func pure&lt;A&gt;(_ value: A) -&gt; F&lt;A&gt;</span><br><span class="line">func flatMap&lt;A, B&gt;(_ value: F&lt;A&gt;, _ fn: (A) -&gt; F&lt;B&gt;) -&gt; F&lt;B&gt;</span><br></pre></td></tr></table></figure></li><li>Array、Optional都是单子</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;函数式编程（Funtional Programming，简称FP）是一种编程范式，也就是如何编写程序的方法论&lt;ul&gt;
&lt;li&gt;主</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Swift" scheme="http://www.hxtec.top/tags/Swift/"/>
    
    <category term="语法" scheme="http://www.hxtec.top/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Swift-从OC到Swift 二</title>
    <link href="http://www.hxtec.top/2022/09/19/Swift-%E4%BB%8EOC%E5%88%B0Swift-%E4%BA%8C/"/>
    <id>http://www.hxtec.top/2022/09/19/Swift-%E4%BB%8EOC%E5%88%B0Swift-%E4%BA%8C/</id>
    <published>2022-09-19T03:05:10.000Z</published>
    <updated>2022-09-19T04:03:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="KVC-x2F-KVO"><a href="#KVC-x2F-KVO" class="headerlink" title="KVC&#x2F;KVO"></a>KVC&#x2F;KVO</h2><ul><li>Swift 支持KVC&#x2F;KVO的条件<ul><li>属性所在的类、监听器最终继承自 NSObject</li><li>用 @objc dynamic 修饰对应的属性</li></ul></li></ul><h3 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 监听器</span><br><span class="line">class Observer: NSObject &#123;</span><br><span class="line">    override func observeValue(forKeyPath keyPath: String?,</span><br><span class="line">                                of object: Any?,</span><br><span class="line">                                change: [NSKeyValueChangeKey : Any]?,</span><br><span class="line">                                context: UnsafeMutableRawPointer?) &#123;</span><br><span class="line">        print(&quot;observeValue&quot;, change?[.newKey] as Any) </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 类</span><br><span class="line">class Person: NSObject &#123;</span><br><span class="line">    @objc dynamic var age: Int = 0</span><br><span class="line">    var observer: Observer = Observer()</span><br><span class="line">    override init() &#123;</span><br><span class="line">        super.init()</span><br><span class="line">        self.addObserver(observer,</span><br><span class="line">                        forKeyPath: &quot;age&quot;,</span><br><span class="line">                        options: .new,</span><br><span class="line">                        context: nil) </span><br><span class="line">    &#125;</span><br><span class="line">    deinit &#123;</span><br><span class="line">        self.removeObserver(observer,</span><br><span class="line">                            forKeyPath: &quot;age&quot;) </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = Person()</span><br><span class="line">// observeValue Optional(20)</span><br><span class="line">p.age = 20</span><br><span class="line">// observeValue Optional(25)</span><br><span class="line">p.setValue(25, forKey: &quot;age&quot;)</span><br></pre></td></tr></table></figure><h3 id="block方式的KVO"><a href="#block方式的KVO" class="headerlink" title="block方式的KVO"></a>block方式的KVO</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Person: NSObject &#123;</span><br><span class="line">    @objc dynamic var age: Int = 0</span><br><span class="line">    var observation: NSKeyValueObservation?</span><br><span class="line">    override init() &#123;</span><br><span class="line">        super.init()</span><br><span class="line">        observation = observe(\Person.age, options: .new) &#123;</span><br><span class="line">            (person, change) in</span><br><span class="line">            print(change.newValue as Any) </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = Person()</span><br><span class="line">// Optional(20)</span><br><span class="line">p.age = 20</span><br><span class="line">// Optional(25)</span><br><span class="line">p.setValue(25, forKey: &quot;age&quot;)</span><br></pre></td></tr></table></figure><h2 id="关联对象（Associated-Object）"><a href="#关联对象（Associated-Object）" class="headerlink" title="关联对象（Associated Object）"></a>关联对象（Associated Object）</h2><ul><li>在Swift中，class依然可以使用关联对象<ul><li>默认情况，extension不可以增加存储属性</li><li>借助关联对象，可以实现类似extension为class增加存储属性的效果</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;&#125;</span><br><span class="line"></span><br><span class="line">extension Person &#123;</span><br><span class="line">    private static var AGE_KEY: Void?</span><br><span class="line">    var age: Int &#123;</span><br><span class="line">        get &#123;(objc_getAssociatedObject(self, &amp;Self.AGE_KEY) as? Int) ?? 0 &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">            objc_setAssociatedObject(self, </span><br><span class="line">                                    &amp;Self.AGE_KEY,</span><br><span class="line">                                    newValue,</span><br><span class="line">                                    .OBJC_ASSOCIATION_ASSIGN) </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = Person()</span><br><span class="line">print(p.age) // 0</span><br><span class="line">p.age = 10</span><br><span class="line">print(p.age) // 10</span><br></pre></td></tr></table></figure><h2 id="资源名管理"><a href="#资源名管理" class="headerlink" title="资源名管理"></a>资源名管理</h2><ul><li>参考Android的资源名管理方式</li></ul><blockquote><p>改善前</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let img = UIImage(named: &quot;logo&quot;)</span><br><span class="line"></span><br><span class="line">let btn = UIButton(type: .custom)</span><br><span class="line">btn.setTitle(&quot;添加&quot;, for: .normal)</span><br><span class="line"></span><br><span class="line">performSegue(withIdentifier: &quot;login_main&quot;, sender: self)</span><br></pre></td></tr></table></figure><blockquote><p>改善后</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//枚举封装</span><br><span class="line">enum R &#123;</span><br><span class="line">    enum string: String &#123;</span><br><span class="line">        case add = &quot;添加&quot; </span><br><span class="line">    &#125;</span><br><span class="line">    enum image: String &#123;</span><br><span class="line">        case logo</span><br><span class="line">    &#125;</span><br><span class="line">    enum segue: String &#123;</span><br><span class="line">        case login_main</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 扩展</span><br><span class="line">extension UIImage &#123;</span><br><span class="line">    convenience init?(_ name: R.image) &#123;</span><br><span class="line">        self.init(named: name.rawValue) </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension UIButton &#123;</span><br><span class="line">    func setTitle(_ title: R.string, for state: UIControl.State) &#123;</span><br><span class="line">        setTitle(title.rawValue, for: state)</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension UIViewController &#123;</span><br><span class="line">    func performSegue(withIdentifier identifier: R.segue, sender: Any?) &#123;</span><br><span class="line">        performSegue(withIdentifier: identifier.rawValue, sender: sender)</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用</span><br><span class="line">let img = UIImage(R.image.logo)</span><br><span class="line"></span><br><span class="line">let btn = UIButton(type: .custom)</span><br><span class="line">btn.setTitle(R.string.add, for: .normal)</span><br><span class="line"></span><br><span class="line">performSegue(withIdentifier: R.segue.login_main, sender: self)</span><br></pre></td></tr></table></figure><h3 id="资源名管理的其他思路"><a href="#资源名管理的其他思路" class="headerlink" title="资源名管理的其他思路"></a>资源名管理的其他思路</h3><blockquote><p>优化前</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let img = UIImage(named: &quot;logo&quot;)</span><br><span class="line"></span><br><span class="line">let font = UIFont(name: &quot;Arial&quot;, size: 14)</span><br></pre></td></tr></table></figure><blockquote><p>优化后</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//枚举进行封装</span><br><span class="line">enum R &#123;</span><br><span class="line">    enum image &#123;</span><br><span class="line">        static var logo = UIImage(named: &quot;logo&quot;) </span><br><span class="line">    &#125;</span><br><span class="line">    enum font &#123;</span><br><span class="line">        static func arial(_ size: CGFloat) -&gt; UIFont? &#123;</span><br><span class="line">            UIFont(name: &quot;Arial&quot;, size: size)</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let img = R.image.logo</span><br><span class="line"></span><br><span class="line">let font = R.font.arial(14)</span><br></pre></td></tr></table></figure><ul><li>更多优秀的思路参考<ul><li><a href="https://github.com/mac-cain13/R.swift">https://github.com/mac-cain13/R.swift</a></li><li><a href="https://github.com/SwiftGen/SwiftGen">https://github.com/SwiftGen/SwiftGen</a></li></ul></li></ul><h2 id="多线程开发-异步"><a href="#多线程开发-异步" class="headerlink" title="多线程开发 - 异步"></a>多线程开发 - 异步</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public typealias Task = () -&gt; Void</span><br><span class="line"></span><br><span class="line">struct Async &#123;</span><br><span class="line">    //子线程开辟任务</span><br><span class="line">     public static func async(_ task: @escaping Task) &#123;</span><br><span class="line">        _async(task)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //子线程任务完成之后，回到主线程执行任务</span><br><span class="line">    public static func async(_ task: @escaping Task, _ mainTask: @escaping Task) &#123;</span><br><span class="line">        _async(task, mainTask)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private static func _async(_ task: @escaping Task, </span><br><span class="line">                                _ mainTask: Task? = nil) &#123;</span><br><span class="line">        let item = DispatchWorkItem(block: task)</span><br><span class="line">        DispatchQueue.global().async(execute: item)</span><br><span class="line">        if let main = mainTask &#123;</span><br><span class="line">            item.notify(queue: DispatchQueue.main, execute: main)</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多线程开发-异步延迟"><a href="#多线程开发-异步延迟" class="headerlink" title="多线程开发 - 异步延迟"></a>多线程开发 - 异步延迟</h3><blockquote><p>一般用法</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@discardableResult //忽略返回值</span><br><span class="line">public static func delay(_ seconds: Double, _ block: @escaping Task) -&gt; DispatchWorkItem &#123;</span><br><span class="line">    let item = DispatchWorkItem(block: block)</span><br><span class="line">    DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + seconds,</span><br><span class="line">                                execute: item)</span><br><span class="line">    return item</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>封装使用</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@discardableResult</span><br><span class="line">public static func asyncDelay(_ seconds: Double, _ task: @escaping Task) -&gt; DispatchWorkItem &#123;</span><br><span class="line">    return _asyncDelay(seconds, task)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@discardableResult</span><br><span class="line">public static func asyncDelay(_ seconds: Double, _ task: @escaping Task, _ mainTask: @escaping Task) -&gt; DispatchWorkItem &#123;</span><br><span class="line">    return _asyncDelay(seconds, task, mainTask)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static func _asyncDelay(_ seconds: Double,  </span><br><span class="line">                                _ task: @escaping Task, </span><br><span class="line">                                _ mainTask: Task? = nil) -&gt; DispatchWorkItem &#123;</span><br><span class="line">    let item = DispatchWorkItem(block: task)</span><br><span class="line">    DispatchQueue.global().asyncAfter(deadline: DispatchTime.now() + seconds,</span><br><span class="line">                                    execute: item)</span><br><span class="line">    if let main = mainTask &#123;</span><br><span class="line">        item.notify(queue: DispatchQueue.main, execute: main)</span><br><span class="line">    &#125;</span><br><span class="line">    return item</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多线程开发-once"><a href="#多线程开发-once" class="headerlink" title="多线程开发 - once"></a>多线程开发 - once</h3><ul><li>dispatch_once在Swift中已被废弃，取而代之 <ul><li>以用类型属性或者全局变量\常量</li><li>默认自带 lazy + dispatch_once 效果<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fileprivate let initTask2: Void = &#123;</span><br><span class="line">    print(&quot;initTask2---------&quot;)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">class ViewController: UIViewController &#123;</span><br><span class="line">    static let initTask1: Void = &#123;</span><br><span class="line">        print(&quot;initTask1---------&quot;)</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        let _ = Self.initTask1</span><br><span class="line">        </span><br><span class="line">        let _ = initTask2</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="多线程开发-加锁"><a href="#多线程开发-加锁" class="headerlink" title="多线程开发 - 加锁"></a>多线程开发 - 加锁</h3><ul><li>gcd信号量<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Cache &#123;</span><br><span class="line">    private static var data = [String: Any]()</span><br><span class="line">    private static var lock = DispatchSemaphore(value: 1)</span><br><span class="line">    static func set(_ key: String, _ value: Any) &#123;</span><br><span class="line">        lock.wait()</span><br><span class="line">        defer &#123; lock.signal() &#125;</span><br><span class="line">        data[key] = value</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Foundation<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//正常加锁</span><br><span class="line">private static var lock = NSLock()</span><br><span class="line">    static func set(_ key: String, _ value: Any) &#123;</span><br><span class="line">        lock.lock()</span><br><span class="line">        defer &#123; lock.unlock() &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 递归锁</span><br><span class="line">private static var lock = NSRecursiveLock()</span><br><span class="line">    static func set(_ key: String, _ value: Any) &#123;</span><br><span class="line">        lock.lock()</span><br><span class="line">        defer &#123; lock.unlock() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;KVC-x2F-KVO&quot;&gt;&lt;a href=&quot;#KVC-x2F-KVO&quot; class=&quot;headerlink&quot; title=&quot;KVC&amp;#x2F;KVO&quot;&gt;&lt;/a&gt;KVC&amp;#x2F;KVO&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Swift 支持KVC&amp;#x2F;KVO的条件&lt;ul</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Swift" scheme="http://www.hxtec.top/tags/Swift/"/>
    
    <category term="语法" scheme="http://www.hxtec.top/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Swift-从OC到Swift 一</title>
    <link href="http://www.hxtec.top/2022/09/19/Swift-%E4%BB%8EOC%E5%88%B0Swift-%E4%B8%80/"/>
    <id>http://www.hxtec.top/2022/09/19/Swift-%E4%BB%8EOC%E5%88%B0Swift-%E4%B8%80/</id>
    <published>2022-09-19T03:04:58.000Z</published>
    <updated>2022-09-19T03:58:03.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="MARK-TODO-FIXME"><a href="#MARK-TODO-FIXME" class="headerlink" title="MARK, TODO, FIXME"></a>MARK, TODO, FIXME</h4><ul><li>&#x2F;&#x2F;MARK: 类似于OC中的 #pragma mark</li><li>&#x2F;&#x2F;MARK: - 类似于OC中的 #pragma mark - </li><li>&#x2F;&#x2F;TODO:用于标记未完成的任务</li><li>&#x2F;&#x2F;FIXME:用于标记待修复的问题</li></ul><h4 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 操作系统：macOS\iOS\tvOS\watchOS\Linux\Android\Windows\FreeBSD</span><br><span class="line">#if os(macOS) || os(iOS)</span><br><span class="line">// CPU架构：i386\x86_64\arm\arm64</span><br><span class="line">#elseif arch(x86_64) || arch(arm64)</span><br><span class="line">// swift版本</span><br><span class="line">#elseif swift(&lt;5) &amp;&amp; swift(&gt;=3)</span><br><span class="line">// 模拟器</span><br><span class="line">#elseif targetEnvironment(simulator)</span><br><span class="line">// 可以导入某模块</span><br><span class="line">#elseif canImport(Foundation)</span><br><span class="line">#else</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">// debug模式</span><br><span class="line">#if DEBUG</span><br><span class="line"></span><br><span class="line">// release模式</span><br><span class="line">#else</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">// 自定义</span><br><span class="line">#if TEST</span><br><span class="line">print(&quot;test&quot;)</span><br><span class="line">#endif</span><br><span class="line">#if OTHER</span><br><span class="line">print(&quot;other&quot;)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h4 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//自定义Log输出格式</span><br><span class="line">func log&lt;T&gt;(_ msg: T,</span><br><span class="line">    file: NSString = #file,</span><br><span class="line">    line: Int = #line,</span><br><span class="line">    fn: String = #function) &#123;</span><br><span class="line">        #if DEBUG</span><br><span class="line">        let prefix = &quot;\(file.lastPathComponent)_\(line)_\(fn):&quot;</span><br><span class="line">        print(prefix, msg)</span><br><span class="line">        #endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="系统版本检测"><a href="#系统版本检测" class="headerlink" title="系统版本检测"></a>系统版本检测</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 对于iOS平台，只在iOS10及以上版本执行</span><br><span class="line">// 对于macOS平台，只在macOS 10.12及以上版本执行</span><br><span class="line">// 最后的*表示在其他所有平台都执行</span><br><span class="line">if #available(iOS 10, macOS 10.12, *) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="API可用性说明"><a href="#API可用性说明" class="headerlink" title="API可用性说明"></a>API可用性说明</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@available(iOS 10, macOS 10.15, *)</span><br><span class="line">class Person &#123;&#125;</span><br><span class="line"></span><br><span class="line">struct Student &#123;</span><br><span class="line">    @available(*, unavailable, renamed: &quot;study&quot;)</span><br><span class="line">    func study_() &#123;&#125;</span><br><span class="line">    func study() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    @available(iOS, deprecated: 11)</span><br><span class="line">    @available(macOS, deprecated: 10.12)</span><br><span class="line">    func run() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="iOS程序的入口"><a href="#iOS程序的入口" class="headerlink" title="iOS程序的入口"></a>iOS程序的入口</h4><ul><li>在AppDelegate上面默认有个@UIApplicationMain标记，这表示<ul><li>编译器自动生成入口代码（main函数代码），自动设置AppDelegate为APP的代理</li></ul></li><li>也可以删掉@UIApplicationMain，自定义入口代码：新建一个main.swift文件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line"></span><br><span class="line">class MyApplication: UIApplication &#123; &#125;</span><br><span class="line"></span><br><span class="line">UIApplicationMain(CommandLine.argc,</span><br><span class="line">                  CommandLine.unsafeArgv,</span><br><span class="line">                  NSStringFromClass(MyApplication.self),</span><br><span class="line">                  NSStringFromClass(AppDelegate.self))</span><br></pre></td></tr></table></figure></li></ul><h4 id="Swift调用OC"><a href="#Swift调用OC" class="headerlink" title="Swift调用OC"></a>Swift调用OC</h4><ul><li>新建1个桥接头文件，文件名格式默认为：**{targetName}-Bridging-Header.h**</li><li>在  <code>&#123;targetName&#125;-Bridging-Header.h </code> 文件中 #import OC需要暴露给Swift的内容<ul><li>TARGETS -&gt; Build Settings -&gt; briding<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;***.h&quot;</span><br><span class="line">#import &quot;***.h&quot;</span><br><span class="line">#import &quot;***.h&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p>示例</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">//Person.h文件</span><br><span class="line">int sum(int a, int b);</span><br><span class="line"></span><br><span class="line">@interface Person : NSObject</span><br><span class="line">@property (nonatomic, assign) NSInteger age;</span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithAge:(NSInteger)age name:(NSString *)name;</span><br><span class="line">+ (instancetype)personWithAge:(NSInteger)age name:(NSString *)name;</span><br><span class="line"></span><br><span class="line">- (void)run;</span><br><span class="line">+ (void)run;</span><br><span class="line"></span><br><span class="line">- (void)eat:(NSString *)food other:(NSString *)other;</span><br><span class="line">+ (void)eat:(NSString *)food other:(NSString *)other;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//Person.m文件</span><br><span class="line">#import Person.h</span><br><span class="line">@end</span><br><span class="line">@implementation Person</span><br><span class="line">- (instancetype)initWithAge:(NSInteger)age name:(NSString *)name &#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        self.age = age;</span><br><span class="line">        self.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    return self; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (instancetype)personWithAge:(NSInteger)age name:(NSString *)name &#123;</span><br><span class="line">    return [[self alloc] initWithAge:age name:name];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)run &#123; NSLog(@&quot;Person +run&quot;); &#125; </span><br><span class="line">- (void)run &#123; NSLog(@&quot;%zd %@ -run&quot;, _age, _name); &#125;</span><br><span class="line"></span><br><span class="line">+ (void)eat:(NSString *)food other:(NSString *)other &#123; NSLog(@&quot;Person +eat %@ %@&quot;, food, other); &#125; </span><br><span class="line">- (void)eat:(NSString *)food other:(NSString *)other &#123; NSLog(@&quot;%zd %@ -eat %@ %@&quot;, _age, _name, food, other); &#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">int sum(int a, int b) &#123; return a + b; &#125;</span><br><span class="line"></span><br><span class="line">//Swift文件中使用Person类</span><br><span class="line">var p = Person(age: 10, name: &quot;Jack&quot;) p.age = 18</span><br><span class="line">p.name = &quot;Rose&quot;</span><br><span class="line">p.run() // 18 Rose -run</span><br><span class="line">p.eat(&quot;Apple&quot;, other: &quot;Water&quot;) // 18 Rose -eat Apple Water</span><br><span class="line"></span><br><span class="line">Person.run() // Person +run</span><br><span class="line">Person.eat(&quot;Pizza&quot;, other: &quot;Banana&quot;) // Person +eat Pizza Banana</span><br><span class="line"></span><br><span class="line">print(sum(10, 20)) // 30</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="Swift调用OC-–-silgen-name"><a href="#Swift调用OC-–-silgen-name" class="headerlink" title="Swift调用OC – @_silgen_name"></a>Swift调用OC – @_silgen_name</h4><ul><li>如果C语言暴露给Swift的函数名跟Swift中的其他函数名冲突了<ul><li>可以在Swift中使用 @_silgen_name 修改C函数名<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// C语言</span><br><span class="line">int sum(int a, int b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Swift</span><br><span class="line">@_silgen_name(&quot;sum&quot;) func swift_sum(_ v1: Int32, _ v2: Int32) -&gt; Int32</span><br><span class="line">print(swift_sum(10, 20)) // 30</span><br><span class="line"></span><br><span class="line">print(sum(10, 20)) // 30</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="OC调用Swift"><a href="#OC调用Swift" class="headerlink" title="OC调用Swift"></a>OC调用Swift</h4><ul><li><p>Xcode已经默认生成一个用于OC调用Swift的头文件，文件名格式是：   <code>&#123;targetName&#125;-Swift.h </code></p><ul><li>TARGETS -&gt; Build Settings -&gt; generated interface</li></ul></li><li><p>Swift暴露给OC的类最终继承自NSObject</p></li><li><p>使用  <code>@objc </code> 修饰需要暴露给OC的成员</p></li><li><p>使用  <code>@objcMembers </code> 修饰类</p><ul><li>代表默认所有成员都会暴露给OC（包括扩展中定义的成员）</li><li>最终是否成功暴露，还需要考虑成员自身的访问级别<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import Foundation</span><br><span class="line"></span><br><span class="line">@objcMembers class Car: NSObject &#123;</span><br><span class="line">    var price: Double</span><br><span class="line">    var band: String</span><br><span class="line">    init(price: Double, band: String) &#123;</span><br><span class="line">        self.price = price</span><br><span class="line">        self.band = band</span><br><span class="line">    &#125;</span><br><span class="line">    func run() &#123; print(price, band, &quot;run&quot;) &#125;</span><br><span class="line">    static func run() &#123; print(&quot;Car run&quot;) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension Car &#123;</span><br><span class="line">    func test() &#123; print(price, band, &quot;test&quot;) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//对应转化生成的OC代码如下：</span><br><span class="line">@interface Car : NSObject</span><br><span class="line">@property (nonatomic) double price;</span><br><span class="line">@property (nonatomic, copy) NSString * _Nonnull band;</span><br><span class="line">- (nonnull instancetype)initWithPrice:(double)price band:(NSString * _Nonnull)band OBJC_DESIGNATED_INITIALIZER; - (void)run;</span><br><span class="line">+ (void)run;</span><br><span class="line">- (nonnull instancetype)init SWIFT_UNAVAILABLE;</span><br><span class="line">+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG(&quot;-init is unavailable&quot;);</span><br><span class="line">@end</span><br><span class="line">//扩展</span><br><span class="line">@interface Car (SWIFT_EXTENSION(_Swift))</span><br><span class="line">- (void)test;</span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>OC调用Swift，OC文件中的代码示例：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;_Swift-Swift.h&quot;</span><br><span class="line">int sum(int a, int b) &#123;</span><br><span class="line">    Car *c = [[Car alloc] initWithPrice:10.5 band:@&quot;BMW&quot;];</span><br><span class="line">    c.band = @&quot;Bently&quot;;</span><br><span class="line">    c.price = 108.5;</span><br><span class="line">    [c run]; // 108.5 Bently run</span><br><span class="line">    [c test]; // 108.5 Bently test</span><br><span class="line">    [Car run]; // Car run</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="OC调用Swift-–-objc"><a href="#OC调用Swift-–-objc" class="headerlink" title="OC调用Swift –  @objc "></a>OC调用Swift –  <code>@objc </code></h4><ul><li>可以通过  <code>@objc </code> 重命名Swift暴露给OC的符号名（类名、属性名、函数名等）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@objc(MyCar)</span><br><span class="line">@objcMembers class Car: NSObject &#123;</span><br><span class="line">    var price: Double</span><br><span class="line">    @objc(name)</span><br><span class="line">    var band: String</span><br><span class="line">    init(price: Double, band: String) &#123;</span><br><span class="line">        self.price = price</span><br><span class="line">        self.band = band</span><br><span class="line">    &#125;</span><br><span class="line">    @objc(drive)</span><br><span class="line">    func run() &#123; print(price, band, &quot;run&quot;) &#125;</span><br><span class="line">    static func run() &#123; print(&quot;Car run&quot;) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension Car &#123;</span><br><span class="line">    @objc(exec:v2:)</span><br><span class="line">    func test() &#123; print(price, band, &quot;test&quot;) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyCar *c = [[MyCar alloc] initWithPrice:10.5 band:@&quot;BMW&quot;];</span><br><span class="line">c.name = @&quot;Bently&quot;;</span><br><span class="line">c.price = 108.5;</span><br><span class="line">[c drive]; // 108.5 Bently run</span><br><span class="line">[c exec:10 v2:20]; // 108.5 Bently test</span><br><span class="line">[MyCar run]; // Car run</span><br></pre></td></tr></table></figure></li></ul><h4 id="选择器（Selector）"><a href="#选择器（Selector）" class="headerlink" title="选择器（Selector）"></a>选择器（Selector）</h4><ul><li>Swift中依然可以使用选择器，使用  <code>#selector(name) </code> 定义一个选择器</li><li>必须是被  <code>@objcMembers </code> 或  <code>@objc </code> 修饰的方法才可以定义选择器<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@objcMembers class Person: NSObject &#123;</span><br><span class="line">    func test1(v1: Int) &#123; print(&quot;test1&quot;) &#125;</span><br><span class="line">    func test2(v1: Int, v2: Int) &#123; print(&quot;test2(v1:v2:)&quot;) &#125;</span><br><span class="line">    func test2(_ v1: Double, _ v2: Double) &#123; print(&quot;test2(_:_:)&quot;) &#125;</span><br><span class="line">    func run() &#123;</span><br><span class="line">        perform(#selector(test1))</span><br><span class="line">        perform(#selector(test1(v1:)))</span><br><span class="line">        perform(#selector(test2(v1:v2:)))</span><br><span class="line">        perform(#selector(test2(_:_:)))</span><br><span class="line">        perform(#selector(test2 as (Double, Double) -&gt; Void))</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="只能被Class继承的协议"><a href="#只能被Class继承的协议" class="headerlink" title="只能被Class继承的协议"></a>只能被Class继承的协议</h4><ul><li>@objc 修饰的协议，还可以暴露给OC去遵守实现<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protocol Runnable1: AnyObject &#123;&#125;</span><br><span class="line"></span><br><span class="line">protocol Runnable2: class &#123;&#125;</span><br><span class="line"></span><br><span class="line">@objc protocol Runnable3 &#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="可选协议"><a href="#可选协议" class="headerlink" title="可选协议"></a>可选协议</h4><ul><li>可以通过 @objc 定义可选协议，这种协议只能被 class 遵守<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@objc protocol Runnable &#123;</span><br><span class="line">    func run1()</span><br><span class="line">    @objc optional func run2()</span><br><span class="line">    func run3()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog: Runnable &#123;</span><br><span class="line">    func run3() &#123; print(&quot;Dog run3&quot;) &#125;</span><br><span class="line">    func run1() &#123; print(&quot;Dog run1&quot;) &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var d = Dog()</span><br><span class="line">d.run1() // Dog run1</span><br><span class="line">d.run3() // Dog run3</span><br></pre></td></tr></table></figure></li></ul><h4 id="dynamic"><a href="#dynamic" class="headerlink" title="dynamic"></a>dynamic</h4><ul><li>被 @objc dynamic 修饰的内容会具有动态性，比如调用方法会走 runtime 那一套流程<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Dog: NSObject &#123;</span><br><span class="line">@objc dynamic func test1() &#123;&#125;</span><br><span class="line">func test2() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">var d = Dog()</span><br><span class="line">d.test1()</span><br><span class="line">d.test2()</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;MARK-TODO-FIXME&quot;&gt;&lt;a href=&quot;#MARK-TODO-FIXME&quot; class=&quot;headerlink&quot; title=&quot;MARK, TODO, FIXME&quot;&gt;&lt;/a&gt;MARK, TODO, FIXME&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&amp;#x2F;&amp;#</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Swift" scheme="http://www.hxtec.top/tags/Swift/"/>
    
    <category term="语法" scheme="http://www.hxtec.top/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Swift-Array的常见操作</title>
    <link href="http://www.hxtec.top/2022/09/19/Swift-Array%E7%9A%84%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/"/>
    <id>http://www.hxtec.top/2022/09/19/Swift-Array%E7%9A%84%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/</id>
    <published>2022-09-19T03:04:36.000Z</published>
    <updated>2022-09-19T03:55:19.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="map-filter-reduce-flatMap-compactMap"><a href="#map-filter-reduce-flatMap-compactMap" class="headerlink" title="map, filter, reduce, flatMap, compactMap"></a>map, filter, reduce, flatMap, compactMap</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4]</span><br><span class="line">// [2, 4, 6, 8]</span><br><span class="line">var arr2 = arr.map &#123; $0 * 2 &#125;</span><br><span class="line"></span><br><span class="line">// [2, 4]</span><br><span class="line">var arr3 = arr.filter &#123; $0 % 2 == 0 &#125;</span><br><span class="line"></span><br><span class="line">// 10</span><br><span class="line">var arr4 = arr.reduce(0) &#123; $0 + $1 &#125;</span><br><span class="line">// 10</span><br><span class="line">var arr5 = arr.reduce(0, +)</span><br><span class="line"></span><br><span class="line">func double(_ i: Int) -&gt; Int &#123; i * 2 &#125;</span><br><span class="line">var arr = [1, 2, 3, 4]</span><br><span class="line">// [2, 4, 6, 8]</span><br><span class="line">print(arr.map(double))</span><br><span class="line"></span><br><span class="line">var arr = [1, 2, 3]</span><br><span class="line">// [[1], [2, 2], [3, 3, 3]]</span><br><span class="line">var arr2 = arr.map &#123; Array.init(repeating: $0, count: $0) &#125;</span><br><span class="line"></span><br><span class="line">// [1, 2, 2, 3, 3, 3]</span><br><span class="line">var arr3 = arr.flatMap &#123; Array.init(repeating: $0, count: $0) &#125;</span><br><span class="line"></span><br><span class="line">var arr = [&quot;123&quot;, &quot;test&quot;, &quot;jack&quot;, &quot;-30&quot;]</span><br><span class="line">// [Optional(123), nil, nil, Optional(-30)]</span><br><span class="line">var arr2 = arr.map &#123; Int($0) &#125;</span><br><span class="line">// [123, -30]</span><br><span class="line">var arr3 = arr.compactMap &#123; Int($0) &#125;</span><br><span class="line"></span><br><span class="line">// 使用reduce实现map、filter的功能</span><br><span class="line">var arr = [1, 2, 3, 4]</span><br><span class="line">// [2, 4, 6, 8]</span><br><span class="line">print(arr.map &#123; $0 * 2 &#125;)</span><br><span class="line">print(arr.reduce([]) &#123; $0 + [$1 * 2] &#125;)</span><br><span class="line"></span><br><span class="line">// [2, 4]</span><br><span class="line">print(arr.filter &#123; $0 % 2 == 0 &#125;)</span><br><span class="line">print(arr.reduce([]) &#123; $1 % 2 == 0 ? $0 + [$1] : $0 &#125;)</span><br></pre></td></tr></table></figure><h3 id="lazy的优化"><a href="#lazy的优化" class="headerlink" title="lazy的优化"></a>lazy的优化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, 3]</span><br><span class="line">let result = arr.lazy.map &#123;</span><br><span class="line">    (i: Int) -&gt; Int in</span><br><span class="line">    print(&quot;mapping \(i)&quot;)</span><br><span class="line">    return i * 2 </span><br><span class="line">&#125;</span><br><span class="line">print(&quot;begin-----&quot;)</span><br><span class="line">print(&quot;mapped&quot;, result[0])</span><br><span class="line">print(&quot;mapped&quot;, result[1])</span><br><span class="line">print(&quot;mapped&quot;, result[2])</span><br><span class="line">print(&quot;end----&quot;)</span><br><span class="line"></span><br><span class="line">begin-----</span><br><span class="line">mapping 1</span><br><span class="line">mapped 2</span><br><span class="line">mapping 2</span><br><span class="line">mapped 4</span><br><span class="line">mapping 3</span><br><span class="line">mapped 6</span><br><span class="line">end----</span><br></pre></td></tr></table></figure><h3 id="Optional的map和flatMap"><a href="#Optional的map和flatMap" class="headerlink" title="Optional的map和flatMap"></a>Optional的map和flatMap</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">var num1: Int? = 10</span><br><span class="line">// Optional(20)</span><br><span class="line">var num2 = num1.map &#123; $0 * 2 &#125;</span><br><span class="line">var num3: Int? = nil</span><br><span class="line">// nil</span><br><span class="line">var num4 = num3.map &#123; $0 * 2 &#125;</span><br><span class="line"></span><br><span class="line">var num1: Int? = 10</span><br><span class="line">// Optional(Optional(20))</span><br><span class="line">var num2 = num1.map &#123; Optional.some($0 * 2) &#125;</span><br><span class="line">// Optional(20)</span><br><span class="line">var num3 = num1.flatMap &#123; Optional.some($0 * 2) &#125;</span><br><span class="line"></span><br><span class="line">var num1: Int? = 10</span><br><span class="line">// num2、num3是等价的</span><br><span class="line">var num2 = (num1 != nil) ? (num1! + 10) : nil</span><br><span class="line">var num3 = num1.map &#123; $0 + 10 &#125;</span><br><span class="line"></span><br><span class="line">var fmt = DateFormatter()</span><br><span class="line">fmt.dateFormat = &quot;yyyy-MM-dd&quot;</span><br><span class="line">var str: String? = &quot;2011-09-10&quot;</span><br><span class="line">// old</span><br><span class="line">var date1 = str != nil ? fmt.date(from: str!) : nil</span><br><span class="line">// new</span><br><span class="line">var date2 = str.flatMap(fmt.date)</span><br><span class="line"></span><br><span class="line">var score: Int? = 98</span><br><span class="line">// old</span><br><span class="line">var str1 = score != nil ? &quot;socre is \(score!)&quot; : &quot;No score&quot;</span><br><span class="line">// new</span><br><span class="line">var str2 = score.map &#123; &quot;score is \($0)&quot; &#125; ?? &quot;No score&quot;</span><br></pre></td></tr></table></figure><blockquote><p>示例1</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct Person &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    var age: Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var items = [</span><br><span class="line">    Person(name: &quot;jack&quot;, age: 20),</span><br><span class="line">    Person(name: &quot;rose&quot;, age: 21),</span><br><span class="line">    Person(name: &quot;kate&quot;, age: 22) </span><br><span class="line">]</span><br><span class="line">// old</span><br><span class="line">func getPerson1(_ name: String) -&gt; Person? &#123;</span><br><span class="line">    let index = items.firstIndex &#123; $0.name == name &#125;</span><br><span class="line">    return index != nil ? items[index!] : nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// new</span><br><span class="line">func getPerson2(_ name: String) -&gt; Person? &#123;</span><br><span class="line">    return items.firstIndex &#123; $0.name == name &#125;.map &#123; items[$0] &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>示例2</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">struct Person &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    var age: Int</span><br><span class="line">    init?(_ json: [String : Any]) &#123;</span><br><span class="line">        guard let name = json[&quot;name&quot;] as? String,</span><br><span class="line">        let age = json[&quot;age&quot;] as? Int else &#123;</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">    self.name = name</span><br><span class="line">    self.age = age</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var json: Dictionary? = [&quot;name&quot; : &quot;Jack&quot;, &quot;age&quot; : 10]</span><br><span class="line">// old</span><br><span class="line">var p1 = json != nil ? Person(json!) : nil</span><br><span class="line"></span><br><span class="line">// new</span><br><span class="line">var p2 = json.flatMap(Person.init)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;map-filter-reduce-flatMap-compactMap&quot;&gt;&lt;a href=&quot;#map-filter-reduce-flatMap-compactMap&quot; class=&quot;headerlink&quot; title=&quot;map, filter, reduce,</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Swift" scheme="http://www.hxtec.top/tags/Swift/"/>
    
    <category term="语法" scheme="http://www.hxtec.top/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Swift-String</title>
    <link href="http://www.hxtec.top/2022/09/19/Swift-String/"/>
    <id>http://www.hxtec.top/2022/09/19/Swift-String/</id>
    <published>2022-09-19T03:04:08.000Z</published>
    <updated>2022-09-19T03:53:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于String的思考"><a href="#关于String的思考" class="headerlink" title="关于String的思考"></a>关于String的思考</h2><ul><li>一个String变量战胜多少内存？</li><li>下面两个String变量，底层存储有什么不同？<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str1 = &quot;0123456789&quot;</span><br><span class="line">var str2 = &quot;0123456789ABCDEF&quot;</span><br></pre></td></tr></table></figure></li><li>如果对String进行拼接操作，String变量的存储会发生什么变化？<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str1.append(&quot;ABCDE&quot;)</span><br><span class="line"></span><br><span class="line">str1.append(&quot;F&quot;)</span><br><span class="line"></span><br><span class="line">str1.append(&quot;G&quot;)</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>分析</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 字符串长度 &lt;= 0xF(16位)，字符串内容直接存放在str1变量的内存中</span><br><span class="line"> var str1 = &quot;0123456789&quot;</span><br><span class="line"> </span><br><span class="line"> // 字符串长度 &gt; 0xF，字符串内容存放在__TEXT.cstring中（常量区）</span><br><span class="line"> // 字符串的地址值信息存放在str2变量的后8个字节中</span><br><span class="line"> var str2 = &quot;0123456789ABCDEF&quot;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> // 由于字符串长度 &lt;= 0xF，所以字符串内容依然存放在str1变量的内存中</span><br><span class="line"> str1.append(&quot;ABCDE&quot;)</span><br><span class="line"> // 开辟堆空间</span><br><span class="line"> str1.append(&quot;F&quot;)</span><br><span class="line"> </span><br><span class="line"> // 开辟堆空间</span><br><span class="line"> str2.append(&quot;G&quot;)</span><br></pre></td></tr></table></figure><h2 id="常规定义"><a href="#常规定义" class="headerlink" title="常规定义"></a>常规定义</h2><ul><li>Swift的字符串类型String，跟OC的NSString，在API设计上还是有较大差异<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 空字符串</span><br><span class="line">var emptyStr1 = &quot;&quot;</span><br><span class="line">var emptyStr2 = String()</span><br><span class="line"></span><br><span class="line">var str: String = &quot;1&quot;</span><br><span class="line">// 拼接，jack_rose</span><br><span class="line">str.append(&quot;_2&quot;)</span><br><span class="line">// 重载运算符 +</span><br><span class="line">str = str + &quot;_3&quot;</span><br><span class="line">// 重载运算符 +=</span><br><span class="line">str += &quot;_4&quot;</span><br><span class="line">// \()插值</span><br><span class="line">str = &quot;\(str)_5&quot;</span><br><span class="line">// 长度，9，1_2_3_4_5</span><br><span class="line">print(str.count)</span><br><span class="line"></span><br><span class="line">var str = &quot;123456&quot;</span><br><span class="line">print(str.hasPrefix(&quot;123&quot;)) // true</span><br><span class="line">print(str.hasSuffix(&quot;456&quot;)) // true</span><br></pre></td></tr></table></figure></li></ul><h3 id="String的插入和删除"><a href="#String的插入和删除" class="headerlink" title="String的插入和删除"></a>String的插入和删除</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;1_2&quot;</span><br><span class="line">// 1_2_</span><br><span class="line">str.insert(&quot;_&quot;, at: str.endIndex)</span><br><span class="line">// 1_2_3_4</span><br><span class="line">str.insert(contentsOf: &quot;3_4&quot;, at: str.endIndex)</span><br><span class="line">// 1666_2_3_4</span><br><span class="line">str.insert(contentsOf: &quot;666&quot;, at: str.index(after: str.startIndex))</span><br><span class="line">// 1666_2_3_8884</span><br><span class="line">str.insert(contentsOf: &quot;888&quot;, at: str.index(before: str.endIndex))</span><br><span class="line">// 1666hello_2_3_8884</span><br><span class="line">str.insert(contentsOf: &quot;hello&quot;, at: str.index(str.startIndex, offsetBy: 4))</span><br><span class="line"></span><br><span class="line">// 666hello_2_3_8884</span><br><span class="line">str.remove(at: str.firstIndex(of: &quot;1&quot;)!)</span><br><span class="line">// hello_2_3_8884</span><br><span class="line">str.removeAll &#123; $0 == &quot;6&quot; &#125;</span><br><span class="line">var range = str.index(str.endIndex, offsetBy: -4)..&lt;str.index(before: str.endIndex)</span><br><span class="line">// hello_2_3_4</span><br><span class="line">str.removeSubrange(range)</span><br></pre></td></tr></table></figure><h3 id="SubSting"><a href="#SubSting" class="headerlink" title="SubSting"></a>SubSting</h3><ul><li>String可以通过下标、prefix、suffix等截取子串，子串类型不是String，而是Substring<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;1_2_3_4_5&quot;</span><br><span class="line">// 1_2</span><br><span class="line">var substr1 = str.prefix(3)</span><br><span class="line">// 4_5</span><br><span class="line">var substr2 = str.suffix(3)</span><br><span class="line">// 1_2</span><br><span class="line">var range = str.startIndex..&lt;str.index(str.startIndex, offsetBy: 3)</span><br><span class="line">var substr3 = str[range]</span><br><span class="line">// 最初的String，1_2_3_4_5</span><br><span class="line">print(substr3.base)</span><br><span class="line">// Substring -&gt; String</span><br><span class="line">var str2 = String(substr3)</span><br></pre></td></tr></table></figure></li><li>Substring和它的base，共享字符串数据</li><li>Substring发生修改 或者 转为String时，会分配新的内存存储字符串数据</li></ul><h3 id="String与Character"><a href="#String与Character" class="headerlink" title="String与Character"></a>String与Character</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for c in &quot;jack&quot; &#123; // c是Character类型</span><br><span class="line">print(c)</span><br><span class="line">&#125;</span><br><span class="line">var str = &quot;jack&quot;</span><br><span class="line">// c是Character类型</span><br><span class="line">var c = str[str.startIndex]</span><br></pre></td></tr></table></figure><h3 id="String相关的协议"><a href="#String相关的协议" class="headerlink" title="String相关的协议"></a>String相关的协议</h3><ul><li>BidirectionalCollection 协议包含的部分内容<ul><li>startIndex、endIndex 属性、index 方法</li><li>String、Array 都遵守了这个协议</li></ul></li><li>RangeReplaceableCollection 协议包含的部分内容<ul><li>append、insert、remove 方法</li><li>String、Array 都遵守了这个协议</li></ul></li><li>Dictionary、Set 也有实现上述协议中声明的一些方法，只是并没有遵守上述协议</li></ul><h3 id="多行String"><a href="#多行String" class="headerlink" title="多行String"></a>多行String</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;&quot;&quot;</span><br><span class="line">1</span><br><span class="line">    &quot;2&quot;</span><br><span class="line">3</span><br><span class="line">    &#x27;4&#x27;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">//输出格式</span><br><span class="line">1</span><br><span class="line">    &quot;2&quot;</span><br><span class="line">3</span><br><span class="line">    &#x27;4&#x27;</span><br><span class="line"></span><br><span class="line">// 如果要显示3引号，至少转义1个引号</span><br><span class="line">let str = &quot;&quot;&quot;</span><br><span class="line">Escaping the first quote \&quot;&quot;&quot;</span><br><span class="line">Escaping two quotes \&quot;\&quot;&quot;</span><br><span class="line">Escaping all three quotes \&quot;\&quot;\&quot;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">Escaping the first quote &quot;&quot;&quot;</span><br><span class="line">Escaping two quotes &quot;&quot;&quot;</span><br><span class="line">Escaping all three quotes &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">// 缩进以结尾的3引号为对齐线</span><br><span class="line">let str = &quot;&quot;&quot;</span><br><span class="line">        1 </span><br><span class="line">            2 </span><br><span class="line">    3</span><br><span class="line">        4</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">//输出格式</span><br><span class="line">        1 </span><br><span class="line">            2</span><br><span class="line">    3 </span><br><span class="line">        4</span><br><span class="line"></span><br><span class="line">// 以下2个字符串是等价的</span><br><span class="line">let str1 = &quot;These are the same.&quot;</span><br><span class="line">let str2 = &quot;&quot;&quot;</span><br><span class="line">These are the same.</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><h3 id="String-与-NSString"><a href="#String-与-NSString" class="headerlink" title="String 与 NSString"></a>String 与 NSString</h3><ul><li>String 与 NSString 之间可以随时随地桥接转换</li><li>如果觉得String的API过于复杂难用，可以考虑将String转为NSString<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var str1: String = &quot;jack&quot;</span><br><span class="line">var str2: NSString = &quot;rose&quot;</span><br><span class="line"></span><br><span class="line">var str3 = str1 as NSString</span><br><span class="line">var str4 = str2 as String</span><br><span class="line"></span><br><span class="line">// ja</span><br><span class="line">var str5 = str3.substring(with: NSRange(location: 0, length: 2))</span><br><span class="line">print(str5) </span><br></pre></td></tr></table></figure></li><li>比较字符串内容是否等价 <ul><li>String使用 &#x3D;&#x3D; 运算符 </li><li>NSString使用isEqual方法，也可以使用 &#x3D;&#x3D; 运算符（本质还是调用了isEqual方法）</li></ul></li></ul><h2 id="Swift、OC桥接转换表"><a href="#Swift、OC桥接转换表" class="headerlink" title="Swift、OC桥接转换表"></a>Swift、OC桥接转换表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String ⇌ NSString</span><br><span class="line">String ← NSMutableString</span><br><span class="line">Array ⇌ NSArray</span><br><span class="line">Array ← NSMutableArray</span><br><span class="line">Dictionary ⇌ NSDictionary</span><br><span class="line">Dictionary ← NSMutableDictionary</span><br><span class="line">Set ⇌ NSSet</span><br><span class="line">Set ← NSMutableSet</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;关于String的思考&quot;&gt;&lt;a href=&quot;#关于String的思考&quot; class=&quot;headerlink&quot; title=&quot;关于String的思考&quot;&gt;&lt;/a&gt;关于String的思考&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;一个String变量战胜多少内存？&lt;/li&gt;
&lt;li&gt;下</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Swift" scheme="http://www.hxtec.top/tags/Swift/"/>
    
    <category term="语法" scheme="http://www.hxtec.top/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Swift-内存管理</title>
    <link href="http://www.hxtec.top/2022/09/19/Swift-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://www.hxtec.top/2022/09/19/Swift-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2022-09-19T03:03:56.000Z</published>
    <updated>2022-09-19T03:50:37.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>跟OC一样，Swift也是采取基于引用计数的ARC内存管理方案（针对堆空间）</li><li>Swfit的ARC中有3各引用<ul><li>强引用（Strong reference）：默认情况下，引用都是强引用</li><li>弱引用（weak reference）：通过weak定义弱引用<ul><li>必须是可选类型的var，因为实例销毁后，ARC会自动将弱引用设置为Nil</li><li>ARC自动给弱引用设置nil时，不会触发属性观察器</li></ul></li><li>无主引用（unowned reference）：通过unowned定义无主引用<ul><li>不会产生强引用，实例销毁后仍然存储着实例的内存地址（类似于OC中的unsafe_unretained）</li><li>试图在实例销毁后访问无主引用，会产生运行时错误（野指针）</li><li><strong>Fatal error: Attempted to read an unowned reference but object 0x0 was already deallocated</strong></li></ul></li></ul></li></ul><h3 id="weak、unowned的使用限制"><a href="#weak、unowned的使用限制" class="headerlink" title="weak、unowned的使用限制"></a>weak、unowned的使用限制</h3><ul><li>weak、owned只能用在类实例上面<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protocol Livable : AnyObject &#123;&#125;</span><br><span class="line">class Person &#123;&#125;</span><br><span class="line"></span><br><span class="line">weak var p0: Person?</span><br><span class="line">weak var p1: AnyObject?</span><br><span class="line">weak var p2: Livable?</span><br><span class="line"></span><br><span class="line">unowned var p10: Person?</span><br><span class="line">unowned var p11: AnyObject?</span><br><span class="line">unowned var p12: Livable?</span><br></pre></td></tr></table></figure></li></ul><h3 id="Autoreleasepool"><a href="#Autoreleasepool" class="headerlink" title="Autoreleasepool"></a>Autoreleasepool</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public func autoreleasepool&lt;Result&gt;(invoking body: () throws -&gt; Result) rethrows -&gt; Result</span><br><span class="line"></span><br><span class="line">autoreleasepool &#123;</span><br><span class="line">    let p = MJPerson(age: 20, name: &quot;Jack&quot;)</span><br><span class="line">    p.run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环引用（Reference-Cycle）"><a href="#循环引用（Reference-Cycle）" class="headerlink" title="循环引用（Reference Cycle）"></a>循环引用（Reference Cycle）</h3><ul><li>weak、unowned 都能解决循环引用的问题， <code>unowned </code> 要比  <code>weak </code> 少一些性能消耗</li><li>在生命周期中可能会变为 nil 的使用 weak</li><li>初始化赋值后再也不会变为 nil 的使用 unowned</li></ul><h3 id="闭包的循环引用"><a href="#闭包的循环引用" class="headerlink" title="闭包的循环引用"></a>闭包的循环引用</h3><ul><li><p>闭包表达式默认会用到的外层对象产生额外的强引用（对外层对象进行了retain操作）</p></li><li><p>正面代码会产生循环引用，导致Person对象无法释放（看不到Persion的deinit被调用）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    var fn: (() -&gt; ())?</span><br><span class="line">    func run() &#123; print(&quot;run&quot;) &#125;</span><br><span class="line">    deinit &#123; print(&quot;deinit&quot;) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func test() &#123;</span><br><span class="line">    let p = Person()</span><br><span class="line">    p.fn = &#123; p.run() &#125;</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br></pre></td></tr></table></figure></li><li><p>在闭包表达式的捕获列表声明weak或unowned引用，解决循环引用问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">p.fn = &#123;</span><br><span class="line">    [weak p] in</span><br><span class="line">    p?.run()//用weak修饰时，要用p?，可选</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p.fn = &#123;</span><br><span class="line">    [unowned p] in</span><br><span class="line">    p.run()//用unowned修饰是，用p， 非可选</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p.fn = &#123;</span><br><span class="line">    [weak wp = p, unowned up = p, a = 10 + 20] in</span><br><span class="line">    wp?.run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果想在定义闭包属性的同时引用self，这个闭包必须是lazy的（因为在实例初始化完毕之后才能引用self）</p></li><li><p>下面闭包fn内部如果用到了实例成员（属性、方法），<strong>编译器会强制要求明确写出 <code>self </code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    lazy var fn: (() -&gt; ()) = &#123;</span><br><span class="line">        [weak self] in</span><br><span class="line">        self?.run()</span><br><span class="line">    &#125;</span><br><span class="line">    func run() &#123; print(&quot;run&quot;) &#125;</span><br><span class="line">    deinit &#123; print(&quot;deinit&quot;) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果lazy属性是闭包调用的结果，那么不用考虑循环引用的问题（因为闭包调用后，闭包的生命周期就结束了）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    var age: Int = 0</span><br><span class="line">    </span><br><span class="line">    lazy var getAge: Int = &#123;</span><br><span class="line">        self.age</span><br><span class="line">    &#125;()//这个属性带有()执行方法</span><br><span class="line">    </span><br><span class="line">    deinit &#123; print(&quot;deinit&quot;) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="escaping"><a href="#escaping" class="headerlink" title="@escaping"></a>@escaping</h3><ul><li>非逃逸闭包、逃逸闭包，一般都是当做参数传递给函数</li><li><strong>非逃逸闭包</strong>：闭包调用发生在函数结束前，闭包调用在函数作用域内 </li><li><strong>逃逸闭包</strong>：闭包有可能在函数结束后调用，闭包调用逃离了函数的作用域，需要通过 <code>@escaping </code>声明<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import Dispatch</span><br><span class="line">typealias Fn = () -&gt; ()</span><br><span class="line"></span><br><span class="line">// fn是非逃逸闭包</span><br><span class="line">func test1(_ fn: Fn) &#123; fn() &#125;</span><br><span class="line"></span><br><span class="line">// fn是逃逸闭包</span><br><span class="line">var gFn: Fn?</span><br><span class="line">func test2(_ fn: @escaping Fn) &#123; gFn = fn &#125;</span><br><span class="line"></span><br><span class="line">// fn是逃逸闭包</span><br><span class="line">func test3(_ fn: @escaping Fn) &#123;</span><br><span class="line">    DispatchQueue.global().async &#123;</span><br><span class="line">        fn()</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">    var fn: Fn</span><br><span class="line">    // fn是逃逸闭包</span><br><span class="line">    init(fn: @escaping Fn) &#123;</span><br><span class="line">        self.fn = fn</span><br><span class="line">    &#125;</span><br><span class="line">    func run() &#123;</span><br><span class="line">        // DispatchQueue.global().async也是一个逃逸闭包</span><br><span class="line">        // 它用到了实例成员（属性、方法），编译器会强制要求明确写出self</span><br><span class="line">        DispatchQueue.global().async &#123;</span><br><span class="line">            self.fn()</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>逃逸闭包的注意点：<br>逃逸闭包不可以捕获inout参数</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typealias Fn = () -&gt; ()</span><br><span class="line">func other1(_ fn: Fn) &#123; fn() &#125;</span><br><span class="line">func other2(_ fn: @escaping Fn) &#123; fn() &#125;</span><br><span class="line"></span><br><span class="line">func test(value: inout Int) -&gt; Fn &#123;</span><br><span class="line">    other1 &#123; value += 1 &#125;</span><br><span class="line">    </span><br><span class="line">    // error: 逃逸闭包不能捕获inout参数</span><br><span class="line">    //other2 &#123; value += 1 &#125;</span><br><span class="line">    </span><br><span class="line">    func plus() &#123; value += 1 &#125;</span><br><span class="line">    // error: 逃逸闭包不能捕获inout参数</span><br><span class="line">    return plus</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;跟OC一样，Swift也是采取基于引用计数的ARC内存管理方案（针对堆空间）&lt;/li&gt;
&lt;li&gt;Swfit的ARC中有3各引用&lt;</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Swift" scheme="http://www.hxtec.top/tags/Swift/"/>
    
    <category term="语法" scheme="http://www.hxtec.top/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Swift-访问控制</title>
    <link href="http://www.hxtec.top/2022/09/19/Swift-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/"/>
    <id>http://www.hxtec.top/2022/09/19/Swift-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</id>
    <published>2022-09-19T03:03:43.000Z</published>
    <updated>2022-09-19T03:48:01.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定义解释"><a href="#定义解释" class="headerlink" title="定义解释"></a>定义解释</h3><ul><li>在访问权限控制这块，Swift提供了5个不同的访问级别（以下是从高到低排列， 实体指被访问级别修饰的内容）<ul><li><code>open </code>：允许在定义实体的模块、其他模块中访问，允许其他模块进行继承、重写（open只能用在类、类成员上）</li><li><code>public </code>：允许在定义实体的模块、其他模块中访问，不允许其他模块进行继承、重写</li><li><code>internal </code>：只允许在定义实体的模块中访问，不允许在其他模块中访问</li><li><code>fileprivate </code>：只允许在定义实体的源文件中访问</li><li><code>private </code>：只允许在定义实体的封闭声明中访问</li></ul></li><li>绝大部分实体默认都是 internal 级别</li></ul><h3 id="访问级别的使用准则"><a href="#访问级别的使用准则" class="headerlink" title="访问级别的使用准则"></a>访问级别的使用准则</h3><ul><li>一个实体不可以被理低访问级别的实体定义，比如：<ul><li>变量\常量类型 ≥ 变量\常量</li><li>参数类型、返回值类型 ≥ 函数</li><li>父类 ≥ 子类</li><li>父协议 ≥ 子协议</li><li>原类型 ≥ typealias</li><li>原始值类型、关联值类型 ≥ 枚举类型</li><li>定义类型A时用到的其他类型 ≥ 类型A </li><li>……</li></ul></li></ul><h3 id="元组类型"><a href="#元组类型" class="headerlink" title="元组类型"></a>元组类型</h3><ul><li>元组类型的访问级别是所有成员类型最低的那个<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">internal struct Dog &#123;&#125;</span><br><span class="line">fileprivate class Person &#123;&#125;</span><br><span class="line"></span><br><span class="line">// (Dog, Person)的访问级别是fileprivate</span><br><span class="line">fileprivate var data1: (Dog, Person)</span><br><span class="line">private var data2: (Dog, Person)</span><br></pre></td></tr></table></figure></li></ul><h3 id="泛型类型"><a href="#泛型类型" class="headerlink" title="泛型类型"></a>泛型类型</h3><ul><li>泛型类型的访问级别是  <code>类型的访问级别 </code> 以及  <code>所有泛型类型参数 </code>  的访问级别中最低的那个<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">internal class Car &#123;&#125;</span><br><span class="line">fileprivate class Dog &#123;&#125;</span><br><span class="line">public class Person&lt;T1, T2&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">// Person&lt;Car, Dog&gt;的访问级别是fileprivate</span><br><span class="line">fileprivate var p = Person&lt;Car, Dog&gt;()</span><br></pre></td></tr></table></figure></li></ul><h3 id="成员、嵌套类型"><a href="#成员、嵌套类型" class="headerlink" title="成员、嵌套类型"></a>成员、嵌套类型</h3><ul><li>类型的访问级别会影响成员（属性、方法、初始化器、下标）、嵌套类型的默认访问级别<ul><li>一般情况下，类型为private或fileprivate，那么成员\嵌套类型默认也是private或fileprivate</li><li>一般情况下，类型为internal或public，那么成员\嵌套类型默认是internal<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class PublicClass &#123;</span><br><span class="line">    public var p1 = 0 // public</span><br><span class="line">    var p2 = 0 // internal</span><br><span class="line">    fileprivate func f1() &#123;&#125; // fileprivate</span><br><span class="line">    private func f2() &#123;&#125; // private</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class InternalClass &#123; // internal</span><br><span class="line">    var p = 0 // internal</span><br><span class="line">    fileprivate func f1() &#123;&#125; // fileprivate</span><br><span class="line">    private func f2() &#123;&#125; // private</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fileprivate class FilePrivateClass &#123; // fileprivate</span><br><span class="line">    func f1() &#123;&#125; // fileprivate</span><br><span class="line">    private func f2() &#123;&#125; // private</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private class PrivateClass &#123; // private</span><br><span class="line">    func f() &#123;&#125; // private</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="成员的重写"><a href="#成员的重写" class="headerlink" title="成员的重写"></a>成员的重写</h3><ul><li>子类重写成员的访问级别必须 &gt;&#x3D; 子类的访问级别，或者 &gt;&#x3D; 父类被重写成员的访问级别</li><li>父类的成员不能被成员作用域外定义的子类重写<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private var age: Int = 0</span><br><span class="line">    </span><br><span class="line">    public class Student : Person &#123;</span><br><span class="line">        override var age: Int &#123;</span><br><span class="line">            set &#123;&#125;</span><br><span class="line">            get &#123;10&#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>####### 示例</p><ul><li>直接在全局作用域下定义的private等价于fileprivate<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private class Person &#123;&#125;</span><br><span class="line"></span><br><span class="line">fileprivate class Student : Person &#123;&#125;</span><br></pre></td></tr></table></figure></li><li>如果上面两句代码放在一个方法体中，就会报错<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func test &#123;</span><br><span class="line">    private class Person &#123;&#125;</span><br><span class="line"></span><br><span class="line">    fileprivate class Student : Person &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="getter-setter"><a href="#getter-setter" class="headerlink" title="getter, setter"></a>getter, setter</h3><ul><li>getter, setter默认自动接收它们所属环境的访问级别</li><li>可以给setter单独设置一个比getter更低的访问级别，用以限制写的权限<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fileprivate(set) public var num = 10</span><br><span class="line">class Person &#123;</span><br><span class="line">    private(set) var age = 0</span><br><span class="line">    fileprivate(set) public var weight: Int &#123;</span><br><span class="line">        set &#123;&#125;</span><br><span class="line">        get &#123; 10 &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    internal(set) public subscript(index: Int) -&gt; Int &#123;</span><br><span class="line">        set &#123;&#125;</span><br><span class="line">        get &#123; index &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="初始化器"><a href="#初始化器" class="headerlink" title="初始化器"></a>初始化器</h3><ul><li>如果一个 <code>public </code>类想在另一个模块调用编译生成的默认无参初始化器，必须显示提供 <code>public </code>的无参初始化器，因为 <code>public </code>类的默认初始化器是 <code>internal </code>级别</li><li>required初始化器 &gt;&#x3D; 它的默认访问级别</li><li>如果结构体有private\fileprivate的存储实例属性，那么它的成员初始化器也是private\fileprivate，否则默认就是Internal</li></ul><h3 id="枚举类型的case"><a href="#枚举类型的case" class="headerlink" title="枚举类型的case"></a>枚举类型的case</h3><ul><li><code>不能给枚举enum的每个case单独设置访问级别 </code></li><li>每个case自动接收enum的访问级别</li><li><code>public </code> enum定义的case 也是  <code>public </code></li></ul><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><ul><li>协议中定义的要求自动接收协议的访问级别，不能单独设置访问级别</li><li>public协议定义的要求也是public</li><li>协议实现的访问级别必须 &gt;&#x3D; 类型的访问级别，或者 &gt;&#x3D; 协议的访问级别</li></ul><blockquote><p>示例：</p></blockquote><ul><li>下面代码能编译通过么？<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public protocol Runnable &#123;</span><br><span class="line">    func run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Person : Runnable &#123;</span><br><span class="line">    func run() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>不能编译通过，由于类定义的public，public下默认为Internal，权限小于public。</li></ul><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><ul><li>如果有显式设置扩展的访问级别，扩展添加的成员自动接收扩展的访问级别</li><li>如果没有显式设置扩展的访问级别，扩展添加的成员的默认访问级别，跟直接在类型中定义的成员一样</li><li>可以单独给扩展添加的成员设置访问级别</li><li>不能给用于遵守协议的扩展显式设置扩展的访问级别</li><li>在同一文件中的扩展，可以写成类似多个部分的类型声明<ul><li>在原本的声明中声明一个私有成员，可以在同一文件的扩展中访问它</li><li>在扩展中声明一个私有成员，可以在同一文件的其他扩展中、原本声明中访问它</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private func run0() &#123;&#125;</span><br><span class="line">    private func eat0() &#123;</span><br><span class="line">        run1()</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension Person &#123;</span><br><span class="line">    private func run1() &#123;&#125;</span><br><span class="line">    private func eat1() &#123;</span><br><span class="line">        run0()</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension Person &#123;</span><br><span class="line">    private func eat2() &#123;</span><br><span class="line">        run1()</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将方法赋值给var-let"><a href="#将方法赋值给var-let" class="headerlink" title="将方法赋值给var\let"></a>将方法赋值给var\let</h3><ul><li>方法也可以像函数那样，赋值给一个let或者var<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct Person &#123;</span><br><span class="line">    var age: Int</span><br><span class="line">    func run(_ v: Int) &#123; print(&quot;func run&quot;, age, v) &#125;</span><br><span class="line">    static func run(_ v: Int) &#123; print(&quot;static func run&quot;, v) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let fn1 = Person.run</span><br><span class="line">fn1(10) // static func run 10</span><br><span class="line"></span><br><span class="line">let fn2: (Int) -&gt; () = Person.run</span><br><span class="line">fn2(20) // static func run 20</span><br><span class="line"></span><br><span class="line">let fn3: (Person) -&gt; ((Int) -&gt; ()) = Person.run</span><br><span class="line">fn3(Person(age: 18))(30) // func run 18 30</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;定义解释&quot;&gt;&lt;a href=&quot;#定义解释&quot; class=&quot;headerlink&quot; title=&quot;定义解释&quot;&gt;&lt;/a&gt;定义解释&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;在访问权限控制这块，Swift提供了5个不同的访问级别（以下是从高到低排列， 实体指被访问级别修饰的内容）&lt;ul</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Swift" scheme="http://www.hxtec.top/tags/Swift/"/>
    
    <category term="语法" scheme="http://www.hxtec.top/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Swift-扩展（Extension）</title>
    <link href="http://www.hxtec.top/2022/09/19/Swift-%E6%89%A9%E5%B1%95%EF%BC%88Extension%EF%BC%89/"/>
    <id>http://www.hxtec.top/2022/09/19/Swift-%E6%89%A9%E5%B1%95%EF%BC%88Extension%EF%BC%89/</id>
    <published>2022-09-19T03:03:24.000Z</published>
    <updated>2022-09-19T03:45:30.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>Swift中的扩展，有点类似于OC中的分类（Category）</li><li>扩展可以为枚举、结构体、类、协议添加新功能<ul><li>可以添加方法、计算属性、下标、（便捷）初始化器、嵌套类型、协议等等</li></ul></li><li>扩展不能办到的事情：<ul><li>不能覆盖原有的功能</li><li>不能添加存储属性，不能向已有的属性添加属性观察器</li><li>不能添加父类</li><li>不能添加指定初始化器，不能添加反初始化器</li><li>…</li></ul></li></ul><h4 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">extension Double &#123;</span><br><span class="line">    var km: Double &#123; self * 1_000.0 &#125;</span><br><span class="line">    var m: Double &#123; self &#125;</span><br><span class="line">    var dm: Double &#123; self / 10.0 &#125;</span><br><span class="line">    var cm: Double &#123; self / 100.0 &#125;</span><br><span class="line">    var mm: Double &#123; self / 1_000.0 &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">extension Array &#123;</span><br><span class="line">    subscript(nullable idx: Int) -&gt; Element? &#123;</span><br><span class="line">    if (startIndex..&lt;endIndex).contains(idx) &#123;</span><br><span class="line">        return self[idx]</span><br><span class="line">    &#125;</span><br><span class="line">    return nil</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法、嵌套类型"><a href="#方法、嵌套类型" class="headerlink" title="方法、嵌套类型"></a>方法、嵌套类型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">extension Int &#123;</span><br><span class="line">    func repetitions(task: () -&gt; Void) &#123;</span><br><span class="line">        for _ in 0..&lt;self &#123; task() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mutating func square() -&gt; Int &#123;</span><br><span class="line">        self = self * self</span><br><span class="line">        return self</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    enum Kind &#123; case negative, zero, positive &#125;</span><br><span class="line">    </span><br><span class="line">    var kind: Kind &#123;</span><br><span class="line">        switch self &#123;</span><br><span class="line">        case 0: return .zero</span><br><span class="line">        case let x where x &gt; 0: return .positive</span><br><span class="line">        default: return .negative</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    subscript(digitIndex: Int) -&gt; Int &#123;</span><br><span class="line">        var decimalBase = 1</span><br><span class="line">        for _ in 0..&lt;digitIndex &#123; decimalBase *= 10 &#125;</span><br><span class="line">        return (self / decimalBase) % 10</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="协议、初始化器"><a href="#协议、初始化器" class="headerlink" title="协议、初始化器"></a>协议、初始化器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    var age: Int</span><br><span class="line">    var name: String</span><br><span class="line">    init(age: Int, name: String) &#123;</span><br><span class="line">        self.age = age</span><br><span class="line">        self.name = name</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension Person : Equatable &#123;</span><br><span class="line">    static func == (left: Person, right: Person) -&gt; Bool &#123;</span><br><span class="line">        left.age == right.age &amp;&amp; left.name == right.name</span><br><span class="line">    &#125;</span><br><span class="line">    convenience init() &#123;</span><br><span class="line">        self.init(age: 0, name: &quot;&quot;) </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果希望自定义初始化器的同时，编译器也能够生成默认初始化器<ul><li>可以在扩展中编写自定义初始化器</li><li><code>required </code>初始化器也不能写在扩展中<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct Point &#123;</span><br><span class="line">    var x: Int = 0</span><br><span class="line">    var y: Int = 0 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension Point &#123;</span><br><span class="line">    init(_ point: Point) &#123;</span><br><span class="line">        self.init(x: point.x, y: point.y) </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p1 = Point()</span><br><span class="line">var p2 = Point(x: 10)</span><br><span class="line">var p3 = Point(y: 20)</span><br><span class="line">var p4 = Point(x: 10, y: 20)</span><br><span class="line">var p5 = Point(p4)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><ul><li>如果一个类型已经实现了协议的所有要求，但是还没有声明它遵守了这个协议， <code>可以通过扩展来让它遵守这个协议 </code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protocol TestProtocol &#123;</span><br><span class="line">    func test()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TestClass &#123;</span><br><span class="line">    func test() &#123;</span><br><span class="line">        print(&quot;test&quot;) </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension TestClass : TestProtocol &#123;&#125;</span><br></pre></td></tr></table></figure></li><li>编写一个函数，判断一个整数是否为奇数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 方法</span><br><span class="line">func isOdd&lt;T: BinaryInteger&gt;(_ i: T) -&gt; Bool &#123;</span><br><span class="line">    i % 2 != 0 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//给UInt, Int添加扩展</span><br><span class="line">extension BinaryInteger &#123;</span><br><span class="line">    func isOdd() -&gt; Bool &#123; self % 2 != 0 &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>扩展可以给协议提供默认实现，也间接实现【可选协议】的效果</li><li>扩展可以给协议扩充【协议中从未声明过的方法】<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">protocol TestProtocol &#123;</span><br><span class="line">    func test1()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 给协议添加扩展方法，以下为可选协议</span><br><span class="line">extension TestProtocol &#123;</span><br><span class="line">    func test1() &#123;</span><br><span class="line">        print(&quot;TestProtocol test1&quot;) </span><br><span class="line">    &#125;</span><br><span class="line">    func test2() &#123;</span><br><span class="line">        print(&quot;TestProtocol test2&quot;) </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 类</span><br><span class="line">class TestClass : TestProtocol &#123;&#125;</span><br><span class="line"></span><br><span class="line">var cls = TestClass()</span><br><span class="line">cls.test1() // TestProtocol test1</span><br><span class="line">cls.test2() // TestProtocol test2</span><br><span class="line"></span><br><span class="line">var cls2: TestProtocol = TestClass()</span><br><span class="line">cls2.test1() // TestProtocol test1</span><br><span class="line">cls2.test2() // TestProtocol test2</span><br><span class="line"></span><br><span class="line">class TestClass : TestProtocol &#123;</span><br><span class="line">    func test1() &#123; print(&quot;TestClass test1&quot;) &#125;</span><br><span class="line">    func test2() &#123; print(&quot;TestClass test2&quot;) &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var cls = TestClass()</span><br><span class="line">cls.test1() // TestClass test1</span><br><span class="line">cls.test2() // TestClass test2</span><br><span class="line"></span><br><span class="line">var cls2: TestProtocol = TestClass()</span><br><span class="line">cls2.test1() // TestClass test1</span><br><span class="line">cls2.test2() // TestProtocol test2，优先调用协议里的test2方法，由于cls2类遵守协议的方法。</span><br></pre></td></tr></table></figure></li></ul><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Stack&lt;E&gt; &#123;</span><br><span class="line">    var elements = [E]()</span><br><span class="line">    func push(_ element: E) &#123;</span><br><span class="line">        elements.append(element)</span><br><span class="line">    &#125;</span><br><span class="line">    func pop() -&gt; E &#123; elements.removeLast() &#125;</span><br><span class="line">    func size() -&gt; Int &#123; elements.count &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 扩展中依然可以使用原类型中的泛型类型</span><br><span class="line">extension Stack &#123;</span><br><span class="line">    func top() -&gt; E &#123; elements.last! &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 符合条件才扩展</span><br><span class="line">extension Stack : Equatable where E : Equatable &#123;</span><br><span class="line">    static func == (left: Stack, right: Stack) -&gt; Bool &#123;</span><br><span class="line">    left.elements == right.elements</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Swift中的扩展，有点类似于OC中的分类（Category）&lt;/li&gt;
&lt;li&gt;扩展可以为枚举、结构体、类、协议添加新功能&lt;u</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Swift" scheme="http://www.hxtec.top/tags/Swift/"/>
    
    <category term="语法" scheme="http://www.hxtec.top/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Swift-高级运算符</title>
    <link href="http://www.hxtec.top/2022/09/19/Swift-%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>http://www.hxtec.top/2022/09/19/Swift-%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6/</id>
    <published>2022-09-19T03:03:13.000Z</published>
    <updated>2022-09-19T03:43:04.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="举出运算符（Overflow-Operator）"><a href="#举出运算符（Overflow-Operator）" class="headerlink" title="举出运算符（Overflow Operator）"></a>举出运算符（Overflow Operator）</h3><ul><li>Swift的算数运算符出现溢出时会抛出运行时错误</li><li>Swift有溢出运算符（&amp;+，&amp;-，&amp;*），用来支持溢出运算<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var min = UInt8.min</span><br><span class="line">print(min &amp;- 1)//255，Int8.max</span><br><span class="line"></span><br><span class="line">var max = UInt8.max</span><br><span class="line">print(max &amp;+ 1) // 0, Int8.min</span><br><span class="line">print(max &amp;* 2) // 254, 等价于 max &amp;+ max</span><br></pre></td></tr></table></figure></li></ul><h3 id="运算符重载（Operator-Overload）"><a href="#运算符重载（Operator-Overload）" class="headerlink" title="运算符重载（Operator Overload）"></a>运算符重载（Operator Overload）</h3><ul><li>类、结构体、枚举可以为现有的运算符提供自定义的实现，这个操作叫做：运算符重载<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">struct Point &#123;</span><br><span class="line">    var x: Int, y: Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// + 的重载</span><br><span class="line">func + (p1: Point, p2: Point) -&gt; Point &#123;</span><br><span class="line">    Point(x: p1.x + p2.x, y: p1.y + p2.y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let p = Point(x: 10, y: 20) + Point(x: 11, y: 22)</span><br><span class="line">print(p)// Point(x: 21, y: 42)</span><br><span class="line"></span><br><span class="line">//静态方法，重载运算符</span><br><span class="line">struct Point &#123;</span><br><span class="line">    var x: Int, y: Int</span><br><span class="line">    // + 的重载</span><br><span class="line">    static func + (p1: Point, p2: Point) -&gt; Point &#123;</span><br><span class="line">        Point(x: p1.x + p2.x, y: p1.y + p2.y)</span><br><span class="line">    &#125;</span><br><span class="line">    // - 的重载</span><br><span class="line">    static func - (p1: Point, p2: Point) -&gt; Point &#123;</span><br><span class="line">        Point(x: p1.x - p2.x, y: p1.y - p2.y)</span><br><span class="line">    &#125;</span><br><span class="line">    // 前置- 的重载</span><br><span class="line">    static prefix func - (p: Point) -&gt; Point &#123;</span><br><span class="line">        Point(x: -p.x, y: -p.y) </span><br><span class="line">    &#125;</span><br><span class="line">    // += 的重载</span><br><span class="line">    static func += (p1: inout Point, p2: Point) &#123;</span><br><span class="line">        p1 = p1 + p2</span><br><span class="line">    &#125;</span><br><span class="line">    static prefix func ++ (p: inout Point) -&gt; Point &#123;</span><br><span class="line">        p += Point(x: 1, y: 1)</span><br><span class="line">        return p</span><br><span class="line">    &#125;</span><br><span class="line">    static postfix func ++ (p: inout Point) -&gt; Point &#123;</span><br><span class="line">        let tmp = p</span><br><span class="line">        p += Point(x: 1, y: 1)</span><br><span class="line">        return tmp</span><br><span class="line">    &#125;</span><br><span class="line">    static func  ` (p1: Point, p2: Point) -&gt; Bool &#123;</span><br><span class="line">        (p1.x  ` p2.x) &amp;&amp; (p1.y  ` p2.y) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Equatable"><a href="#Equatable" class="headerlink" title="Equatable"></a>Equatable</h3><ul><li>要想得知2个实例是否等价，一般做法是遵守Equatable协议，重载 &#96;运算符<ul><li>与此同时，等价于重载了 ! &#96; 运算符<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct Point : Equatable &#123;</span><br><span class="line">    var x: Int, y: Int</span><br><span class="line">&#125;</span><br><span class="line">var p1 = Point(x: 10, y: 20)</span><br><span class="line">var p2 = Point(x: 11, y: 22)</span><br><span class="line">print(p1  ` p2) // false</span><br><span class="line">print(p1 != p2) // true</span><br></pre></td></tr></table></figure></li></ul></li><li>Swift为以下类型提供默认的Equatable实现<ul><li>没有关联类型的枚举</li><li>只拥有遵守Equatable协议关联类型的枚举</li><li>只拥有遵守Equatable协议存储属性的结构体</li></ul></li><li>引用类型比较存储的地址值是否相等（是否引用着同一个对象），使用恒等运算符  <code>= 、! </code></li></ul><h3 id="Comparable"><a href="#Comparable" class="headerlink" title="Comparable"></a>Comparable</h3><ul><li>要想比较2个实例的大小，一般做法是：<ul><li>遵守Comparable协议</li><li>重载相应的运算符<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// score大的比较大，若score相等，age小的比较大</span><br><span class="line">struct Student : Comparable &#123;</span><br><span class="line">    var age: Int</span><br><span class="line">    var score: Int</span><br><span class="line">    init(score: Int, age: Int) &#123;</span><br><span class="line">    self.score = score</span><br><span class="line">    self.age = age</span><br><span class="line">    &#125;</span><br><span class="line">    static func &lt; (lhs: Student, rhs: Student) -&gt; Bool &#123;</span><br><span class="line">        (lhs.score &lt; rhs.score)</span><br><span class="line">            || (lhs.score  ` rhs.score &amp;&amp; lhs.age &gt; rhs.age)</span><br><span class="line">    &#125;</span><br><span class="line">    static func &gt; (lhs: Student, rhs: Student) -&gt; Bool &#123;</span><br><span class="line">        (lhs.score &gt; rhs.score)</span><br><span class="line">            || (lhs.score  ` rhs.score &amp;&amp; lhs.age &lt; rhs.age)    </span><br><span class="line">    &#125;</span><br><span class="line">    static func &lt;= (lhs: Student, rhs: Student) -&gt; Bool &#123;</span><br><span class="line">        !(lhs &gt; rhs)</span><br><span class="line">    &#125;</span><br><span class="line">    static func &gt;= (lhs: Student, rhs: Student) -&gt; Bool &#123;</span><br><span class="line">        !(lhs &lt; rhs)</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var stu1 = Student(score: 100, age: 20)</span><br><span class="line">var stu2 = Student(score: 98, age: 18)</span><br><span class="line">var stu3 = Student(score: 100, age: 20)</span><br><span class="line">print(stu1 &gt; stu2) // true</span><br><span class="line">print(stu1 &gt;= stu2) // true</span><br><span class="line">print(stu1 &gt;= stu3) // true</span><br><span class="line">print(stu1 &lt;= stu3) // true</span><br><span class="line">print(stu2 &lt; stu1) // true</span><br><span class="line">print(stu2 &lt;= stu1) // true</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="自定义运算符（Custom-Operator）"><a href="#自定义运算符（Custom-Operator）" class="headerlink" title="自定义运算符（Custom Operator）"></a>自定义运算符（Custom Operator）</h3><ul><li>可以自定义新的运算符：在全局作用域使用operator进行声明<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">prefix operator 前缀运算符</span><br><span class="line">postfix operator 后缀运算符</span><br><span class="line">infix operator 中缀运算符 : 优先级组</span><br><span class="line"></span><br><span class="line">precedencegroup 优先级组 &#123;</span><br><span class="line">    associativity: 结合性(left\right\none)</span><br><span class="line">    higherThan: 比谁的优先级高</span><br><span class="line">    lowerThan: 比谁的优先级低</span><br><span class="line">    assignment: true代表在可选链操作中拥有跟赋值运算符一样的优先级</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">prefix operator +++</span><br><span class="line">infix operator +- : PlusMinusPrecedence</span><br><span class="line">precedencegroup PlusMinusPrecedence &#123;</span><br><span class="line">    associativity: none</span><br><span class="line">    higherThan: AdditionPrecedence</span><br><span class="line">    lowerThan: MultiplicationPrecedence</span><br><span class="line">    assignment: true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Point &#123;</span><br><span class="line">    var x: Int, y: Int</span><br><span class="line">    static prefix func +++ (point: inout Point) -&gt; Point &#123;</span><br><span class="line">        point = Point(x: point.x + point.x, y: point.y + point.y)</span><br><span class="line">        return point</span><br><span class="line">    &#125;</span><br><span class="line">    static func +- (left: Point, right: Point) -&gt; Point &#123;</span><br><span class="line">        return Point(x: left.x + right.x, y: left.y - right.y)</span><br><span class="line">    &#125;</span><br><span class="line">    static func +- (left: Point?, right: Point) -&gt; Point &#123;</span><br><span class="line">        print(&quot;+-&quot;)</span><br><span class="line">        return Point(x: left?.x ?? 0 + right.x, y: left?.y ?? 0 - right.y) </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Person &#123;</span><br><span class="line">    var point: Point</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">var person: Person? = nil</span><br><span class="line">person?.point +- Point(x: 10, y: 20)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;举出运算符（Overflow-Operator）&quot;&gt;&lt;a href=&quot;#举出运算符（Overflow-Operator）&quot; class=&quot;headerlink&quot; title=&quot;举出运算符（Overflow Operator）&quot;&gt;&lt;/a&gt;举出运算符（Overflow</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Swift" scheme="http://www.hxtec.top/tags/Swift/"/>
    
    <category term="语法" scheme="http://www.hxtec.top/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Swift-泛型</title>
    <link href="http://www.hxtec.top/2022/09/19/Swift-%E6%B3%9B%E5%9E%8B/"/>
    <id>http://www.hxtec.top/2022/09/19/Swift-%E6%B3%9B%E5%9E%8B/</id>
    <published>2022-09-19T03:02:59.000Z</published>
    <updated>2022-09-19T03:41:34.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>-泛型可以将类型参数化，提高代码复用率，减少代码量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func swapValues&lt;T&gt;(_ a: inout T, _ b: inout T) &#123;</span><br><span class="line">    (a, b) = (b, a)</span><br><span class="line">&#125;</span><br><span class="line">var i1 = 10</span><br><span class="line">var i2 = 20</span><br><span class="line">swapValues(&amp;i1, &amp;i2)</span><br><span class="line">var d1 = 10.0</span><br><span class="line">var d2 = 20.0</span><br><span class="line">swapValues(&amp;d1, &amp;d2)</span><br><span class="line"></span><br><span class="line">struct Date &#123;</span><br><span class="line">    var year = 0, month = 0, day = 0 </span><br><span class="line">&#125;</span><br><span class="line">var dd1 = Date(year: 2011, month: 9, day: 10)</span><br><span class="line">var dd2 = Date(year: 2012, month: 10, day: 11)</span><br><span class="line">swapValues(&amp;dd1, &amp;dd2)</span><br></pre></td></tr></table></figure><ul><li>泛型函数赋值给变量<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func test&lt;T1, T2&gt;(_ t1: T1, _ t2: T2) &#123;&#125;</span><br><span class="line">var fn: (Int, Double) -&gt; () = test</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>代码示例</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Stack&lt;E&gt; &#123;</span><br><span class="line">    var elements = [E]()</span><br><span class="line">    func push(_ element: E) &#123; elements.append(element) &#125;</span><br><span class="line">    func pop() -&gt; E &#123; elements.removeLast() &#125;</span><br><span class="line">    func top() -&gt; E &#123; elements.last! &#125;</span><br><span class="line">    func size() -&gt; Int &#123; elements.count &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SubStack&lt;E&gt; : Stack&lt;E&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">var stack = Stack&lt;Int&gt;()</span><br><span class="line">stack.push(11)</span><br><span class="line">stack.push(22)</span><br><span class="line">stack.push(33)</span><br><span class="line">print(stack.top()) // 33</span><br><span class="line">print(stack.pop()) // 33</span><br><span class="line">print(stack.pop()) // 22</span><br><span class="line">print(stack.pop()) // 11</span><br><span class="line">print(stack.size()) // 0</span><br><span class="line"></span><br><span class="line">struct Stack&lt;E&gt; &#123;</span><br><span class="line">    var elements = [E]()</span><br><span class="line">    mutating func push(_ element: E) &#123; elements.append(element) &#125;</span><br><span class="line">    mutating func pop() -&gt; E &#123; elements.removeLast() &#125;</span><br><span class="line">    func top() -&gt; E &#123; elements.last! &#125;</span><br><span class="line">    func size() -&gt; Int &#123; elements.count &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum Score&lt;T&gt; &#123;</span><br><span class="line">    case point(T)</span><br><span class="line">    case grade(String) </span><br><span class="line">&#125;</span><br><span class="line">let score0 = Score&lt;Int&gt;.point(100)</span><br><span class="line">let score1 = Score.point(99)</span><br><span class="line">let score2 = Score.point(99.5)</span><br><span class="line">let score3 = Score&lt;Int&gt;.grade(&quot;A&quot;)</span><br></pre></td></tr></table></figure><h3 id="关联类型（Associated-Type）"><a href="#关联类型（Associated-Type）" class="headerlink" title="关联类型（Associated Type）"></a>关联类型（Associated Type）</h3><ul><li>关联类型的作用：给协议中用到的类型定义一个占位名称</li><li>协议中可以拥有多个关联类型<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">protocol Stackable &#123;</span><br><span class="line">    associatedtype Element // 关联类型</span><br><span class="line">    mutating func push(_ element: Element)</span><br><span class="line">    mutating func pop() -&gt; Element</span><br><span class="line">    func top() -&gt; Element</span><br><span class="line">    func size() -&gt; Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Stack&lt;E&gt; : Stackable &#123;</span><br><span class="line">    // typealias Element = E</span><br><span class="line">    var elements = [E]()</span><br><span class="line">    func push(_ element: E) &#123; </span><br><span class="line">        elements.append(element) </span><br><span class="line">    &#125;</span><br><span class="line">    func pop() -&gt; E &#123; elements.removeLast() &#125;</span><br><span class="line">    func top() -&gt; E &#123; elements.last! &#125;</span><br><span class="line">    func size() -&gt; Int &#123; elements.count &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class StringStack : Stackable &#123;</span><br><span class="line">    // 给关联类型设定真实类型</span><br><span class="line">    // typealias Element = String</span><br><span class="line">    var elements = [String]()</span><br><span class="line">    func push(_ element: String) &#123; elements.append(element) &#125;</span><br><span class="line">    func pop() -&gt; String &#123; elements.removeLast() &#125;</span><br><span class="line">    func top() -&gt; String &#123; elements.last! &#125;</span><br><span class="line">    func size() -&gt; Int &#123; elements.count &#125; </span><br><span class="line">&#125;</span><br><span class="line">var ss = StringStack()</span><br><span class="line">ss.push(&quot;Jack&quot;)</span><br><span class="line">ss.push(&quot;Rose&quot;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="类型约束"><a href="#类型约束" class="headerlink" title="类型约束"></a>类型约束</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">protocol Runnable &#123; &#125;</span><br><span class="line">class Person &#123; &#125;</span><br><span class="line">func swapValues&lt;T : Person &amp; Runnable&gt;(_ a: inout T, _ b: inout T) &#123;</span><br><span class="line">    (a, b) = (b, a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol Stackable &#123;</span><br><span class="line">    associatedtype Element: Equatable</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Stack&lt;E : Equatable&gt; : Stackable &#123; typealias Element = E &#125;</span><br><span class="line"></span><br><span class="line">func equal&lt;S1: Stackable, S2: Stackable&gt;(_ s1: S1, _ s2: S2) -&gt; Bool</span><br><span class="line">    where S1.Element  ` S2.Element, S1.Element : Hashable &#123;</span><br><span class="line">    return false</span><br><span class="line">&#125;</span><br><span class="line">var stack1 = Stack&lt;Int&gt;()</span><br><span class="line">var stack2 = Stack&lt;String&gt;()</span><br><span class="line">// error: requires the types &#x27;Int&#x27; and &#x27;String&#x27; be equivalent</span><br><span class="line">equal(stack1, stack2)</span><br></pre></td></tr></table></figure><h3 id="协议类型的注意点"><a href="#协议类型的注意点" class="headerlink" title="协议类型的注意点"></a>协议类型的注意点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protocol Runnable &#123;&#125;</span><br><span class="line">class Person : Runnable &#123;&#125;</span><br><span class="line">class Car : Runnable &#123;&#125;</span><br><span class="line">func get(_ type: Int) -&gt; Runnable &#123;</span><br><span class="line">    if type  ` 0 &#123;</span><br><span class="line">        return Person()</span><br><span class="line">    &#125;</span><br><span class="line">    return Car()</span><br><span class="line">&#125;</span><br><span class="line">var r1 = get(0)</span><br><span class="line">var r2 = get(1) </span><br></pre></td></tr></table></figure><ul><li>如果协议中有 <code>associatedtype </code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protocol Runnable &#123;</span><br><span class="line">    associatedtype Speed</span><br><span class="line">    var speed: Speed &#123; get &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person : Runnable &#123;</span><br><span class="line">    var speed: Double &#123; 0.0 &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Car : Runnable &#123;</span><br><span class="line">    var speed: Int &#123; 0 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="泛型解决"><a href="#泛型解决" class="headerlink" title="泛型解决"></a>泛型解决</h4><ul><li>解决方案①：使用泛型<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func get&lt;T : Runnable&gt;(_ type: Int) -&gt; T &#123;</span><br><span class="line">    if type  ` 0 &#123;</span><br><span class="line">        return Person() as! T </span><br><span class="line">    &#125;</span><br><span class="line">    return Car() as! T </span><br><span class="line">&#125;</span><br><span class="line">var r1: Person = get(0)</span><br><span class="line">var r2: Car = get(1)</span><br></pre></td></tr></table></figure></li></ul><h3 id="不透明类型（Opaque-Type）"><a href="#不透明类型（Opaque-Type）" class="headerlink" title="不透明类型（Opaque Type）"></a>不透明类型（Opaque Type）</h3><ul><li>解决方案②：使用some关键字声明一个不透明类型<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func get(_ type: Int) -&gt; some Runnable &#123; Car() &#125;</span><br><span class="line">var r1 = get(0)</span><br><span class="line">var r2 = get(1)</span><br></pre></td></tr></table></figure></li><li>some限制只能返回一种类型</li></ul><h4 id="some"><a href="#some" class="headerlink" title="some"></a>some</h4><ul><li>some除了用在返回值类型上，一般还可以用在属性类型上<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protocol Runnable &#123; associatedtype Speed &#125;</span><br><span class="line">class Dog : Runnable &#123; typealias Speed = Double &#125;</span><br><span class="line">class Person &#123;</span><br><span class="line">    var pet: some Runnable &#123;</span><br><span class="line">        return Dog()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="可选项的本质"><a href="#可选项的本质" class="headerlink" title="可选项的本质"></a>可选项的本质</h3><ul><li>可选项的本质是enum类型<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public enum Optional&lt;Wrapped&gt; : ExpressibleByNilLiteral &#123;</span><br><span class="line">    case none</span><br><span class="line">    case some(Wrapped)</span><br><span class="line">    public init(_ some: Wrapped)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var age: Int? = 10</span><br><span class="line">var age0: Optional&lt;Int&gt; = Optional&lt;Int&gt;.some(10)</span><br><span class="line">var age1: Optional = .some(10)</span><br><span class="line">var age2 = Optional.some(10)</span><br><span class="line">var age3 = Optional(10)</span><br><span class="line">age = nil</span><br><span class="line">age3 = .none</span><br><span class="line"></span><br><span class="line">var age: Int? = nil</span><br><span class="line">var age0 = Optional&lt;Int&gt;.none</span><br><span class="line">var age1: Optional&lt;Int&gt; = .none</span><br><span class="line"></span><br><span class="line">var age: Int? = .none</span><br><span class="line">age = 10</span><br><span class="line">age = .some(20)</span><br><span class="line">age = nil</span><br><span class="line"></span><br><span class="line">switch age &#123;</span><br><span class="line">    case let v?:</span><br><span class="line">        print(&quot;some&quot;, v)</span><br><span class="line">    case nil:</span><br><span class="line">        print(&quot;none&quot;) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">switch age &#123;</span><br><span class="line">    case let .some(v):</span><br><span class="line">        print(&quot;some&quot;, v)</span><br><span class="line">    case .none:</span><br><span class="line">        print(&quot;none&quot;) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 另一示例</span><br><span class="line">var age_: Int? = 10</span><br><span class="line">var age: Int?? = age_</span><br><span class="line">age = nil</span><br><span class="line"></span><br><span class="line">var age0 = Optional.some(Optional.some(10))</span><br><span class="line">age0 = .none</span><br><span class="line">var age1: Optional&lt;Optional&gt; = .some(.some(10))</span><br><span class="line">age1 = .none</span><br><span class="line"></span><br><span class="line">var age: Int?? = 10</span><br><span class="line">var age0: Optional&lt;Optional&gt; = 10</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;p&gt;-泛型可以将类型参数化，提高代码复用率，减少代码量&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;tab</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Swift" scheme="http://www.hxtec.top/tags/Swift/"/>
    
    <category term="语法" scheme="http://www.hxtec.top/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Swift-错误处理</title>
    <link href="http://www.hxtec.top/2022/09/19/Swift-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"/>
    <id>http://www.hxtec.top/2022/09/19/Swift-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</id>
    <published>2022-09-19T03:02:46.000Z</published>
    <updated>2022-09-19T03:39:18.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h3><ul><li>开发过程常见的错误<ul><li>语法错误（编译错误）</li><li>逻辑错误</li><li>运行时错误（可能会导致闪退，一般也叫做异常）</li><li>…</li></ul></li></ul><h3 id="自定义错误"><a href="#自定义错误" class="headerlink" title="自定义错误"></a>自定义错误</h3><ul><li><p>Swift中可以通过Error协议自定义运行时的错误信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum SomeError : Error &#123;</span><br><span class="line">    case illegalArg(String)</span><br><span class="line">    case outOfBounds(Int, Int)</span><br><span class="line">    case outOfMemory</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数内部通过throw抛出自定义Error，可能会抛出Error的函数必须加上 <code>throws </code>声明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func divide(_ num1: Int, _ num2: Int) throws -&gt; Int &#123;</span><br><span class="line">    if num2  ` 0 &#123;</span><br><span class="line">        throw SomeError.illegalArg(&quot;0不能作为除数&quot;) </span><br><span class="line">    &#125;</span><br><span class="line">    return num1 / num2</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p>需要使用 <code>try </code>调用可能会抛出Error的函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var result = try divide(20, 10)</span><br></pre></td></tr></table></figure></li></ul><h3 id="do-catch"><a href="#do-catch" class="headerlink" title="do-catch"></a>do-catch</h3><ul><li>可以使用do-catch捕捉Error<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">func test() &#123;</span><br><span class="line">    print(&quot;1&quot;)</span><br><span class="line">    do &#123;</span><br><span class="line">        print(&quot;2&quot;)</span><br><span class="line">        print(try divide(20, 0))</span><br><span class="line">        print(&quot;3&quot;)</span><br><span class="line">    &#125; catch let SomeError.illegalArg(msg) &#123;</span><br><span class="line">        print(&quot;参数异常:&quot;, msg)</span><br><span class="line">    &#125; catch let SomeError.outOfBounds(size, index) &#123;</span><br><span class="line">        print(&quot;下标越界:&quot;, &quot;size=\(size)&quot;, &quot;index=\(index)&quot;)</span><br><span class="line">    &#125; catch SomeError.outOfMemory &#123;</span><br><span class="line">        print(&quot;内存溢出&quot;)</span><br><span class="line">    &#125; catch &#123;</span><br><span class="line">        print(&quot;其他错误&quot;) &#125;</span><br><span class="line">        print(&quot;4&quot;) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test()</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// 参数异常: 0不能作为除数</span><br><span class="line">// 4</span><br><span class="line"></span><br><span class="line">do &#123;</span><br><span class="line">    try divide(20, 0)</span><br><span class="line">&#125; catch let error &#123;</span><br><span class="line">    switch error &#123;</span><br><span class="line">    case let SomeError.illegalArg(msg):</span><br><span class="line">        print(&quot;参数错误：&quot;, msg)</span><br><span class="line">    default:</span><br><span class="line">        print(&quot;其他错误&quot;) </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>抛出Error后，try下一句直到作用域结束的代码都将停止运行</li></ul><h3 id="处理Error"><a href="#处理Error" class="headerlink" title="处理Error"></a>处理Error</h3><ul><li>处理Error的2种方式</li><li>① 通过 <code>do-catch </code>捕捉Error</li><li>② 不捕捉Error，在当前函数增加 <code>throws </code>声明，Error将自动抛给上层函数</li><li>如果最顶层函数（main函数）依然没有捕捉Error，那么程序将终止<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">func test() throws &#123;</span><br><span class="line">    print(&quot;1&quot;)</span><br><span class="line">    print(try divide(20, 0))</span><br><span class="line">    print(&quot;2&quot;) </span><br><span class="line">&#125;</span><br><span class="line">try test()</span><br><span class="line">// 1</span><br><span class="line">// Fatal error: Error raised at top level</span><br><span class="line"></span><br><span class="line">do &#123;</span><br><span class="line">    print(try divide(20, 0))</span><br><span class="line">&#125; catch is SomeError &#123;</span><br><span class="line">    print(&quot;SomeError&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func test() throws &#123;</span><br><span class="line">    print(&quot;1&quot;)</span><br><span class="line">    do &#123;</span><br><span class="line">    print(&quot;2&quot;)</span><br><span class="line">    print(try divide(20, 0))</span><br><span class="line">    print(&quot;3&quot;)</span><br><span class="line">    &#125; catch let error as SomeError &#123;</span><br><span class="line">        print(error)</span><br><span class="line">    &#125;</span><br><span class="line">    print(&quot;4&quot;) </span><br><span class="line">&#125;</span><br><span class="line">try test()</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// illegalArg(&quot;0不能作为除数&quot;)</span><br><span class="line">// 4</span><br></pre></td></tr></table></figure></li></ul><h3 id="try-、try"><a href="#try-、try" class="headerlink" title="try?、try!"></a>try?、try!</h3><ul><li>可以使用try?、try!调用可能会抛出Error的函数，这样就不用去处理Error<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func test() &#123;</span><br><span class="line">    print(&quot;1&quot;)</span><br><span class="line">    var result1 = try? divide(20, 10) // Optional(2), Int?</span><br><span class="line">    var result2 = try? divide(20, 0) // nil</span><br><span class="line">    var result3 = try! divide(20, 10) // 2, Int</span><br><span class="line">    print(&quot;2&quot;)</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br></pre></td></tr></table></figure></li><li>a、b是等价的<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = try? divide(20, 0)</span><br><span class="line">var b: Int?</span><br><span class="line">do &#123;</span><br><span class="line">    b = try divide(20, 0)</span><br><span class="line">&#125; catch &#123; b = nil &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="rethrows"><a href="#rethrows" class="headerlink" title="rethrows"></a>rethrows</h3><ul><li>rethrows表明：函数本身不会抛出错误，但调用闭包参数抛出错误，那么它会将错误向上抛<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func exec(_ fn: (Int, Int) throws -&gt; Int, _ num1: Int, _ num2: Int) rethrows &#123;</span><br><span class="line">    print(try fn(num1, num2))</span><br><span class="line">&#125;</span><br><span class="line">// Fatal error: Error raised at top level</span><br><span class="line">try exec(divide, 20, 0)</span><br></pre></td></tr></table></figure></li></ul><h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><ul><li>defer语句：用来定义以任何方式（抛错误、return等）离开代码块前必须要执行的代码</li><li>defer语句将延迟至当前作用域结束之前执行<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">func open(_ filename: String) -&gt; Int &#123;</span><br><span class="line">    print(&quot;open&quot;)</span><br><span class="line">    return 0 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func close(_ file: Int) &#123;</span><br><span class="line">    print(&quot;close&quot;) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func processFile(_ filename: String) throws &#123;</span><br><span class="line">    let file = open(filename)</span><br><span class="line">    defer &#123;</span><br><span class="line">        close(file)</span><br><span class="line">    &#125;</span><br><span class="line">    // 使用file</span><br><span class="line">    // ....</span><br><span class="line">    try divide(20, 0)</span><br><span class="line">    // close将会在这里调用</span><br><span class="line">&#125;</span><br><span class="line">try processFile(&quot;test.txt&quot;)</span><br><span class="line">// open</span><br><span class="line">// close</span><br><span class="line">// Fatal error: Error raised at top level</span><br></pre></td></tr></table></figure></li><li>defer语句的执行顺序与定义顺序相反<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func fn1() &#123; print(&quot;fn1&quot;) &#125;</span><br><span class="line">func fn2() &#123; print(&quot;fn2&quot;) &#125;</span><br><span class="line">func test() &#123;</span><br><span class="line">    defer &#123; fn1() &#125;</span><br><span class="line">    defer &#123; fn2() &#125;</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br><span class="line">// fn2</span><br><span class="line">// fn1</span><br></pre></td></tr></table></figure></li></ul><h3 id="assert（断言）"><a href="#assert（断言）" class="headerlink" title="assert（断言）"></a>assert（断言）</h3><ul><li>很多编程语言都有断言机制：不符合指定条件就抛出运行时错误，常用于调试（Debug）阶段的条件判断</li><li>默认情况下，Swift的断言只会在Debug模式下生效，Release模式下会忽略<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func divide(_ v1: Int, _ v2: Int) -&gt; Int &#123;</span><br><span class="line">assert(v2 != 0, &quot;除数不能为0&quot;)</span><br><span class="line">return v1 / v2</span><br><span class="line">&#125;</span><br><span class="line">print(divide(20, 0))</span><br></pre></td></tr></table></figure></li><li>增加Swift Flags修改断言的默认行为</li><li><code>-assert-config Release </code>：强制关闭断言</li><li><code>-assert-config Debug </code>：强制开启断言</li></ul><h3 id="fatalError"><a href="#fatalError" class="headerlink" title="fatalError"></a>fatalError</h3><ul><li><p>如果遇到严重问题，希望结束程序运行时，可以直接使用fatalError函数抛出错误（这是无法通过do-catch捕捉的错误）</p></li><li><p>使用了fatalError函数，就不需要再写return</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func test(_ num: Int) -&gt; Int &#123;</span><br><span class="line">    if num &gt;= 0 &#123;</span><br><span class="line">        return 1 </span><br><span class="line">    &#125;</span><br><span class="line">    fatalError(&quot;num不能小于0&quot;) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在某些不得不实现、但不希望别人调用的方法，可以考虑内部使用fatalError函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123; required init() &#123;&#125; &#125;</span><br><span class="line">class Student : Person &#123;</span><br><span class="line">    required init() &#123; fatalError(&quot;don&#x27;t call Student.init&quot;) &#125;</span><br><span class="line">    init(score: Int) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">var stu1 = Student(score: 98)</span><br><span class="line">var stu2 = Student()</span><br></pre></td></tr></table></figure></li></ul><h3 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h3><ul><li>可以使用 do 实现局部作用域<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">    let dog1 = Dog()</span><br><span class="line">    dog1.age = 10</span><br><span class="line">    dog1.run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">do &#123;</span><br><span class="line">    let dog2 = Dog()</span><br><span class="line">    dog2.age = 10</span><br><span class="line">    dog2.run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;错误类型&quot;&gt;&lt;a href=&quot;#错误类型&quot; class=&quot;headerlink&quot; title=&quot;错误类型&quot;&gt;&lt;/a&gt;错误类型&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;开发过程常见的错误&lt;ul&gt;
&lt;li&gt;语法错误（编译错误）&lt;/li&gt;
&lt;li&gt;逻辑错误&lt;/li&gt;
&lt;li&gt;运行时错</summary>
      
    
    
    
    <category term="iOS" scheme="http://www.hxtec.top/categories/iOS/"/>
    
    
    <category term="Swift" scheme="http://www.hxtec.top/tags/Swift/"/>
    
    <category term="语法" scheme="http://www.hxtec.top/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
</feed>
